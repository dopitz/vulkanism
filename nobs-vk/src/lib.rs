//! # nobs-vk
//! no bullshit vulkan bindings.
//! 
//! This crate is auto generated by python scripts and provides types, constants and functions for [vulkan](https://www.khronos.org/vulkan/).
//! 
//! 1. [Existential questions](#existential-questions)
//! 2. [Examples](#examples)
//!     1. [Vulkan core initialisation](#vulkan-core-initialisation)
//!     2. [Manual Instance creation and extension loading](#manual-instance-creation-and-extension-loading)
//!     3. [Convenience Instance and Device creation](#convenience-instance-and-device-creation)
//! 3. [Details](#details)
//!     1. [Namespaces](#namespaces)
//!     2. [Function pointers](#function-pointers)
//!     3. [Check macros](#check-macros)
//!     4. [Instance and Device builder patterns](#instance-and-device-builder-patterns)
//! 
//! ## Existential questions
//! Why does nobs-vk exists? nobs-vk...
//! 1. is used how the vulkan api is documented
//! 2. is auto generated from a python script that sources the vk.xml from the vulkan registry
//! 3. gives you the freedom to do as you please in your design decisions (but therefore doesn't protect you from your own stupidity)
//! 4. is not a full blown window creating bloat library in the back, just to execute some small compute shader with a headless vulkan build
//! 
//! While more involved wrappers for vulkan do exist they also strife to completely hide the vulkan api behind another layer of rust code and might force you into design decisions you would normally try to avoid. This library tries to be as simple as possible and just exposes callable functions to vulkan.
//! 
//! ## Examples
//! ### Vulkan core initialisation
//! This is a simple example that retrieves the version of vulkan that is installed on the system
//! ```rust
//! #[macro_use] extern crate nobs_vk as vk;
//! //...
//! 
//! # fn main() {
//! // loads vulkan core
//! let _vk_lib = vk::Core::new();
//! 
//! // good to go from here, we can use any vulkan function that is supported by this system
//! // make sure _vk_lib lives throughout the time that vulkan is used and is dropped afterwards
//! 
//! // global vulkan version
//! let mut inst_ver: u32 = 0;
//! if vk::EnumerateInstanceVersion(&mut inst_ver) != vk::SUCCESS { 
//!   panic!("something went terribly wrong");
//! }
//! 
//! assert_eq!(1, version_major!(inst_ver));
//! assert_eq!(1, version_minor!(inst_ver));
//! assert_eq!(0, version_patch!(inst_ver));
//! # }
//! ```
//! 
//! ### Manual Instance creation and extension loading
//! After we created a vulkan instance we can load extensions
//! ```rust
//! #[macro_use] extern crate nobs_vk as vk;
//! use std::ffi::CString;
//! use std::ffi::CStr;
//! use std::ptr;
//! use std::os::raw::c_char;
//! # fn main() {
//! // ...
//! let _vk_lib = vk::Core::new();
//! 
//! // Define some extensions and convert them to c-strings
//! let ext_names = vec![vk::KHR_SURFACE_EXTENSION_NAME, vk::KHR_XLIB_SURFACE_EXTENSION_NAME];
//! let ext_names_cstr = ext_names
//!   .iter()
//!   .map(|e| CString::new(*e).unwrap())
//!   .collect::<Vec<CString>>();
//! let ext_names_ptr = ext_names_cstr
//!   .iter()
//!   .map(|e| e.as_ptr())
//!   .collect::<Vec<*const c_char>>();
//! 
//! // create the instance
//! let appinfo = vk::InstanceCreateInfo {
//!   sType: vk::STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
//!   pNext: ptr::null(),
//!   flags: 0,
//!   pApplicationInfo: ptr::null(),
//!   enabledLayerCount: 0,
//!   ppEnabledLayerNames: ptr::null(),
//!   enabledExtensionCount: ext_names.len() as u32,   // <- extension names go here
//!   ppEnabledExtensionNames: ext_names_ptr.as_ptr(), // <-
//! };
//! 
//! let mut inst = vk::NULL_HANDLE;
//! vk::CreateInstance(&appinfo, ptr::null(), &mut inst);
//! 
//! // not an extension, so we can call it no matter what
//! let mut num_devices: u32 = 0;
//! vk::EnumeratePhysicalDevices(inst, &mut num_devices, ptr::null_mut());
//! println!("num devices:  {}", num_devices);
//! 
//! // load extensions
//! // note that only extensions are loaded, that have been specified in ext_names
//! let ie = vk::InstanceExtensions::new(inst);
//! // we can now use instence extensions, e.g.:
//! // ie.CreateXlibSurfaceKHR(...)
//! 
//! // don't forget to clean up
//! vk::DestroyInstance(inst, ptr::null());
//! # }
//! ```
//! 
//! ### Convenience Instance and Device creation
//! Instance and device creation are a large portion of the boiler plate code that comes with implementing a vulkan application, so it makes sence to have a convenient way of doing this in the library (which is why you could argue that it barely does not contradicts the "no bullshit" paradigm)
//! ```rust
//! #[macro_use]
//! extern crate nobs_vk;
//! 
//! use nobs_vk as vk;
//! use std::ffi::CStr;
//! 
//! fn main() {
//!   let lib = vk::Core::new();
//!   let inst = vk::instance::new()
//!     .validate(vk::DEBUG_REPORT_ERROR_BIT_EXT | vk::DEBUG_REPORT_WARNING_BIT_EXT)
//!     .application("awesome app", 0)
//!     .add_extension(vk::KHR_SURFACE_EXTENSION_NAME)
//!     .add_extension(vk::KHR_XLIB_SURFACE_EXTENSION_NAME)
//!     .create(lib)
//!     .unwrap();
//! 
//!   for pd in vk::device::PhysicalDevice::enumerate_all(inst.handle) {
//!     println!(
//!       "instance api version:  {} {} {}",
//!       version_major!(pd.properties.apiVersion),
//!       version_minor!(pd.properties.apiVersion),
//!       version_patch!(pd.properties.apiVersion)
//!     );
//!     println!("driver version:        {}", pd.properties.driverVersion);
//!     println!("vendor id:             {}", pd.properties.vendorID);
//!     println!("device id:             {}", pd.properties.deviceID);
//!     println!("vendor:                {}", unsafe {
//!       CStr::from_ptr(&pd.properties.deviceName[0]).to_str().unwrap()
//!     });
//!     
//!     println!("layers:                {:?}", pd.supported_layers);
//!     println!("extensions:            {:?}", pd.supported_extensions);
//!   }
//! 
//!   let (_pdevice, _device) = vk::device::PhysicalDevice::enumerate_all(inst.handle)
//!     .remove(0)
//!     .into_device()
//!     .add_queue(vk::device::QueueProperties {
//!       present: false,
//!       graphics: true,
//!       compute: true,
//!       transfer: true,
//!     }).create()
//!     .unwrap();
//! }
//! ```
//! 
//! ## Details
//! ### Namespaces
//! Name prefixes of the C-types, enums and functions are removed in favor of the module namespace. 
//! For example `VK_Result` becomes `vk::Result`, `VK_SUCCESS` becomes `vk::SUCCESS`, `vkCreateInstance()` becomes `vk::CreateInstance()`.
//! 
//! ### Function pointers
//! Entry points to vulkan commands are placed in objects containing funcion pointes. After loading the function pointers contain the address to the respective vulkan API call. Vulkan commands are either core or extension. We provide two different mechanisms to load function pointers:
//! 
//! **Core commands** are loaded with [nobs_vk::Core::new](struct.Core.html#method.new) or [nobs_vk::Core::with_version](struct.Core.html#method.with_version). The returned object holds entry points to core vulkan commands and defines member function to call them. Additionaly global functions in the `nobs_vk` namespace are defined that may be called as long as a valid instance of `nobs_vk::Core` exists. *Warning: do not create multiple instances of `nobs_vk::Core`.*
//! 
//! **Instance and device extensions** are loaded with
//! `nobs_vk::[InstanceExtensions|DeviceExtensions]`. The two types hold entry points to vulkan extensions and define member functions to call them. Only those extension are loaded, that have been specified during instance/device creation (`enabledExtensionCount` and `ppEnabledExtensionNames` fields of fields of [VkInstanceCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkInstanceCreateInfo.html) and [VkDeviceCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkDeviceCreateInfo.html)).
//! 
//! Objects with function pointes define all commands that are listed the vulkan reference. In case a specific feature level is selected as well as platform or hardware vendor specific extensions the definitions for the functions or methods are not removed. However calling such a function, that is not supported will always cause a panic.
//! ### Check macros
//! Additionally to the [result integer constants](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkResult.html) that are defined by the vulkan api, the two enums [Success](enum.Success.html) and [Error](enum.Error.html) are declared. These capture the successful and unsuccessful error codes. The [vk_check!](macro.vk_check.html) converts the error code returned from vulkan with [make_result](fn.make_result.html) and prints debug information when the command failed. `vk_uncheck!` will consume the result and panic on error, while `vk_check!` returns the `Result<Success, Error>`
//! 
//! ### Instance and Device builder patterns
//! As the sole convenience feature this library introduces builder patterns for instance and device creation. This enables a convenient way of configuring e.g. debug layers for a vulkan instance, or extensions and properties of queues for devices. See [instance::Builder](instance/struct.Builder.html) and [device::Builder](device/struct.Builder.html) for more details
//! 
//! ## Vulkan reference
//! For documentation of the defined enums, structs and funcions see the 
//! [vulkan reference](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/).


#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]

use std::os::raw::c_char;
use std::os::raw::c_ushort;
use std::os::raw::c_ulong;
use std::os::raw::c_void;
use std::mem;



#[doc(hidden)] pub type SampleMask = u32;
#[doc(hidden)] pub type Bool32 = u32;
#[doc(hidden)] pub type Flags = u32;
#[doc(hidden)] pub type DeviceSize = u64;


#[doc(hidden)] pub const MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256u32;
#[doc(hidden)] pub const UUID_SIZE: u32 = 16u32;
#[doc(hidden)] pub const LUID_SIZE: u32 = 8u32;
#[doc(hidden)] pub const MAX_EXTENSION_NAME_SIZE: u32 = 256u32;
#[doc(hidden)] pub const MAX_DESCRIPTION_SIZE: u32 = 256u32;
#[doc(hidden)] pub const MAX_MEMORY_TYPES: u32 = 32u32;
#[doc(hidden)] pub const MAX_MEMORY_HEAPS: u32 = 16u32;
#[doc(hidden)] pub const LOD_CLAMP_NONE: f32 = 1000.0f32;
#[doc(hidden)] pub const REMAINING_MIP_LEVELS: u32 = !0u32;
#[doc(hidden)] pub const REMAINING_ARRAY_LAYERS: u32 = !0u32;
#[doc(hidden)] pub const WHOLE_SIZE: u64 = !0u64;
#[doc(hidden)] pub const ATTACHMENT_UNUSED: u32 = !0u32;
#[doc(hidden)] pub const TRUE: u32 = 1u32;
#[doc(hidden)] pub const FALSE: u32 = 0u32;
#[doc(hidden)] pub const QUEUE_FAMILY_IGNORED: u32 = !0u32;
#[doc(hidden)] pub const QUEUE_FAMILY_EXTERNAL: u32 = !0 - 1u32;
#[doc(hidden)] pub const QUEUE_FAMILY_FOREIGN_EXT: u32 = !0 - 2u32;
#[doc(hidden)] pub const SUBPASS_EXTERNAL: u32 = !0u32;
#[doc(hidden)] pub const MAX_DEVICE_GROUP_SIZE: u32 = 32u32;
#[doc(hidden)] pub const MAX_DRIVER_NAME_SIZE_KHR: u32 = 256u32;
#[doc(hidden)] pub const MAX_DRIVER_INFO_SIZE_KHR: u32 = 256u32;
#[doc(hidden)] pub const SHADER_UNUSED_NV: u32 = !0u32;


#[doc(hidden)] pub const KHR_SURFACE_EXTENSION_NAME: &str = "VK_KHR_surface";
#[doc(hidden)] pub const KHR_SWAPCHAIN_EXTENSION_NAME: &str = "VK_KHR_swapchain";
#[doc(hidden)] pub const KHR_DISPLAY_EXTENSION_NAME: &str = "VK_KHR_display";
#[doc(hidden)] pub const KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME: &str = "VK_KHR_display_swapchain";
#[doc(hidden)] pub const KHR_XLIB_SURFACE_EXTENSION_NAME: &str = "VK_KHR_xlib_surface";
#[doc(hidden)] pub const KHR_XCB_SURFACE_EXTENSION_NAME: &str = "VK_KHR_xcb_surface";
#[doc(hidden)] pub const KHR_WAYLAND_SURFACE_EXTENSION_NAME: &str = "VK_KHR_wayland_surface";
#[doc(hidden)] pub const KHR_ANDROID_SURFACE_EXTENSION_NAME: &str = "VK_KHR_android_surface";
#[doc(hidden)] pub const KHR_WIN32_SURFACE_EXTENSION_NAME: &str = "VK_KHR_win32_surface";
#[doc(hidden)] pub const EXT_DEBUG_REPORT_EXTENSION_NAME: &str = "VK_EXT_debug_report";
#[doc(hidden)] pub const NV_GLSL_SHADER_EXTENSION_NAME: &str = "VK_NV_glsl_shader";
#[doc(hidden)] pub const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME: &str = "VK_KHR_sampler_mirror_clamp_to_edge";
#[doc(hidden)] pub const IMG_FILTER_CUBIC_EXTENSION_NAME: &str = "VK_IMG_filter_cubic";
#[doc(hidden)] pub const AMD_RASTERIZATION_ORDER_EXTENSION_NAME: &str = "VK_AMD_rasterization_order";
#[doc(hidden)] pub const EXT_DEBUG_MARKER_EXTENSION_NAME: &str = "VK_EXT_debug_marker";
#[doc(hidden)] pub const NV_DEDICATED_ALLOCATION_EXTENSION_NAME: &str = "VK_NV_dedicated_allocation";
#[doc(hidden)] pub const EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME: &str = "VK_EXT_transform_feedback";
#[doc(hidden)] pub const AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME: &str = "VK_AMD_draw_indirect_count";
#[doc(hidden)] pub const AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME: &str = "VK_AMD_texture_gather_bias_lod";
#[doc(hidden)] pub const AMD_SHADER_INFO_EXTENSION_NAME: &str = "VK_AMD_shader_info";
#[doc(hidden)] pub const NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME: &str = "VK_NV_corner_sampled_image";
#[doc(hidden)] pub const KHR_MULTIVIEW_EXTENSION_NAME: &str = "VK_KHR_multiview";
#[doc(hidden)] pub const IMG_FORMAT_PVRTC_EXTENSION_NAME: &str = "VK_IMG_format_pvrtc";
#[doc(hidden)] pub const NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: &str = "VK_NV_external_memory_capabilities";
#[doc(hidden)] pub const NV_EXTERNAL_MEMORY_EXTENSION_NAME: &str = "VK_NV_external_memory";
#[doc(hidden)] pub const NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME: &str = "VK_NV_external_memory_win32";
#[doc(hidden)] pub const NV_WIN32_KEYED_MUTEX_EXTENSION_NAME: &str = "VK_NV_win32_keyed_mutex";
#[doc(hidden)] pub const KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME: &str = "VK_KHR_get_physical_device_properties2";
#[doc(hidden)] pub const KHR_DEVICE_GROUP_EXTENSION_NAME: &str = "VK_KHR_device_group";
#[doc(hidden)] pub const EXT_VALIDATION_FLAGS_EXTENSION_NAME: &str = "VK_EXT_validation_flags";
#[doc(hidden)] pub const NN_VI_SURFACE_EXTENSION_NAME: &str = "VK_NN_vi_surface";
#[doc(hidden)] pub const EXT_ASTC_DECODE_MODE_EXTENSION_NAME: &str = "VK_EXT_astc_decode_mode";
#[doc(hidden)] pub const KHR_MAINTENANCE1_EXTENSION_NAME: &str = "VK_KHR_maintenance1";
#[doc(hidden)] pub const KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME: &str = "VK_KHR_device_group_creation";
#[doc(hidden)] pub const KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: &str = "VK_KHR_external_memory_capabilities";
#[doc(hidden)] pub const KHR_EXTERNAL_MEMORY_EXTENSION_NAME: &str = "VK_KHR_external_memory";
#[doc(hidden)] pub const KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME: &str = "VK_KHR_external_memory_win32";
#[doc(hidden)] pub const KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME: &str = "VK_KHR_external_memory_fd";
#[doc(hidden)] pub const KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME: &str = "VK_KHR_win32_keyed_mutex";
#[doc(hidden)] pub const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME: &str = "VK_KHR_external_semaphore_capabilities";
#[doc(hidden)] pub const KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME: &str = "VK_KHR_external_semaphore";
#[doc(hidden)] pub const KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME: &str = "VK_KHR_external_semaphore_win32";
#[doc(hidden)] pub const KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME: &str = "VK_KHR_external_semaphore_fd";
#[doc(hidden)] pub const KHR_PUSH_DESCRIPTOR_EXTENSION_NAME: &str = "VK_KHR_push_descriptor";
#[doc(hidden)] pub const EXT_CONDITIONAL_RENDERING_EXTENSION_NAME: &str = "VK_EXT_conditional_rendering";
#[doc(hidden)] pub const KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME: &str = "VK_KHR_shader_float16_int8";
#[doc(hidden)] pub const KHR_16BIT_STORAGE_EXTENSION_NAME: &str = "VK_KHR_16bit_storage";
#[doc(hidden)] pub const KHR_INCREMENTAL_PRESENT_EXTENSION_NAME: &str = "VK_KHR_incremental_present";
#[doc(hidden)] pub const KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME: &str = "VK_KHR_descriptor_update_template";
#[doc(hidden)] pub const NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME: &str = "VK_NVX_device_generated_commands";
#[doc(hidden)] pub const NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME: &str = "VK_NV_clip_space_w_scaling";
#[doc(hidden)] pub const EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME: &str = "VK_EXT_direct_mode_display";
#[doc(hidden)] pub const EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME: &str = "VK_EXT_acquire_xlib_display";
#[doc(hidden)] pub const EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME: &str = "VK_EXT_display_surface_counter";
#[doc(hidden)] pub const EXT_DISPLAY_CONTROL_EXTENSION_NAME: &str = "VK_EXT_display_control";
#[doc(hidden)] pub const GOOGLE_DISPLAY_TIMING_EXTENSION_NAME: &str = "VK_GOOGLE_display_timing";
#[doc(hidden)] pub const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME: &str = "VK_NVX_multiview_per_view_attributes";
#[doc(hidden)] pub const NV_VIEWPORT_SWIZZLE_EXTENSION_NAME: &str = "VK_NV_viewport_swizzle";
#[doc(hidden)] pub const EXT_DISCARD_RECTANGLES_EXTENSION_NAME: &str = "VK_EXT_discard_rectangles";
#[doc(hidden)] pub const EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME: &str = "VK_EXT_conservative_rasterization";
#[doc(hidden)] pub const EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME: &str = "VK_EXT_swapchain_colorspace";
#[doc(hidden)] pub const EXT_HDR_METADATA_EXTENSION_NAME: &str = "VK_EXT_hdr_metadata";
#[doc(hidden)] pub const KHR_CREATE_RENDERPASS_2_EXTENSION_NAME: &str = "VK_KHR_create_renderpass2";
#[doc(hidden)] pub const KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME: &str = "VK_KHR_shared_presentable_image";
#[doc(hidden)] pub const KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME: &str = "VK_KHR_external_fence_capabilities";
#[doc(hidden)] pub const KHR_EXTERNAL_FENCE_EXTENSION_NAME: &str = "VK_KHR_external_fence";
#[doc(hidden)] pub const KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME: &str = "VK_KHR_external_fence_win32";
#[doc(hidden)] pub const KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME: &str = "VK_KHR_external_fence_fd";
#[doc(hidden)] pub const KHR_MAINTENANCE2_EXTENSION_NAME: &str = "VK_KHR_maintenance2";
#[doc(hidden)] pub const KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME: &str = "VK_KHR_get_surface_capabilities2";
#[doc(hidden)] pub const KHR_VARIABLE_POINTERS_EXTENSION_NAME: &str = "VK_KHR_variable_pointers";
#[doc(hidden)] pub const KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME: &str = "VK_KHR_get_display_properties2";
#[doc(hidden)] pub const MVK_IOS_SURFACE_EXTENSION_NAME: &str = "VK_MVK_ios_surface";
#[doc(hidden)] pub const MVK_MACOS_SURFACE_EXTENSION_NAME: &str = "VK_MVK_macos_surface";
#[doc(hidden)] pub const EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME: &str = "VK_EXT_external_memory_dma_buf";
#[doc(hidden)] pub const EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME: &str = "VK_EXT_queue_family_foreign";
#[doc(hidden)] pub const KHR_DEDICATED_ALLOCATION_EXTENSION_NAME: &str = "VK_KHR_dedicated_allocation";
#[doc(hidden)] pub const EXT_DEBUG_UTILS_EXTENSION_NAME: &str = "VK_EXT_debug_utils";
#[doc(hidden)] pub const ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME: &str = "VK_ANDROID_external_memory_android_hardware_buffer";
#[doc(hidden)] pub const EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME: &str = "VK_EXT_sampler_filter_minmax";
#[doc(hidden)] pub const EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME: &str = "VK_EXT_inline_uniform_block";
#[doc(hidden)] pub const EXT_SAMPLE_LOCATIONS_EXTENSION_NAME: &str = "VK_EXT_sample_locations";
#[doc(hidden)] pub const KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME: &str = "VK_KHR_get_memory_requirements2";
#[doc(hidden)] pub const KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME: &str = "VK_KHR_image_format_list";
#[doc(hidden)] pub const EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME: &str = "VK_EXT_blend_operation_advanced";
#[doc(hidden)] pub const NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME: &str = "VK_NV_fragment_coverage_to_color";
#[doc(hidden)] pub const NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME: &str = "VK_NV_framebuffer_mixed_samples";
#[doc(hidden)] pub const NV_FILL_RECTANGLE_EXTENSION_NAME: &str = "VK_NV_fill_rectangle";
#[doc(hidden)] pub const KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME: &str = "VK_KHR_sampler_ycbcr_conversion";
#[doc(hidden)] pub const KHR_BIND_MEMORY_2_EXTENSION_NAME: &str = "VK_KHR_bind_memory2";
#[doc(hidden)] pub const EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME: &str = "VK_EXT_image_drm_format_modifier";
#[doc(hidden)] pub const EXT_VALIDATION_CACHE_EXTENSION_NAME: &str = "VK_EXT_validation_cache";
#[doc(hidden)] pub const EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME: &str = "VK_EXT_descriptor_indexing";
#[doc(hidden)] pub const NV_SHADING_RATE_IMAGE_EXTENSION_NAME: &str = "VK_NV_shading_rate_image";
#[doc(hidden)] pub const NV_RAY_TRACING_EXTENSION_NAME: &str = "VK_NV_ray_tracing";
#[doc(hidden)] pub const NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME: &str = "VK_NV_representative_fragment_test";
#[doc(hidden)] pub const KHR_MAINTENANCE3_EXTENSION_NAME: &str = "VK_KHR_maintenance3";
#[doc(hidden)] pub const KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME: &str = "VK_KHR_draw_indirect_count";
#[doc(hidden)] pub const EXT_GLOBAL_PRIORITY_EXTENSION_NAME: &str = "VK_EXT_global_priority";
#[doc(hidden)] pub const KHR_8BIT_STORAGE_EXTENSION_NAME: &str = "VK_KHR_8bit_storage";
#[doc(hidden)] pub const EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME: &str = "VK_EXT_external_memory_host";
#[doc(hidden)] pub const AMD_BUFFER_MARKER_EXTENSION_NAME: &str = "VK_AMD_buffer_marker";
#[doc(hidden)] pub const KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME: &str = "VK_KHR_shader_atomic_int64";
#[doc(hidden)] pub const EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME: &str = "VK_EXT_calibrated_timestamps";
#[doc(hidden)] pub const AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME: &str = "VK_AMD_shader_core_properties";
#[doc(hidden)] pub const AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME: &str = "VK_AMD_memory_overallocation_behavior";
#[doc(hidden)] pub const EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME: &str = "VK_EXT_vertex_attribute_divisor";
#[doc(hidden)] pub const KHR_DRIVER_PROPERTIES_EXTENSION_NAME: &str = "VK_KHR_driver_properties";
#[doc(hidden)] pub const KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME: &str = "VK_KHR_shader_float_controls";
#[doc(hidden)] pub const NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME: &str = "VK_NV_shader_subgroup_partitioned";
#[doc(hidden)] pub const KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME: &str = "VK_KHR_swapchain_mutable_format";
#[doc(hidden)] pub const NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME: &str = "VK_NV_compute_shader_derivatives";
#[doc(hidden)] pub const NV_MESH_SHADER_EXTENSION_NAME: &str = "VK_NV_mesh_shader";
#[doc(hidden)] pub const NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME: &str = "VK_NV_fragment_shader_barycentric";
#[doc(hidden)] pub const NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME: &str = "VK_NV_shader_image_footprint";
#[doc(hidden)] pub const NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME: &str = "VK_NV_scissor_exclusive";
#[doc(hidden)] pub const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME: &str = "VK_NV_device_diagnostic_checkpoints";
#[doc(hidden)] pub const KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME: &str = "VK_KHR_vulkan_memory_model";
#[doc(hidden)] pub const EXT_PCI_BUS_INFO_EXTENSION_NAME: &str = "VK_EXT_pci_bus_info";
#[doc(hidden)] pub const FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME: &str = "VK_FUCHSIA_imagepipe_surface";
#[doc(hidden)] pub const EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME: &str = "VK_EXT_fragment_density_map";
#[doc(hidden)] pub const EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME: &str = "VK_EXT_scalar_block_layout";
#[doc(hidden)] pub const EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME: &str = "VK_EXT_separate_stencil_usage";


#[doc(hidden)] pub const NULL_HANDLE: u64 = 0;
#[doc(hidden)] pub type Instance = u64;
#[doc(hidden)] pub type PhysicalDevice = u64;
#[doc(hidden)] pub type Device = u64;
#[doc(hidden)] pub type Queue = u64;
#[doc(hidden)] pub type CommandBuffer = u64;
#[doc(hidden)] pub type DeviceMemory = u64;
#[doc(hidden)] pub type CommandPool = u64;
#[doc(hidden)] pub type Buffer = u64;
#[doc(hidden)] pub type BufferView = u64;
#[doc(hidden)] pub type Image = u64;
#[doc(hidden)] pub type ImageView = u64;
#[doc(hidden)] pub type ShaderModule = u64;
#[doc(hidden)] pub type Pipeline = u64;
#[doc(hidden)] pub type PipelineLayout = u64;
#[doc(hidden)] pub type Sampler = u64;
#[doc(hidden)] pub type DescriptorSet = u64;
#[doc(hidden)] pub type DescriptorSetLayout = u64;
#[doc(hidden)] pub type DescriptorPool = u64;
#[doc(hidden)] pub type Fence = u64;
#[doc(hidden)] pub type Semaphore = u64;
#[doc(hidden)] pub type Event = u64;
#[doc(hidden)] pub type QueryPool = u64;
#[doc(hidden)] pub type Framebuffer = u64;
#[doc(hidden)] pub type RenderPass = u64;
#[doc(hidden)] pub type PipelineCache = u64;
#[doc(hidden)] pub type ObjectTableNVX = u64;
#[doc(hidden)] pub type IndirectCommandsLayoutNVX = u64;
#[doc(hidden)] pub type DescriptorUpdateTemplate = u64;
#[doc(hidden)] pub type SamplerYcbcrConversion = u64;
#[doc(hidden)] pub type ValidationCacheEXT = u64;
#[doc(hidden)] pub type AccelerationStructureNV = u64;
#[doc(hidden)] pub type DisplayKHR = u64;
#[doc(hidden)] pub type DisplayModeKHR = u64;
#[doc(hidden)] pub type SurfaceKHR = u64;
#[doc(hidden)] pub type SwapchainKHR = u64;
#[doc(hidden)] pub type DebugReportCallbackEXT = u64;
#[doc(hidden)] pub type DebugUtilsMessengerEXT = u64;


#[doc(hidden)] pub type PFN_vkVoidFunction = extern "system" fn() -> ();

#[doc(hidden)] pub type PFN_vkInternalAllocationNotification = extern "system" fn(*mut c_void, usize, InternalAllocationType, SystemAllocationScope) -> ();

#[doc(hidden)] pub type PFN_vkInternalFreeNotification = extern "system" fn(*mut c_void, usize, InternalAllocationType, SystemAllocationScope) -> ();

#[doc(hidden)] pub type PFN_vkReallocationFunction = extern "system" fn(*mut c_void, *mut c_void, usize, usize, SystemAllocationScope) -> *mut c_void;

#[doc(hidden)] pub type PFN_vkAllocationFunction = extern "system" fn(*mut c_void, usize, usize, SystemAllocationScope) -> *mut c_void;

#[doc(hidden)] pub type PFN_vkFreeFunction = extern "system" fn(*mut c_void, *mut c_void) -> ();

#[doc(hidden)] pub type PFN_vkDebugReportCallbackEXT = extern "system" fn(flags: DebugReportFlagsEXT, objectType: DebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *mut c_char, pMessage: *mut c_char, pUserData: *mut c_void) -> Bool32;

#[doc(hidden)] pub type PFN_vkDebugUtilsMessengerCallbackEXT = extern "system" fn(messageSeverity: DebugUtilsMessageSeverityFlagBitsEXT, messageTypes: DebugUtilsMessageTypeFlagsEXT, pCallbackData: *const DebugUtilsMessengerCallbackDataEXT, pUserData: *mut c_void) -> Bool32;



#[doc(hidden)] pub type FramebufferCreateFlags = Flags;

#[doc(hidden)] pub type QueryPoolCreateFlags = Flags;

#[doc(hidden)] pub type RenderPassCreateFlags = Flags;

#[doc(hidden)] pub type SamplerCreateFlags = Flags;

#[doc(hidden)] pub type PipelineLayoutCreateFlags = Flags;

#[doc(hidden)] pub type PipelineCacheCreateFlags = Flags;

#[doc(hidden)] pub type PipelineDepthStencilStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineDynamicStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineColorBlendStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineMultisampleStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineRasterizationStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineViewportStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineTessellationStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineInputAssemblyStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineVertexInputStateCreateFlags = Flags;

#[doc(hidden)] pub type PipelineShaderStageCreateFlags = Flags;

#[doc(hidden)] pub type DescriptorSetLayoutCreateFlags = Flags;

#[doc(hidden)] pub type BufferViewCreateFlags = Flags;

#[doc(hidden)] pub type InstanceCreateFlags = Flags;

#[doc(hidden)] pub type DeviceCreateFlags = Flags;

#[doc(hidden)] pub type DeviceQueueCreateFlags = Flags;

#[doc(hidden)] pub type QueueFlags = Flags;

#[doc(hidden)] pub type MemoryPropertyFlags = Flags;

#[doc(hidden)] pub type MemoryHeapFlags = Flags;

#[doc(hidden)] pub type AccessFlags = Flags;

#[doc(hidden)] pub type BufferUsageFlags = Flags;

#[doc(hidden)] pub type BufferCreateFlags = Flags;

#[doc(hidden)] pub type ShaderStageFlags = Flags;

#[doc(hidden)] pub type ImageUsageFlags = Flags;

#[doc(hidden)] pub type ImageCreateFlags = Flags;

#[doc(hidden)] pub type ImageViewCreateFlags = Flags;

#[doc(hidden)] pub type PipelineCreateFlags = Flags;

#[doc(hidden)] pub type ColorComponentFlags = Flags;

#[doc(hidden)] pub type FenceCreateFlags = Flags;

#[doc(hidden)] pub type SemaphoreCreateFlags = Flags;

#[doc(hidden)] pub type FormatFeatureFlags = Flags;

#[doc(hidden)] pub type QueryControlFlags = Flags;

#[doc(hidden)] pub type QueryResultFlags = Flags;

#[doc(hidden)] pub type ShaderModuleCreateFlags = Flags;

#[doc(hidden)] pub type EventCreateFlags = Flags;

#[doc(hidden)] pub type CommandPoolCreateFlags = Flags;

#[doc(hidden)] pub type CommandPoolResetFlags = Flags;

#[doc(hidden)] pub type CommandBufferResetFlags = Flags;

#[doc(hidden)] pub type CommandBufferUsageFlags = Flags;

#[doc(hidden)] pub type QueryPipelineStatisticFlags = Flags;

#[doc(hidden)] pub type MemoryMapFlags = Flags;

#[doc(hidden)] pub type ImageAspectFlags = Flags;

#[doc(hidden)] pub type SparseMemoryBindFlags = Flags;

#[doc(hidden)] pub type SparseImageFormatFlags = Flags;

#[doc(hidden)] pub type SubpassDescriptionFlags = Flags;

#[doc(hidden)] pub type PipelineStageFlags = Flags;

#[doc(hidden)] pub type SampleCountFlags = Flags;

#[doc(hidden)] pub type AttachmentDescriptionFlags = Flags;

#[doc(hidden)] pub type StencilFaceFlags = Flags;

#[doc(hidden)] pub type CullModeFlags = Flags;

#[doc(hidden)] pub type DescriptorPoolCreateFlags = Flags;

#[doc(hidden)] pub type DescriptorPoolResetFlags = Flags;

#[doc(hidden)] pub type DependencyFlags = Flags;

#[doc(hidden)] pub type SubgroupFeatureFlags = Flags;

#[doc(hidden)] pub type IndirectCommandsLayoutUsageFlagsNVX = Flags;

#[doc(hidden)] pub type ObjectEntryUsageFlagsNVX = Flags;

#[doc(hidden)] pub type GeometryFlagsNV = Flags;

#[doc(hidden)] pub type GeometryInstanceFlagsNV = Flags;

#[doc(hidden)] pub type BuildAccelerationStructureFlagsNV = Flags;

#[doc(hidden)] pub type DescriptorUpdateTemplateCreateFlags = Flags;

#[doc(hidden)] pub type CompositeAlphaFlagsKHR = Flags;

#[doc(hidden)] pub type DisplayPlaneAlphaFlagsKHR = Flags;

#[doc(hidden)] pub type SurfaceTransformFlagsKHR = Flags;

#[doc(hidden)] pub type SwapchainCreateFlagsKHR = Flags;

#[doc(hidden)] pub type DisplayModeCreateFlagsKHR = Flags;

#[doc(hidden)] pub type DisplaySurfaceCreateFlagsKHR = Flags;

#[doc(hidden)] pub type AndroidSurfaceCreateFlagsKHR = Flags;

#[doc(hidden)] pub type ViSurfaceCreateFlagsNN = Flags;

#[doc(hidden)] pub type WaylandSurfaceCreateFlagsKHR = Flags;

#[doc(hidden)] pub type Win32SurfaceCreateFlagsKHR = Flags;

#[doc(hidden)] pub type XlibSurfaceCreateFlagsKHR = Flags;

#[doc(hidden)] pub type XcbSurfaceCreateFlagsKHR = Flags;

#[doc(hidden)] pub type IOSSurfaceCreateFlagsMVK = Flags;

#[doc(hidden)] pub type MacOSSurfaceCreateFlagsMVK = Flags;

#[doc(hidden)] pub type ImagePipeSurfaceCreateFlagsFUCHSIA = Flags;

#[doc(hidden)] pub type PeerMemoryFeatureFlags = Flags;

#[doc(hidden)] pub type MemoryAllocateFlags = Flags;

#[doc(hidden)] pub type DeviceGroupPresentModeFlagsKHR = Flags;

#[doc(hidden)] pub type DebugReportFlagsEXT = Flags;

#[doc(hidden)] pub type CommandPoolTrimFlags = Flags;

#[doc(hidden)] pub type ExternalMemoryHandleTypeFlagsNV = Flags;

#[doc(hidden)] pub type ExternalMemoryFeatureFlagsNV = Flags;

#[doc(hidden)] pub type ExternalMemoryHandleTypeFlags = Flags;

#[doc(hidden)] pub type ExternalMemoryFeatureFlags = Flags;

#[doc(hidden)] pub type ExternalSemaphoreHandleTypeFlags = Flags;

#[doc(hidden)] pub type ExternalSemaphoreFeatureFlags = Flags;

#[doc(hidden)] pub type SemaphoreImportFlags = Flags;

#[doc(hidden)] pub type ExternalFenceHandleTypeFlags = Flags;

#[doc(hidden)] pub type ExternalFenceFeatureFlags = Flags;

#[doc(hidden)] pub type FenceImportFlags = Flags;

#[doc(hidden)] pub type SurfaceCounterFlagsEXT = Flags;

#[doc(hidden)] pub type PipelineViewportSwizzleStateCreateFlagsNV = Flags;

#[doc(hidden)] pub type PipelineDiscardRectangleStateCreateFlagsEXT = Flags;

#[doc(hidden)] pub type PipelineCoverageToColorStateCreateFlagsNV = Flags;

#[doc(hidden)] pub type PipelineCoverageModulationStateCreateFlagsNV = Flags;

#[doc(hidden)] pub type ValidationCacheCreateFlagsEXT = Flags;

#[doc(hidden)] pub type DebugUtilsMessageSeverityFlagsEXT = Flags;

#[doc(hidden)] pub type DebugUtilsMessageTypeFlagsEXT = Flags;

#[doc(hidden)] pub type DebugUtilsMessengerCreateFlagsEXT = Flags;

#[doc(hidden)] pub type DebugUtilsMessengerCallbackDataFlagsEXT = Flags;

#[doc(hidden)] pub type PipelineRasterizationConservativeStateCreateFlagsEXT = Flags;

#[doc(hidden)] pub type DescriptorBindingFlagsEXT = Flags;

#[doc(hidden)] pub type ConditionalRenderingFlagsEXT = Flags;

#[doc(hidden)] pub type PipelineRasterizationStateStreamCreateFlagsEXT = Flags;

#[doc(hidden)] pub type AttachmentLoadOp = u32;
#[doc(hidden)] pub const ATTACHMENT_LOAD_OP_LOAD: u32 = 0u32;
#[doc(hidden)] pub const ATTACHMENT_LOAD_OP_CLEAR: u32 = 1u32;
#[doc(hidden)] pub const ATTACHMENT_LOAD_OP_DONT_CARE: u32 = 2u32;

#[doc(hidden)] pub type AttachmentStoreOp = u32;
#[doc(hidden)] pub const ATTACHMENT_STORE_OP_STORE: u32 = 0u32;
#[doc(hidden)] pub const ATTACHMENT_STORE_OP_DONT_CARE: u32 = 1u32;

#[doc(hidden)] pub type BlendFactor = u32;
#[doc(hidden)] pub const BLEND_FACTOR_ZERO: u32 = 0u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE: u32 = 1u32;
#[doc(hidden)] pub const BLEND_FACTOR_SRC_COLOR: u32 = 2u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE_MINUS_SRC_COLOR: u32 = 3u32;
#[doc(hidden)] pub const BLEND_FACTOR_DST_COLOR: u32 = 4u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE_MINUS_DST_COLOR: u32 = 5u32;
#[doc(hidden)] pub const BLEND_FACTOR_SRC_ALPHA: u32 = 6u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: u32 = 7u32;
#[doc(hidden)] pub const BLEND_FACTOR_DST_ALPHA: u32 = 8u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE_MINUS_DST_ALPHA: u32 = 9u32;
#[doc(hidden)] pub const BLEND_FACTOR_CONSTANT_COLOR: u32 = 10u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: u32 = 11u32;
#[doc(hidden)] pub const BLEND_FACTOR_CONSTANT_ALPHA: u32 = 12u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: u32 = 13u32;
#[doc(hidden)] pub const BLEND_FACTOR_SRC_ALPHA_SATURATE: u32 = 14u32;
#[doc(hidden)] pub const BLEND_FACTOR_SRC1_COLOR: u32 = 15u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE_MINUS_SRC1_COLOR: u32 = 16u32;
#[doc(hidden)] pub const BLEND_FACTOR_SRC1_ALPHA: u32 = 17u32;
#[doc(hidden)] pub const BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA: u32 = 18u32;

#[doc(hidden)] pub type BlendOp = u32;
#[doc(hidden)] pub const BLEND_OP_ADD: u32 = 0u32;
#[doc(hidden)] pub const BLEND_OP_SUBTRACT: u32 = 1u32;
#[doc(hidden)] pub const BLEND_OP_REVERSE_SUBTRACT: u32 = 2u32;
#[doc(hidden)] pub const BLEND_OP_MIN: u32 = 3u32;
#[doc(hidden)] pub const BLEND_OP_MAX: u32 = 4u32;
#[doc(hidden)] pub const BLEND_OP_ZERO_EXT: u32 = 1000148000u32;
#[doc(hidden)] pub const BLEND_OP_SRC_EXT: u32 = 1000148001u32;
#[doc(hidden)] pub const BLEND_OP_DST_EXT: u32 = 1000148002u32;
#[doc(hidden)] pub const BLEND_OP_SRC_OVER_EXT: u32 = 1000148003u32;
#[doc(hidden)] pub const BLEND_OP_DST_OVER_EXT: u32 = 1000148004u32;
#[doc(hidden)] pub const BLEND_OP_SRC_IN_EXT: u32 = 1000148005u32;
#[doc(hidden)] pub const BLEND_OP_DST_IN_EXT: u32 = 1000148006u32;
#[doc(hidden)] pub const BLEND_OP_SRC_OUT_EXT: u32 = 1000148007u32;
#[doc(hidden)] pub const BLEND_OP_DST_OUT_EXT: u32 = 1000148008u32;
#[doc(hidden)] pub const BLEND_OP_SRC_ATOP_EXT: u32 = 1000148009u32;
#[doc(hidden)] pub const BLEND_OP_DST_ATOP_EXT: u32 = 1000148010u32;
#[doc(hidden)] pub const BLEND_OP_XOR_EXT: u32 = 1000148011u32;
#[doc(hidden)] pub const BLEND_OP_MULTIPLY_EXT: u32 = 1000148012u32;
#[doc(hidden)] pub const BLEND_OP_SCREEN_EXT: u32 = 1000148013u32;
#[doc(hidden)] pub const BLEND_OP_OVERLAY_EXT: u32 = 1000148014u32;
#[doc(hidden)] pub const BLEND_OP_DARKEN_EXT: u32 = 1000148015u32;
#[doc(hidden)] pub const BLEND_OP_LIGHTEN_EXT: u32 = 1000148016u32;
#[doc(hidden)] pub const BLEND_OP_COLORDODGE_EXT: u32 = 1000148017u32;
#[doc(hidden)] pub const BLEND_OP_COLORBURN_EXT: u32 = 1000148018u32;
#[doc(hidden)] pub const BLEND_OP_HARDLIGHT_EXT: u32 = 1000148019u32;
#[doc(hidden)] pub const BLEND_OP_SOFTLIGHT_EXT: u32 = 1000148020u32;
#[doc(hidden)] pub const BLEND_OP_DIFFERENCE_EXT: u32 = 1000148021u32;
#[doc(hidden)] pub const BLEND_OP_EXCLUSION_EXT: u32 = 1000148022u32;
#[doc(hidden)] pub const BLEND_OP_INVERT_EXT: u32 = 1000148023u32;
#[doc(hidden)] pub const BLEND_OP_INVERT_RGB_EXT: u32 = 1000148024u32;
#[doc(hidden)] pub const BLEND_OP_LINEARDODGE_EXT: u32 = 1000148025u32;
#[doc(hidden)] pub const BLEND_OP_LINEARBURN_EXT: u32 = 1000148026u32;
#[doc(hidden)] pub const BLEND_OP_VIVIDLIGHT_EXT: u32 = 1000148027u32;
#[doc(hidden)] pub const BLEND_OP_LINEARLIGHT_EXT: u32 = 1000148028u32;
#[doc(hidden)] pub const BLEND_OP_PINLIGHT_EXT: u32 = 1000148029u32;
#[doc(hidden)] pub const BLEND_OP_HARDMIX_EXT: u32 = 1000148030u32;
#[doc(hidden)] pub const BLEND_OP_HSL_HUE_EXT: u32 = 1000148031u32;
#[doc(hidden)] pub const BLEND_OP_HSL_SATURATION_EXT: u32 = 1000148032u32;
#[doc(hidden)] pub const BLEND_OP_HSL_COLOR_EXT: u32 = 1000148033u32;
#[doc(hidden)] pub const BLEND_OP_HSL_LUMINOSITY_EXT: u32 = 1000148034u32;
#[doc(hidden)] pub const BLEND_OP_PLUS_EXT: u32 = 1000148035u32;
#[doc(hidden)] pub const BLEND_OP_PLUS_CLAMPED_EXT: u32 = 1000148036u32;
#[doc(hidden)] pub const BLEND_OP_PLUS_CLAMPED_ALPHA_EXT: u32 = 1000148037u32;
#[doc(hidden)] pub const BLEND_OP_PLUS_DARKER_EXT: u32 = 1000148038u32;
#[doc(hidden)] pub const BLEND_OP_MINUS_EXT: u32 = 1000148039u32;
#[doc(hidden)] pub const BLEND_OP_MINUS_CLAMPED_EXT: u32 = 1000148040u32;
#[doc(hidden)] pub const BLEND_OP_CONTRAST_EXT: u32 = 1000148041u32;
#[doc(hidden)] pub const BLEND_OP_INVERT_OVG_EXT: u32 = 1000148042u32;
#[doc(hidden)] pub const BLEND_OP_RED_EXT: u32 = 1000148043u32;
#[doc(hidden)] pub const BLEND_OP_GREEN_EXT: u32 = 1000148044u32;
#[doc(hidden)] pub const BLEND_OP_BLUE_EXT: u32 = 1000148045u32;

#[doc(hidden)] pub type BorderColor = u32;
#[doc(hidden)] pub const BORDER_COLOR_FLOAT_TRANSPARENT_BLACK: u32 = 0u32;
#[doc(hidden)] pub const BORDER_COLOR_INT_TRANSPARENT_BLACK: u32 = 1u32;
#[doc(hidden)] pub const BORDER_COLOR_FLOAT_OPAQUE_BLACK: u32 = 2u32;
#[doc(hidden)] pub const BORDER_COLOR_INT_OPAQUE_BLACK: u32 = 3u32;
#[doc(hidden)] pub const BORDER_COLOR_FLOAT_OPAQUE_WHITE: u32 = 4u32;
#[doc(hidden)] pub const BORDER_COLOR_INT_OPAQUE_WHITE: u32 = 5u32;

#[doc(hidden)] pub type SamplerCreateFlagBits = u32;
#[doc(hidden)] pub const SAMPLER_CREATE_SUBSAMPLED_BIT_EXT: u32 = 0x1u32;
#[doc(hidden)] pub const SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT: u32 = 0x2u32;

#[doc(hidden)] pub type PipelineCacheHeaderVersion = u32;
#[doc(hidden)] pub const PIPELINE_CACHE_HEADER_VERSION_ONE: u32 = 1u32;

#[doc(hidden)] pub type DescriptorSetLayoutCreateFlagBits = u32;
#[doc(hidden)] pub const DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: u32 = 0x1u32;
#[doc(hidden)] pub const DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT: u32 = 0x2u32;

#[doc(hidden)] pub type DeviceQueueCreateFlagBits = u32;
#[doc(hidden)] pub const DEVICE_QUEUE_CREATE_PROTECTED_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type BufferCreateFlagBits = u32;
#[doc(hidden)] pub const BUFFER_CREATE_SPARSE_BINDING_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const BUFFER_CREATE_SPARSE_RESIDENCY_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const BUFFER_CREATE_SPARSE_ALIASED_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const BUFFER_CREATE_PROTECTED_BIT: u32 = 0x8u32;

#[doc(hidden)] pub type BufferUsageFlagBits = u32;
#[doc(hidden)] pub const BUFFER_USAGE_TRANSFER_SRC_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const BUFFER_USAGE_TRANSFER_DST_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const BUFFER_USAGE_UNIFORM_BUFFER_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const BUFFER_USAGE_STORAGE_BUFFER_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const BUFFER_USAGE_INDEX_BUFFER_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const BUFFER_USAGE_VERTEX_BUFFER_BIT: u32 = 0x80u32;
#[doc(hidden)] pub const BUFFER_USAGE_INDIRECT_BUFFER_BIT: u32 = 0x100u32;
#[doc(hidden)] pub const BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: u32 = 0x800u32;
#[doc(hidden)] pub const BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: u32 = 0x1000u32;
#[doc(hidden)] pub const BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT: u32 = 0x200u32;
#[doc(hidden)] pub const BUFFER_USAGE_RAY_TRACING_BIT_NV: u32 = 0x400u32;

#[doc(hidden)] pub type ColorComponentFlagBits = u32;
#[doc(hidden)] pub const COLOR_COMPONENT_R_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const COLOR_COMPONENT_G_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const COLOR_COMPONENT_B_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const COLOR_COMPONENT_A_BIT: u32 = 0x8u32;

#[doc(hidden)] pub type ComponentSwizzle = u32;
#[doc(hidden)] pub const COMPONENT_SWIZZLE_IDENTITY: u32 = 0u32;
#[doc(hidden)] pub const COMPONENT_SWIZZLE_ZERO: u32 = 1u32;
#[doc(hidden)] pub const COMPONENT_SWIZZLE_ONE: u32 = 2u32;
#[doc(hidden)] pub const COMPONENT_SWIZZLE_R: u32 = 3u32;
#[doc(hidden)] pub const COMPONENT_SWIZZLE_G: u32 = 4u32;
#[doc(hidden)] pub const COMPONENT_SWIZZLE_B: u32 = 5u32;
#[doc(hidden)] pub const COMPONENT_SWIZZLE_A: u32 = 6u32;

#[doc(hidden)] pub type CommandPoolCreateFlagBits = u32;
#[doc(hidden)] pub const COMMAND_POOL_CREATE_TRANSIENT_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const COMMAND_POOL_CREATE_PROTECTED_BIT: u32 = 0x4u32;

#[doc(hidden)] pub type CommandPoolResetFlagBits = u32;
#[doc(hidden)] pub const COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type CommandBufferResetFlagBits = u32;
#[doc(hidden)] pub const COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type CommandBufferLevel = u32;
#[doc(hidden)] pub const COMMAND_BUFFER_LEVEL_PRIMARY: u32 = 0u32;
#[doc(hidden)] pub const COMMAND_BUFFER_LEVEL_SECONDARY: u32 = 1u32;

#[doc(hidden)] pub type CommandBufferUsageFlagBits = u32;
#[doc(hidden)] pub const COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT: u32 = 0x4u32;

#[doc(hidden)] pub type CompareOp = u32;
#[doc(hidden)] pub const COMPARE_OP_NEVER: u32 = 0u32;
#[doc(hidden)] pub const COMPARE_OP_LESS: u32 = 1u32;
#[doc(hidden)] pub const COMPARE_OP_EQUAL: u32 = 2u32;
#[doc(hidden)] pub const COMPARE_OP_LESS_OR_EQUAL: u32 = 3u32;
#[doc(hidden)] pub const COMPARE_OP_GREATER: u32 = 4u32;
#[doc(hidden)] pub const COMPARE_OP_NOT_EQUAL: u32 = 5u32;
#[doc(hidden)] pub const COMPARE_OP_GREATER_OR_EQUAL: u32 = 6u32;
#[doc(hidden)] pub const COMPARE_OP_ALWAYS: u32 = 7u32;

#[doc(hidden)] pub type CullModeFlagBits = u32;
#[doc(hidden)] pub const CULL_MODE_NONE: u32 = 0u32;
#[doc(hidden)] pub const CULL_MODE_FRONT_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const CULL_MODE_BACK_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const CULL_MODE_FRONT_AND_BACK: u32 = 0x00000003u32;

#[doc(hidden)] pub type DescriptorType = u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_SAMPLER: u32 = 0u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: u32 = 1u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_SAMPLED_IMAGE: u32 = 2u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_STORAGE_IMAGE: u32 = 3u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: u32 = 4u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: u32 = 5u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_UNIFORM_BUFFER: u32 = 6u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_STORAGE_BUFFER: u32 = 7u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: u32 = 8u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: u32 = 9u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_INPUT_ATTACHMENT: u32 = 10u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: u32 = 1000138000u32;
#[doc(hidden)] pub const DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV: u32 = 1000165000u32;

#[doc(hidden)] pub type DynamicState = u32;
#[doc(hidden)] pub const DYNAMIC_STATE_VIEWPORT: u32 = 0u32;
#[doc(hidden)] pub const DYNAMIC_STATE_SCISSOR: u32 = 1u32;
#[doc(hidden)] pub const DYNAMIC_STATE_LINE_WIDTH: u32 = 2u32;
#[doc(hidden)] pub const DYNAMIC_STATE_DEPTH_BIAS: u32 = 3u32;
#[doc(hidden)] pub const DYNAMIC_STATE_BLEND_CONSTANTS: u32 = 4u32;
#[doc(hidden)] pub const DYNAMIC_STATE_DEPTH_BOUNDS: u32 = 5u32;
#[doc(hidden)] pub const DYNAMIC_STATE_STENCIL_COMPARE_MASK: u32 = 6u32;
#[doc(hidden)] pub const DYNAMIC_STATE_STENCIL_WRITE_MASK: u32 = 7u32;
#[doc(hidden)] pub const DYNAMIC_STATE_STENCIL_REFERENCE: u32 = 8u32;
#[doc(hidden)] pub const DYNAMIC_STATE_VIEWPORT_W_SCALING_NV: u32 = 1000087000u32;
#[doc(hidden)] pub const DYNAMIC_STATE_DISCARD_RECTANGLE_EXT: u32 = 1000099000u32;
#[doc(hidden)] pub const DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT: u32 = 1000143000u32;
#[doc(hidden)] pub const DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV: u32 = 1000164004u32;
#[doc(hidden)] pub const DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV: u32 = 1000164006u32;
#[doc(hidden)] pub const DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV: u32 = 1000205001u32;

#[doc(hidden)] pub type FenceCreateFlagBits = u32;
#[doc(hidden)] pub const FENCE_CREATE_SIGNALED_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type PolygonMode = u32;
#[doc(hidden)] pub const POLYGON_MODE_FILL: u32 = 0u32;
#[doc(hidden)] pub const POLYGON_MODE_LINE: u32 = 1u32;
#[doc(hidden)] pub const POLYGON_MODE_POINT: u32 = 2u32;
#[doc(hidden)] pub const POLYGON_MODE_FILL_RECTANGLE_NV: u32 = 1000153000u32;

#[doc(hidden)] pub type Format = u32;
#[doc(hidden)] pub const FORMAT_UNDEFINED: u32 = 0u32;
#[doc(hidden)] pub const FORMAT_R4G4_UNORM_PACK8: u32 = 1u32;
#[doc(hidden)] pub const FORMAT_R4G4B4A4_UNORM_PACK16: u32 = 2u32;
#[doc(hidden)] pub const FORMAT_B4G4R4A4_UNORM_PACK16: u32 = 3u32;
#[doc(hidden)] pub const FORMAT_R5G6B5_UNORM_PACK16: u32 = 4u32;
#[doc(hidden)] pub const FORMAT_B5G6R5_UNORM_PACK16: u32 = 5u32;
#[doc(hidden)] pub const FORMAT_R5G5B5A1_UNORM_PACK16: u32 = 6u32;
#[doc(hidden)] pub const FORMAT_B5G5R5A1_UNORM_PACK16: u32 = 7u32;
#[doc(hidden)] pub const FORMAT_A1R5G5B5_UNORM_PACK16: u32 = 8u32;
#[doc(hidden)] pub const FORMAT_R8_UNORM: u32 = 9u32;
#[doc(hidden)] pub const FORMAT_R8_SNORM: u32 = 10u32;
#[doc(hidden)] pub const FORMAT_R8_USCALED: u32 = 11u32;
#[doc(hidden)] pub const FORMAT_R8_SSCALED: u32 = 12u32;
#[doc(hidden)] pub const FORMAT_R8_UINT: u32 = 13u32;
#[doc(hidden)] pub const FORMAT_R8_SINT: u32 = 14u32;
#[doc(hidden)] pub const FORMAT_R8_SRGB: u32 = 15u32;
#[doc(hidden)] pub const FORMAT_R8G8_UNORM: u32 = 16u32;
#[doc(hidden)] pub const FORMAT_R8G8_SNORM: u32 = 17u32;
#[doc(hidden)] pub const FORMAT_R8G8_USCALED: u32 = 18u32;
#[doc(hidden)] pub const FORMAT_R8G8_SSCALED: u32 = 19u32;
#[doc(hidden)] pub const FORMAT_R8G8_UINT: u32 = 20u32;
#[doc(hidden)] pub const FORMAT_R8G8_SINT: u32 = 21u32;
#[doc(hidden)] pub const FORMAT_R8G8_SRGB: u32 = 22u32;
#[doc(hidden)] pub const FORMAT_R8G8B8_UNORM: u32 = 23u32;
#[doc(hidden)] pub const FORMAT_R8G8B8_SNORM: u32 = 24u32;
#[doc(hidden)] pub const FORMAT_R8G8B8_USCALED: u32 = 25u32;
#[doc(hidden)] pub const FORMAT_R8G8B8_SSCALED: u32 = 26u32;
#[doc(hidden)] pub const FORMAT_R8G8B8_UINT: u32 = 27u32;
#[doc(hidden)] pub const FORMAT_R8G8B8_SINT: u32 = 28u32;
#[doc(hidden)] pub const FORMAT_R8G8B8_SRGB: u32 = 29u32;
#[doc(hidden)] pub const FORMAT_B8G8R8_UNORM: u32 = 30u32;
#[doc(hidden)] pub const FORMAT_B8G8R8_SNORM: u32 = 31u32;
#[doc(hidden)] pub const FORMAT_B8G8R8_USCALED: u32 = 32u32;
#[doc(hidden)] pub const FORMAT_B8G8R8_SSCALED: u32 = 33u32;
#[doc(hidden)] pub const FORMAT_B8G8R8_UINT: u32 = 34u32;
#[doc(hidden)] pub const FORMAT_B8G8R8_SINT: u32 = 35u32;
#[doc(hidden)] pub const FORMAT_B8G8R8_SRGB: u32 = 36u32;
#[doc(hidden)] pub const FORMAT_R8G8B8A8_UNORM: u32 = 37u32;
#[doc(hidden)] pub const FORMAT_R8G8B8A8_SNORM: u32 = 38u32;
#[doc(hidden)] pub const FORMAT_R8G8B8A8_USCALED: u32 = 39u32;
#[doc(hidden)] pub const FORMAT_R8G8B8A8_SSCALED: u32 = 40u32;
#[doc(hidden)] pub const FORMAT_R8G8B8A8_UINT: u32 = 41u32;
#[doc(hidden)] pub const FORMAT_R8G8B8A8_SINT: u32 = 42u32;
#[doc(hidden)] pub const FORMAT_R8G8B8A8_SRGB: u32 = 43u32;
#[doc(hidden)] pub const FORMAT_B8G8R8A8_UNORM: u32 = 44u32;
#[doc(hidden)] pub const FORMAT_B8G8R8A8_SNORM: u32 = 45u32;
#[doc(hidden)] pub const FORMAT_B8G8R8A8_USCALED: u32 = 46u32;
#[doc(hidden)] pub const FORMAT_B8G8R8A8_SSCALED: u32 = 47u32;
#[doc(hidden)] pub const FORMAT_B8G8R8A8_UINT: u32 = 48u32;
#[doc(hidden)] pub const FORMAT_B8G8R8A8_SINT: u32 = 49u32;
#[doc(hidden)] pub const FORMAT_B8G8R8A8_SRGB: u32 = 50u32;
#[doc(hidden)] pub const FORMAT_A8B8G8R8_UNORM_PACK32: u32 = 51u32;
#[doc(hidden)] pub const FORMAT_A8B8G8R8_SNORM_PACK32: u32 = 52u32;
#[doc(hidden)] pub const FORMAT_A8B8G8R8_USCALED_PACK32: u32 = 53u32;
#[doc(hidden)] pub const FORMAT_A8B8G8R8_SSCALED_PACK32: u32 = 54u32;
#[doc(hidden)] pub const FORMAT_A8B8G8R8_UINT_PACK32: u32 = 55u32;
#[doc(hidden)] pub const FORMAT_A8B8G8R8_SINT_PACK32: u32 = 56u32;
#[doc(hidden)] pub const FORMAT_A8B8G8R8_SRGB_PACK32: u32 = 57u32;
#[doc(hidden)] pub const FORMAT_A2R10G10B10_UNORM_PACK32: u32 = 58u32;
#[doc(hidden)] pub const FORMAT_A2R10G10B10_SNORM_PACK32: u32 = 59u32;
#[doc(hidden)] pub const FORMAT_A2R10G10B10_USCALED_PACK32: u32 = 60u32;
#[doc(hidden)] pub const FORMAT_A2R10G10B10_SSCALED_PACK32: u32 = 61u32;
#[doc(hidden)] pub const FORMAT_A2R10G10B10_UINT_PACK32: u32 = 62u32;
#[doc(hidden)] pub const FORMAT_A2R10G10B10_SINT_PACK32: u32 = 63u32;
#[doc(hidden)] pub const FORMAT_A2B10G10R10_UNORM_PACK32: u32 = 64u32;
#[doc(hidden)] pub const FORMAT_A2B10G10R10_SNORM_PACK32: u32 = 65u32;
#[doc(hidden)] pub const FORMAT_A2B10G10R10_USCALED_PACK32: u32 = 66u32;
#[doc(hidden)] pub const FORMAT_A2B10G10R10_SSCALED_PACK32: u32 = 67u32;
#[doc(hidden)] pub const FORMAT_A2B10G10R10_UINT_PACK32: u32 = 68u32;
#[doc(hidden)] pub const FORMAT_A2B10G10R10_SINT_PACK32: u32 = 69u32;
#[doc(hidden)] pub const FORMAT_R16_UNORM: u32 = 70u32;
#[doc(hidden)] pub const FORMAT_R16_SNORM: u32 = 71u32;
#[doc(hidden)] pub const FORMAT_R16_USCALED: u32 = 72u32;
#[doc(hidden)] pub const FORMAT_R16_SSCALED: u32 = 73u32;
#[doc(hidden)] pub const FORMAT_R16_UINT: u32 = 74u32;
#[doc(hidden)] pub const FORMAT_R16_SINT: u32 = 75u32;
#[doc(hidden)] pub const FORMAT_R16_SFLOAT: u32 = 76u32;
#[doc(hidden)] pub const FORMAT_R16G16_UNORM: u32 = 77u32;
#[doc(hidden)] pub const FORMAT_R16G16_SNORM: u32 = 78u32;
#[doc(hidden)] pub const FORMAT_R16G16_USCALED: u32 = 79u32;
#[doc(hidden)] pub const FORMAT_R16G16_SSCALED: u32 = 80u32;
#[doc(hidden)] pub const FORMAT_R16G16_UINT: u32 = 81u32;
#[doc(hidden)] pub const FORMAT_R16G16_SINT: u32 = 82u32;
#[doc(hidden)] pub const FORMAT_R16G16_SFLOAT: u32 = 83u32;
#[doc(hidden)] pub const FORMAT_R16G16B16_UNORM: u32 = 84u32;
#[doc(hidden)] pub const FORMAT_R16G16B16_SNORM: u32 = 85u32;
#[doc(hidden)] pub const FORMAT_R16G16B16_USCALED: u32 = 86u32;
#[doc(hidden)] pub const FORMAT_R16G16B16_SSCALED: u32 = 87u32;
#[doc(hidden)] pub const FORMAT_R16G16B16_UINT: u32 = 88u32;
#[doc(hidden)] pub const FORMAT_R16G16B16_SINT: u32 = 89u32;
#[doc(hidden)] pub const FORMAT_R16G16B16_SFLOAT: u32 = 90u32;
#[doc(hidden)] pub const FORMAT_R16G16B16A16_UNORM: u32 = 91u32;
#[doc(hidden)] pub const FORMAT_R16G16B16A16_SNORM: u32 = 92u32;
#[doc(hidden)] pub const FORMAT_R16G16B16A16_USCALED: u32 = 93u32;
#[doc(hidden)] pub const FORMAT_R16G16B16A16_SSCALED: u32 = 94u32;
#[doc(hidden)] pub const FORMAT_R16G16B16A16_UINT: u32 = 95u32;
#[doc(hidden)] pub const FORMAT_R16G16B16A16_SINT: u32 = 96u32;
#[doc(hidden)] pub const FORMAT_R16G16B16A16_SFLOAT: u32 = 97u32;
#[doc(hidden)] pub const FORMAT_R32_UINT: u32 = 98u32;
#[doc(hidden)] pub const FORMAT_R32_SINT: u32 = 99u32;
#[doc(hidden)] pub const FORMAT_R32_SFLOAT: u32 = 100u32;
#[doc(hidden)] pub const FORMAT_R32G32_UINT: u32 = 101u32;
#[doc(hidden)] pub const FORMAT_R32G32_SINT: u32 = 102u32;
#[doc(hidden)] pub const FORMAT_R32G32_SFLOAT: u32 = 103u32;
#[doc(hidden)] pub const FORMAT_R32G32B32_UINT: u32 = 104u32;
#[doc(hidden)] pub const FORMAT_R32G32B32_SINT: u32 = 105u32;
#[doc(hidden)] pub const FORMAT_R32G32B32_SFLOAT: u32 = 106u32;
#[doc(hidden)] pub const FORMAT_R32G32B32A32_UINT: u32 = 107u32;
#[doc(hidden)] pub const FORMAT_R32G32B32A32_SINT: u32 = 108u32;
#[doc(hidden)] pub const FORMAT_R32G32B32A32_SFLOAT: u32 = 109u32;
#[doc(hidden)] pub const FORMAT_R64_UINT: u32 = 110u32;
#[doc(hidden)] pub const FORMAT_R64_SINT: u32 = 111u32;
#[doc(hidden)] pub const FORMAT_R64_SFLOAT: u32 = 112u32;
#[doc(hidden)] pub const FORMAT_R64G64_UINT: u32 = 113u32;
#[doc(hidden)] pub const FORMAT_R64G64_SINT: u32 = 114u32;
#[doc(hidden)] pub const FORMAT_R64G64_SFLOAT: u32 = 115u32;
#[doc(hidden)] pub const FORMAT_R64G64B64_UINT: u32 = 116u32;
#[doc(hidden)] pub const FORMAT_R64G64B64_SINT: u32 = 117u32;
#[doc(hidden)] pub const FORMAT_R64G64B64_SFLOAT: u32 = 118u32;
#[doc(hidden)] pub const FORMAT_R64G64B64A64_UINT: u32 = 119u32;
#[doc(hidden)] pub const FORMAT_R64G64B64A64_SINT: u32 = 120u32;
#[doc(hidden)] pub const FORMAT_R64G64B64A64_SFLOAT: u32 = 121u32;
#[doc(hidden)] pub const FORMAT_B10G11R11_UFLOAT_PACK32: u32 = 122u32;
#[doc(hidden)] pub const FORMAT_E5B9G9R9_UFLOAT_PACK32: u32 = 123u32;
#[doc(hidden)] pub const FORMAT_D16_UNORM: u32 = 124u32;
#[doc(hidden)] pub const FORMAT_X8_D24_UNORM_PACK32: u32 = 125u32;
#[doc(hidden)] pub const FORMAT_D32_SFLOAT: u32 = 126u32;
#[doc(hidden)] pub const FORMAT_S8_UINT: u32 = 127u32;
#[doc(hidden)] pub const FORMAT_D16_UNORM_S8_UINT: u32 = 128u32;
#[doc(hidden)] pub const FORMAT_D24_UNORM_S8_UINT: u32 = 129u32;
#[doc(hidden)] pub const FORMAT_D32_SFLOAT_S8_UINT: u32 = 130u32;
#[doc(hidden)] pub const FORMAT_BC1_RGB_UNORM_BLOCK: u32 = 131u32;
#[doc(hidden)] pub const FORMAT_BC1_RGB_SRGB_BLOCK: u32 = 132u32;
#[doc(hidden)] pub const FORMAT_BC1_RGBA_UNORM_BLOCK: u32 = 133u32;
#[doc(hidden)] pub const FORMAT_BC1_RGBA_SRGB_BLOCK: u32 = 134u32;
#[doc(hidden)] pub const FORMAT_BC2_UNORM_BLOCK: u32 = 135u32;
#[doc(hidden)] pub const FORMAT_BC2_SRGB_BLOCK: u32 = 136u32;
#[doc(hidden)] pub const FORMAT_BC3_UNORM_BLOCK: u32 = 137u32;
#[doc(hidden)] pub const FORMAT_BC3_SRGB_BLOCK: u32 = 138u32;
#[doc(hidden)] pub const FORMAT_BC4_UNORM_BLOCK: u32 = 139u32;
#[doc(hidden)] pub const FORMAT_BC4_SNORM_BLOCK: u32 = 140u32;
#[doc(hidden)] pub const FORMAT_BC5_UNORM_BLOCK: u32 = 141u32;
#[doc(hidden)] pub const FORMAT_BC5_SNORM_BLOCK: u32 = 142u32;
#[doc(hidden)] pub const FORMAT_BC6H_UFLOAT_BLOCK: u32 = 143u32;
#[doc(hidden)] pub const FORMAT_BC6H_SFLOAT_BLOCK: u32 = 144u32;
#[doc(hidden)] pub const FORMAT_BC7_UNORM_BLOCK: u32 = 145u32;
#[doc(hidden)] pub const FORMAT_BC7_SRGB_BLOCK: u32 = 146u32;
#[doc(hidden)] pub const FORMAT_ETC2_R8G8B8_UNORM_BLOCK: u32 = 147u32;
#[doc(hidden)] pub const FORMAT_ETC2_R8G8B8_SRGB_BLOCK: u32 = 148u32;
#[doc(hidden)] pub const FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: u32 = 149u32;
#[doc(hidden)] pub const FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: u32 = 150u32;
#[doc(hidden)] pub const FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: u32 = 151u32;
#[doc(hidden)] pub const FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: u32 = 152u32;
#[doc(hidden)] pub const FORMAT_EAC_R11_UNORM_BLOCK: u32 = 153u32;
#[doc(hidden)] pub const FORMAT_EAC_R11_SNORM_BLOCK: u32 = 154u32;
#[doc(hidden)] pub const FORMAT_EAC_R11G11_UNORM_BLOCK: u32 = 155u32;
#[doc(hidden)] pub const FORMAT_EAC_R11G11_SNORM_BLOCK: u32 = 156u32;
#[doc(hidden)] pub const FORMAT_ASTC_4x4_UNORM_BLOCK: u32 = 157u32;
#[doc(hidden)] pub const FORMAT_ASTC_4x4_SRGB_BLOCK: u32 = 158u32;
#[doc(hidden)] pub const FORMAT_ASTC_5x4_UNORM_BLOCK: u32 = 159u32;
#[doc(hidden)] pub const FORMAT_ASTC_5x4_SRGB_BLOCK: u32 = 160u32;
#[doc(hidden)] pub const FORMAT_ASTC_5x5_UNORM_BLOCK: u32 = 161u32;
#[doc(hidden)] pub const FORMAT_ASTC_5x5_SRGB_BLOCK: u32 = 162u32;
#[doc(hidden)] pub const FORMAT_ASTC_6x5_UNORM_BLOCK: u32 = 163u32;
#[doc(hidden)] pub const FORMAT_ASTC_6x5_SRGB_BLOCK: u32 = 164u32;
#[doc(hidden)] pub const FORMAT_ASTC_6x6_UNORM_BLOCK: u32 = 165u32;
#[doc(hidden)] pub const FORMAT_ASTC_6x6_SRGB_BLOCK: u32 = 166u32;
#[doc(hidden)] pub const FORMAT_ASTC_8x5_UNORM_BLOCK: u32 = 167u32;
#[doc(hidden)] pub const FORMAT_ASTC_8x5_SRGB_BLOCK: u32 = 168u32;
#[doc(hidden)] pub const FORMAT_ASTC_8x6_UNORM_BLOCK: u32 = 169u32;
#[doc(hidden)] pub const FORMAT_ASTC_8x6_SRGB_BLOCK: u32 = 170u32;
#[doc(hidden)] pub const FORMAT_ASTC_8x8_UNORM_BLOCK: u32 = 171u32;
#[doc(hidden)] pub const FORMAT_ASTC_8x8_SRGB_BLOCK: u32 = 172u32;
#[doc(hidden)] pub const FORMAT_ASTC_10x5_UNORM_BLOCK: u32 = 173u32;
#[doc(hidden)] pub const FORMAT_ASTC_10x5_SRGB_BLOCK: u32 = 174u32;
#[doc(hidden)] pub const FORMAT_ASTC_10x6_UNORM_BLOCK: u32 = 175u32;
#[doc(hidden)] pub const FORMAT_ASTC_10x6_SRGB_BLOCK: u32 = 176u32;
#[doc(hidden)] pub const FORMAT_ASTC_10x8_UNORM_BLOCK: u32 = 177u32;
#[doc(hidden)] pub const FORMAT_ASTC_10x8_SRGB_BLOCK: u32 = 178u32;
#[doc(hidden)] pub const FORMAT_ASTC_10x10_UNORM_BLOCK: u32 = 179u32;
#[doc(hidden)] pub const FORMAT_ASTC_10x10_SRGB_BLOCK: u32 = 180u32;
#[doc(hidden)] pub const FORMAT_ASTC_12x10_UNORM_BLOCK: u32 = 181u32;
#[doc(hidden)] pub const FORMAT_ASTC_12x10_SRGB_BLOCK: u32 = 182u32;
#[doc(hidden)] pub const FORMAT_ASTC_12x12_UNORM_BLOCK: u32 = 183u32;
#[doc(hidden)] pub const FORMAT_ASTC_12x12_SRGB_BLOCK: u32 = 184u32;
#[doc(hidden)] pub const FORMAT_G8B8G8R8_422_UNORM: u32 = 1000156000u32;
#[doc(hidden)] pub const FORMAT_B8G8R8G8_422_UNORM: u32 = 1000156001u32;
#[doc(hidden)] pub const FORMAT_G8_B8_R8_3PLANE_420_UNORM: u32 = 1000156002u32;
#[doc(hidden)] pub const FORMAT_G8_B8R8_2PLANE_420_UNORM: u32 = 1000156003u32;
#[doc(hidden)] pub const FORMAT_G8_B8_R8_3PLANE_422_UNORM: u32 = 1000156004u32;
#[doc(hidden)] pub const FORMAT_G8_B8R8_2PLANE_422_UNORM: u32 = 1000156005u32;
#[doc(hidden)] pub const FORMAT_G8_B8_R8_3PLANE_444_UNORM: u32 = 1000156006u32;
#[doc(hidden)] pub const FORMAT_R10X6_UNORM_PACK16: u32 = 1000156007u32;
#[doc(hidden)] pub const FORMAT_R10X6G10X6_UNORM_2PACK16: u32 = 1000156008u32;
#[doc(hidden)] pub const FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: u32 = 1000156009u32;
#[doc(hidden)] pub const FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: u32 = 1000156010u32;
#[doc(hidden)] pub const FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: u32 = 1000156011u32;
#[doc(hidden)] pub const FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: u32 = 1000156012u32;
#[doc(hidden)] pub const FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: u32 = 1000156013u32;
#[doc(hidden)] pub const FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: u32 = 1000156014u32;
#[doc(hidden)] pub const FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: u32 = 1000156015u32;
#[doc(hidden)] pub const FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: u32 = 1000156016u32;
#[doc(hidden)] pub const FORMAT_R12X4_UNORM_PACK16: u32 = 1000156017u32;
#[doc(hidden)] pub const FORMAT_R12X4G12X4_UNORM_2PACK16: u32 = 1000156018u32;
#[doc(hidden)] pub const FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: u32 = 1000156019u32;
#[doc(hidden)] pub const FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: u32 = 1000156020u32;
#[doc(hidden)] pub const FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: u32 = 1000156021u32;
#[doc(hidden)] pub const FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: u32 = 1000156022u32;
#[doc(hidden)] pub const FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: u32 = 1000156023u32;
#[doc(hidden)] pub const FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: u32 = 1000156024u32;
#[doc(hidden)] pub const FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: u32 = 1000156025u32;
#[doc(hidden)] pub const FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: u32 = 1000156026u32;
#[doc(hidden)] pub const FORMAT_G16B16G16R16_422_UNORM: u32 = 1000156027u32;
#[doc(hidden)] pub const FORMAT_B16G16R16G16_422_UNORM: u32 = 1000156028u32;
#[doc(hidden)] pub const FORMAT_G16_B16_R16_3PLANE_420_UNORM: u32 = 1000156029u32;
#[doc(hidden)] pub const FORMAT_G16_B16R16_2PLANE_420_UNORM: u32 = 1000156030u32;
#[doc(hidden)] pub const FORMAT_G16_B16_R16_3PLANE_422_UNORM: u32 = 1000156031u32;
#[doc(hidden)] pub const FORMAT_G16_B16R16_2PLANE_422_UNORM: u32 = 1000156032u32;
#[doc(hidden)] pub const FORMAT_G16_B16_R16_3PLANE_444_UNORM: u32 = 1000156033u32;
#[doc(hidden)] pub const FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: u32 = 1000054000u32;
#[doc(hidden)] pub const FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: u32 = 1000054001u32;
#[doc(hidden)] pub const FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: u32 = 1000054002u32;
#[doc(hidden)] pub const FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: u32 = 1000054003u32;
#[doc(hidden)] pub const FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: u32 = 1000054004u32;
#[doc(hidden)] pub const FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: u32 = 1000054005u32;
#[doc(hidden)] pub const FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: u32 = 1000054006u32;
#[doc(hidden)] pub const FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: u32 = 1000054007u32;

#[doc(hidden)] pub type FormatFeatureFlagBits = u32;
#[doc(hidden)] pub const FORMAT_FEATURE_SAMPLED_IMAGE_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const FORMAT_FEATURE_STORAGE_IMAGE_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const FORMAT_FEATURE_VERTEX_BUFFER_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const FORMAT_FEATURE_COLOR_ATTACHMENT_BIT: u32 = 0x80u32;
#[doc(hidden)] pub const FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT: u32 = 0x100u32;
#[doc(hidden)] pub const FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT: u32 = 0x200u32;
#[doc(hidden)] pub const FORMAT_FEATURE_BLIT_SRC_BIT: u32 = 0x400u32;
#[doc(hidden)] pub const FORMAT_FEATURE_BLIT_DST_BIT: u32 = 0x800u32;
#[doc(hidden)] pub const FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT: u32 = 0x1000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_TRANSFER_SRC_BIT: u32 = 0x4000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_TRANSFER_DST_BIT: u32 = 0x8000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT: u32 = 0x20000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: u32 = 0x40000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: u32 = 0x80000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: u32 = 0x100000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: u32 = 0x200000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_DISJOINT_BIT: u32 = 0x400000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT: u32 = 0x800000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG: u32 = 0x2000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT: u32 = 0x10000u32;
#[doc(hidden)] pub const FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT: u32 = 0x1000000u32;

#[doc(hidden)] pub type FrontFace = u32;
#[doc(hidden)] pub const FRONT_FACE_COUNTER_CLOCKWISE: u32 = 0u32;
#[doc(hidden)] pub const FRONT_FACE_CLOCKWISE: u32 = 1u32;

#[doc(hidden)] pub type ImageAspectFlagBits = u32;
#[doc(hidden)] pub const IMAGE_ASPECT_COLOR_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const IMAGE_ASPECT_DEPTH_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const IMAGE_ASPECT_STENCIL_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const IMAGE_ASPECT_METADATA_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const IMAGE_ASPECT_PLANE_0_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const IMAGE_ASPECT_PLANE_1_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const IMAGE_ASPECT_PLANE_2_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: u32 = 0x80u32;
#[doc(hidden)] pub const IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: u32 = 0x100u32;
#[doc(hidden)] pub const IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: u32 = 0x200u32;
#[doc(hidden)] pub const IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: u32 = 0x400u32;

#[doc(hidden)] pub type ImageCreateFlagBits = u32;
#[doc(hidden)] pub const IMAGE_CREATE_SPARSE_BINDING_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const IMAGE_CREATE_SPARSE_RESIDENCY_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const IMAGE_CREATE_SPARSE_ALIASED_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const IMAGE_CREATE_MUTABLE_FORMAT_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const IMAGE_CREATE_CUBE_COMPATIBLE_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const IMAGE_CREATE_ALIAS_BIT: u32 = 0x400u32;
#[doc(hidden)] pub const IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: u32 = 0x80u32;
#[doc(hidden)] pub const IMAGE_CREATE_EXTENDED_USAGE_BIT: u32 = 0x100u32;
#[doc(hidden)] pub const IMAGE_CREATE_PROTECTED_BIT: u32 = 0x800u32;
#[doc(hidden)] pub const IMAGE_CREATE_DISJOINT_BIT: u32 = 0x200u32;
#[doc(hidden)] pub const IMAGE_CREATE_CORNER_SAMPLED_BIT_NV: u32 = 0x2000u32;
#[doc(hidden)] pub const IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT: u32 = 0x1000u32;
#[doc(hidden)] pub const IMAGE_CREATE_SUBSAMPLED_BIT_EXT: u32 = 0x4000u32;

#[doc(hidden)] pub type ImageLayout = u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_UNDEFINED: u32 = 0u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_GENERAL: u32 = 1u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: u32 = 2u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: u32 = 3u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: u32 = 4u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: u32 = 5u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: u32 = 6u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: u32 = 7u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_PREINITIALIZED: u32 = 8u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: u32 = 1000117000u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: u32 = 1000117001u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_PRESENT_SRC_KHR: u32 = 1000001002u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_SHARED_PRESENT_KHR: u32 = 1000111000u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: u32 = 1000164003u32;
#[doc(hidden)] pub const IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: u32 = 1000218000u32;

#[doc(hidden)] pub type ImageTiling = u32;
#[doc(hidden)] pub const IMAGE_TILING_OPTIMAL: u32 = 0u32;
#[doc(hidden)] pub const IMAGE_TILING_LINEAR: u32 = 1u32;
#[doc(hidden)] pub const IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: u32 = 1000158000u32;

#[doc(hidden)] pub type ImageType = u32;
#[doc(hidden)] pub const IMAGE_TYPE_1D: u32 = 0u32;
#[doc(hidden)] pub const IMAGE_TYPE_2D: u32 = 1u32;
#[doc(hidden)] pub const IMAGE_TYPE_3D: u32 = 2u32;

#[doc(hidden)] pub type ImageUsageFlagBits = u32;
#[doc(hidden)] pub const IMAGE_USAGE_TRANSFER_SRC_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const IMAGE_USAGE_TRANSFER_DST_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const IMAGE_USAGE_SAMPLED_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const IMAGE_USAGE_STORAGE_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const IMAGE_USAGE_COLOR_ATTACHMENT_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const IMAGE_USAGE_INPUT_ATTACHMENT_BIT: u32 = 0x80u32;
#[doc(hidden)] pub const IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV: u32 = 0x100u32;
#[doc(hidden)] pub const IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT: u32 = 0x200u32;

#[doc(hidden)] pub type ImageViewCreateFlagBits = u32;
#[doc(hidden)] pub const IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT: u32 = 0x1u32;

#[doc(hidden)] pub type ImageViewType = u32;
#[doc(hidden)] pub const IMAGE_VIEW_TYPE_1D: u32 = 0u32;
#[doc(hidden)] pub const IMAGE_VIEW_TYPE_2D: u32 = 1u32;
#[doc(hidden)] pub const IMAGE_VIEW_TYPE_3D: u32 = 2u32;
#[doc(hidden)] pub const IMAGE_VIEW_TYPE_CUBE: u32 = 3u32;
#[doc(hidden)] pub const IMAGE_VIEW_TYPE_1D_ARRAY: u32 = 4u32;
#[doc(hidden)] pub const IMAGE_VIEW_TYPE_2D_ARRAY: u32 = 5u32;
#[doc(hidden)] pub const IMAGE_VIEW_TYPE_CUBE_ARRAY: u32 = 6u32;

#[doc(hidden)] pub type SharingMode = u32;
#[doc(hidden)] pub const SHARING_MODE_EXCLUSIVE: u32 = 0u32;
#[doc(hidden)] pub const SHARING_MODE_CONCURRENT: u32 = 1u32;

#[doc(hidden)] pub type IndexType = u32;
#[doc(hidden)] pub const INDEX_TYPE_UINT16: u32 = 0u32;
#[doc(hidden)] pub const INDEX_TYPE_UINT32: u32 = 1u32;
#[doc(hidden)] pub const INDEX_TYPE_NONE_NV: u32 = 1000165000u32;

#[doc(hidden)] pub type LogicOp = u32;
#[doc(hidden)] pub const LOGIC_OP_CLEAR: u32 = 0u32;
#[doc(hidden)] pub const LOGIC_OP_AND: u32 = 1u32;
#[doc(hidden)] pub const LOGIC_OP_AND_REVERSE: u32 = 2u32;
#[doc(hidden)] pub const LOGIC_OP_COPY: u32 = 3u32;
#[doc(hidden)] pub const LOGIC_OP_AND_INVERTED: u32 = 4u32;
#[doc(hidden)] pub const LOGIC_OP_NO_OP: u32 = 5u32;
#[doc(hidden)] pub const LOGIC_OP_XOR: u32 = 6u32;
#[doc(hidden)] pub const LOGIC_OP_OR: u32 = 7u32;
#[doc(hidden)] pub const LOGIC_OP_NOR: u32 = 8u32;
#[doc(hidden)] pub const LOGIC_OP_EQUIVALENT: u32 = 9u32;
#[doc(hidden)] pub const LOGIC_OP_INVERT: u32 = 10u32;
#[doc(hidden)] pub const LOGIC_OP_OR_REVERSE: u32 = 11u32;
#[doc(hidden)] pub const LOGIC_OP_COPY_INVERTED: u32 = 12u32;
#[doc(hidden)] pub const LOGIC_OP_OR_INVERTED: u32 = 13u32;
#[doc(hidden)] pub const LOGIC_OP_NAND: u32 = 14u32;
#[doc(hidden)] pub const LOGIC_OP_SET: u32 = 15u32;

#[doc(hidden)] pub type MemoryHeapFlagBits = u32;
#[doc(hidden)] pub const MEMORY_HEAP_DEVICE_LOCAL_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const MEMORY_HEAP_MULTI_INSTANCE_BIT: u32 = 0x2u32;

#[doc(hidden)] pub type AccessFlagBits = u32;
#[doc(hidden)] pub const ACCESS_INDIRECT_COMMAND_READ_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const ACCESS_INDEX_READ_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const ACCESS_VERTEX_ATTRIBUTE_READ_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const ACCESS_UNIFORM_READ_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const ACCESS_INPUT_ATTACHMENT_READ_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const ACCESS_SHADER_READ_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const ACCESS_SHADER_WRITE_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const ACCESS_COLOR_ATTACHMENT_READ_BIT: u32 = 0x80u32;
#[doc(hidden)] pub const ACCESS_COLOR_ATTACHMENT_WRITE_BIT: u32 = 0x100u32;
#[doc(hidden)] pub const ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: u32 = 0x200u32;
#[doc(hidden)] pub const ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: u32 = 0x400u32;
#[doc(hidden)] pub const ACCESS_TRANSFER_READ_BIT: u32 = 0x800u32;
#[doc(hidden)] pub const ACCESS_TRANSFER_WRITE_BIT: u32 = 0x1000u32;
#[doc(hidden)] pub const ACCESS_HOST_READ_BIT: u32 = 0x2000u32;
#[doc(hidden)] pub const ACCESS_HOST_WRITE_BIT: u32 = 0x4000u32;
#[doc(hidden)] pub const ACCESS_MEMORY_READ_BIT: u32 = 0x8000u32;
#[doc(hidden)] pub const ACCESS_MEMORY_WRITE_BIT: u32 = 0x10000u32;
#[doc(hidden)] pub const ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: u32 = 0x2000000u32;
#[doc(hidden)] pub const ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: u32 = 0x4000000u32;
#[doc(hidden)] pub const ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: u32 = 0x8000000u32;
#[doc(hidden)] pub const ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT: u32 = 0x100000u32;
#[doc(hidden)] pub const ACCESS_COMMAND_PROCESS_READ_BIT_NVX: u32 = 0x20000u32;
#[doc(hidden)] pub const ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX: u32 = 0x40000u32;
#[doc(hidden)] pub const ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: u32 = 0x80000u32;
#[doc(hidden)] pub const ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV: u32 = 0x800000u32;
#[doc(hidden)] pub const ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV: u32 = 0x200000u32;
#[doc(hidden)] pub const ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV: u32 = 0x400000u32;
#[doc(hidden)] pub const ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: u32 = 0x1000000u32;

#[doc(hidden)] pub type MemoryPropertyFlagBits = u32;
#[doc(hidden)] pub const MEMORY_PROPERTY_DEVICE_LOCAL_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const MEMORY_PROPERTY_HOST_VISIBLE_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const MEMORY_PROPERTY_HOST_COHERENT_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const MEMORY_PROPERTY_HOST_CACHED_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const MEMORY_PROPERTY_PROTECTED_BIT: u32 = 0x20u32;

#[doc(hidden)] pub type PhysicalDeviceType = u32;
#[doc(hidden)] pub const PHYSICAL_DEVICE_TYPE_OTHER: u32 = 0u32;
#[doc(hidden)] pub const PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: u32 = 1u32;
#[doc(hidden)] pub const PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: u32 = 2u32;
#[doc(hidden)] pub const PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: u32 = 3u32;
#[doc(hidden)] pub const PHYSICAL_DEVICE_TYPE_CPU: u32 = 4u32;

#[doc(hidden)] pub type PipelineBindPoint = u32;
#[doc(hidden)] pub const PIPELINE_BIND_POINT_GRAPHICS: u32 = 0u32;
#[doc(hidden)] pub const PIPELINE_BIND_POINT_COMPUTE: u32 = 1u32;
#[doc(hidden)] pub const PIPELINE_BIND_POINT_RAY_TRACING_NV: u32 = 1000165000u32;

#[doc(hidden)] pub type PipelineCreateFlagBits = u32;
#[doc(hidden)] pub const PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const PIPELINE_CREATE_DERIVATIVE_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const PIPELINE_CREATE_DISPATCH_BASE: u32 = 0x10u32;
#[doc(hidden)] pub const PIPELINE_CREATE_DEFER_COMPILE_BIT_NV: u32 = 0x20u32;

#[doc(hidden)] pub type PrimitiveTopology = u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_POINT_LIST: u32 = 0u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_LINE_LIST: u32 = 1u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_LINE_STRIP: u32 = 2u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_TRIANGLE_LIST: u32 = 3u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP: u32 = 4u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_TRIANGLE_FAN: u32 = 5u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY: u32 = 6u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY: u32 = 7u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY: u32 = 8u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY: u32 = 9u32;
#[doc(hidden)] pub const PRIMITIVE_TOPOLOGY_PATCH_LIST: u32 = 10u32;

#[doc(hidden)] pub type QueryControlFlagBits = u32;
#[doc(hidden)] pub const QUERY_CONTROL_PRECISE_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type QueryPipelineStatisticFlagBits = u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT: u32 = 0x80u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT: u32 = 0x100u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: u32 = 0x200u32;
#[doc(hidden)] pub const QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT: u32 = 0x400u32;

#[doc(hidden)] pub type QueryResultFlagBits = u32;
#[doc(hidden)] pub const QUERY_RESULT_64_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const QUERY_RESULT_WAIT_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const QUERY_RESULT_WITH_AVAILABILITY_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const QUERY_RESULT_PARTIAL_BIT: u32 = 0x8u32;

#[doc(hidden)] pub type QueryType = u32;
#[doc(hidden)] pub const QUERY_TYPE_OCCLUSION: u32 = 0u32;
#[doc(hidden)] pub const QUERY_TYPE_PIPELINE_STATISTICS: u32 = 1u32;
#[doc(hidden)] pub const QUERY_TYPE_TIMESTAMP: u32 = 2u32;
#[doc(hidden)] pub const QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT: u32 = 1000028004u32;
#[doc(hidden)] pub const QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: u32 = 1000165000u32;

#[doc(hidden)] pub type QueueFlagBits = u32;
#[doc(hidden)] pub const QUEUE_GRAPHICS_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const QUEUE_COMPUTE_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const QUEUE_TRANSFER_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const QUEUE_SPARSE_BINDING_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const QUEUE_PROTECTED_BIT: u32 = 0x10u32;

#[doc(hidden)] pub type SubpassContents = u32;
#[doc(hidden)] pub const SUBPASS_CONTENTS_INLINE: u32 = 0u32;
#[doc(hidden)] pub const SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: u32 = 1u32;

#[doc(hidden)] pub type Result = u32;
#[doc(hidden)] pub const SUCCESS: u32 = 0u32;
#[doc(hidden)] pub const NOT_READY: u32 = 1u32;
#[doc(hidden)] pub const TIMEOUT: u32 = 2u32;
#[doc(hidden)] pub const EVENT_SET: u32 = 3u32;
#[doc(hidden)] pub const EVENT_RESET: u32 = 4u32;
#[doc(hidden)] pub const INCOMPLETE: u32 = 5u32;
#[doc(hidden)] pub const ERROR_OUT_OF_HOST_MEMORY: u32 = -1i32 as u32;
#[doc(hidden)] pub const ERROR_OUT_OF_DEVICE_MEMORY: u32 = -2i32 as u32;
#[doc(hidden)] pub const ERROR_INITIALIZATION_FAILED: u32 = -3i32 as u32;
#[doc(hidden)] pub const ERROR_DEVICE_LOST: u32 = -4i32 as u32;
#[doc(hidden)] pub const ERROR_MEMORY_MAP_FAILED: u32 = -5i32 as u32;
#[doc(hidden)] pub const ERROR_LAYER_NOT_PRESENT: u32 = -6i32 as u32;
#[doc(hidden)] pub const ERROR_EXTENSION_NOT_PRESENT: u32 = -7i32 as u32;
#[doc(hidden)] pub const ERROR_FEATURE_NOT_PRESENT: u32 = -8i32 as u32;
#[doc(hidden)] pub const ERROR_INCOMPATIBLE_DRIVER: u32 = -9i32 as u32;
#[doc(hidden)] pub const ERROR_TOO_MANY_OBJECTS: u32 = -10i32 as u32;
#[doc(hidden)] pub const ERROR_FORMAT_NOT_SUPPORTED: u32 = -11i32 as u32;
#[doc(hidden)] pub const ERROR_FRAGMENTED_POOL: u32 = -12i32 as u32;
#[doc(hidden)] pub const ERROR_OUT_OF_POOL_MEMORY: u32 = -1000069000i32 as u32;
#[doc(hidden)] pub const ERROR_INVALID_EXTERNAL_HANDLE: u32 = -1000072003i32 as u32;
#[doc(hidden)] pub const ERROR_SURFACE_LOST_KHR: u32 = -1000000000i32 as u32;
#[doc(hidden)] pub const ERROR_NATIVE_WINDOW_IN_USE_KHR: u32 = -1000000001i32 as u32;
#[doc(hidden)] pub const SUBOPTIMAL_KHR: u32 = 1000001003u32;
#[doc(hidden)] pub const ERROR_OUT_OF_DATE_KHR: u32 = -1000001004i32 as u32;
#[doc(hidden)] pub const ERROR_INCOMPATIBLE_DISPLAY_KHR: u32 = -1000003001i32 as u32;
#[doc(hidden)] pub const ERROR_VALIDATION_FAILED_EXT: u32 = -1000011001i32 as u32;
#[doc(hidden)] pub const ERROR_INVALID_SHADER_NV: u32 = -1000012000i32 as u32;
#[doc(hidden)] pub const ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: u32 = -1000158000i32 as u32;
#[doc(hidden)] pub const ERROR_FRAGMENTATION_EXT: u32 = -1000161000i32 as u32;
#[doc(hidden)] pub const ERROR_NOT_PERMITTED_EXT: u32 = -1000174001i32 as u32;

#[doc(hidden)] pub type ShaderStageFlagBits = u32;
#[doc(hidden)] pub const SHADER_STAGE_VERTEX_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const SHADER_STAGE_TESSELLATION_CONTROL_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const SHADER_STAGE_TESSELLATION_EVALUATION_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const SHADER_STAGE_GEOMETRY_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const SHADER_STAGE_FRAGMENT_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const SHADER_STAGE_COMPUTE_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const SHADER_STAGE_ALL_GRAPHICS: u32 = 0x0000001Fu32;
#[doc(hidden)] pub const SHADER_STAGE_ALL: u32 = 0x7FFFFFFFu32;
#[doc(hidden)] pub const SHADER_STAGE_RAYGEN_BIT_NV: u32 = 0x100u32;
#[doc(hidden)] pub const SHADER_STAGE_ANY_HIT_BIT_NV: u32 = 0x200u32;
#[doc(hidden)] pub const SHADER_STAGE_CLOSEST_HIT_BIT_NV: u32 = 0x400u32;
#[doc(hidden)] pub const SHADER_STAGE_MISS_BIT_NV: u32 = 0x800u32;
#[doc(hidden)] pub const SHADER_STAGE_INTERSECTION_BIT_NV: u32 = 0x1000u32;
#[doc(hidden)] pub const SHADER_STAGE_CALLABLE_BIT_NV: u32 = 0x2000u32;
#[doc(hidden)] pub const SHADER_STAGE_TASK_BIT_NV: u32 = 0x40u32;
#[doc(hidden)] pub const SHADER_STAGE_MESH_BIT_NV: u32 = 0x80u32;

#[doc(hidden)] pub type SparseMemoryBindFlagBits = u32;
#[doc(hidden)] pub const SPARSE_MEMORY_BIND_METADATA_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type StencilFaceFlagBits = u32;
#[doc(hidden)] pub const STENCIL_FACE_FRONT_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const STENCIL_FACE_BACK_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const STENCIL_FRONT_AND_BACK: u32 = 0x00000003u32;

#[doc(hidden)] pub type StencilOp = u32;
#[doc(hidden)] pub const STENCIL_OP_KEEP: u32 = 0u32;
#[doc(hidden)] pub const STENCIL_OP_ZERO: u32 = 1u32;
#[doc(hidden)] pub const STENCIL_OP_REPLACE: u32 = 2u32;
#[doc(hidden)] pub const STENCIL_OP_INCREMENT_AND_CLAMP: u32 = 3u32;
#[doc(hidden)] pub const STENCIL_OP_DECREMENT_AND_CLAMP: u32 = 4u32;
#[doc(hidden)] pub const STENCIL_OP_INVERT: u32 = 5u32;
#[doc(hidden)] pub const STENCIL_OP_INCREMENT_AND_WRAP: u32 = 6u32;
#[doc(hidden)] pub const STENCIL_OP_DECREMENT_AND_WRAP: u32 = 7u32;

#[doc(hidden)] pub type StructureType = u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_APPLICATION_INFO: u32 = 0u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_INSTANCE_CREATE_INFO: u32 = 1u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: u32 = 2u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_CREATE_INFO: u32 = 3u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SUBMIT_INFO: u32 = 4u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: u32 = 5u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: u32 = 6u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BIND_SPARSE_INFO: u32 = 7u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_FENCE_CREATE_INFO: u32 = 8u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: u32 = 9u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EVENT_CREATE_INFO: u32 = 10u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: u32 = 11u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BUFFER_CREATE_INFO: u32 = 12u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: u32 = 13u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_CREATE_INFO: u32 = 14u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: u32 = 15u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: u32 = 16u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: u32 = 17u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: u32 = 18u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: u32 = 19u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: u32 = 20u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: u32 = 21u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: u32 = 22u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: u32 = 23u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: u32 = 24u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: u32 = 25u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: u32 = 26u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: u32 = 27u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: u32 = 28u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: u32 = 29u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: u32 = 30u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SAMPLER_CREATE_INFO: u32 = 31u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: u32 = 32u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: u32 = 33u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: u32 = 34u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: u32 = 35u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: u32 = 36u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: u32 = 37u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: u32 = 38u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: u32 = 39u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: u32 = 40u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: u32 = 41u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: u32 = 42u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: u32 = 43u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: u32 = 44u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: u32 = 45u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_BARRIER: u32 = 46u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: u32 = 47u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: u32 = 48u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: u32 = 1000094000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: u32 = 1000157000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: u32 = 1000157001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: u32 = 1000083000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: u32 = 1000127000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: u32 = 1000127001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: u32 = 1000060000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: u32 = 1000060003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: u32 = 1000060004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: u32 = 1000060005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: u32 = 1000060006u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: u32 = 1000060013u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: u32 = 1000060014u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: u32 = 1000070000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: u32 = 1000070001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: u32 = 1000146000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: u32 = 1000146001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: u32 = 1000146002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: u32 = 1000146003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: u32 = 1000146004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: u32 = 1000059000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: u32 = 1000059001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_FORMAT_PROPERTIES_2: u32 = 1000059002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: u32 = 1000059003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: u32 = 1000059004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: u32 = 1000059005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: u32 = 1000059006u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: u32 = 1000059007u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: u32 = 1000059008u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: u32 = 1000117000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: u32 = 1000117001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: u32 = 1000117002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: u32 = 1000117003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: u32 = 1000053000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: u32 = 1000053001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: u32 = 1000053002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: u32 = 1000120000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: u32 = 1000145000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: u32 = 1000145001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: u32 = 1000145002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: u32 = 1000145003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: u32 = 1000156000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: u32 = 1000156001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: u32 = 1000156002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: u32 = 1000156003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: u32 = 1000156004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: u32 = 1000156005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: u32 = 1000085000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: u32 = 1000071000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: u32 = 1000071001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: u32 = 1000071002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: u32 = 1000071003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: u32 = 1000071004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: u32 = 1000072000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: u32 = 1000072001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: u32 = 1000072002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: u32 = 1000112000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: u32 = 1000112001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: u32 = 1000113000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: u32 = 1000077000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: u32 = 1000076000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: u32 = 1000076001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: u32 = 1000168000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: u32 = 1000168001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: u32 = 1000063000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: u32 = 1000001000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PRESENT_INFO_KHR: u32 = 1000001001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: u32 = 1000060007u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: u32 = 1000060008u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: u32 = 1000060009u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: u32 = 1000060010u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: u32 = 1000060011u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: u32 = 1000060012u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: u32 = 1000002000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: u32 = 1000002001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: u32 = 1000003000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR: u32 = 1000004000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR: u32 = 1000005000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR: u32 = 1000006000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR: u32 = 1000008000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR: u32 = 1000009000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: u32 = 1000011000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: u32 = 1000018000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: u32 = 1000022000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: u32 = 1000022001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: u32 = 1000022002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: u32 = 1000026000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: u32 = 1000026001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: u32 = 1000026002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: u32 = 1000028000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: u32 = 1000028001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: u32 = 1000028002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: u32 = 1000041000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: u32 = 1000050000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: u32 = 1000056000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: u32 = 1000056001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: u32 = 1000057000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: u32 = 1000057001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: u32 = 1000058000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: u32 = 1000061000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN: u32 = 1000062000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: u32 = 1000067000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: u32 = 1000067001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: u32 = 1000073000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: u32 = 1000073001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: u32 = 1000073002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR: u32 = 1000073003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: u32 = 1000074000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: u32 = 1000074001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: u32 = 1000074002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: u32 = 1000075000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: u32 = 1000078000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: u32 = 1000078001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: u32 = 1000078002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: u32 = 1000078003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: u32 = 1000079000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: u32 = 1000079001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: u32 = 1000080000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: u32 = 1000081000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: u32 = 1000081001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: u32 = 1000081002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: u32 = 1000082000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PRESENT_REGIONS_KHR: u32 = 1000084000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX: u32 = 1000086000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX: u32 = 1000086001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX: u32 = 1000086002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX: u32 = 1000086003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX: u32 = 1000086004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX: u32 = 1000086005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: u32 = 1000087000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: u32 = 1000090000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: u32 = 1000091000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: u32 = 1000091001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: u32 = 1000091002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: u32 = 1000091003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: u32 = 1000092000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: u32 = 1000097000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: u32 = 1000098000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: u32 = 1000099000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: u32 = 1000099001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: u32 = 1000101000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: u32 = 1000101001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_HDR_METADATA_EXT: u32 = 1000105000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: u32 = 1000109000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: u32 = 1000109001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: u32 = 1000109002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: u32 = 1000109003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: u32 = 1000109004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: u32 = 1000109005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: u32 = 1000109006u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: u32 = 1000111000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: u32 = 1000114000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: u32 = 1000114001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR: u32 = 1000114002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: u32 = 1000115000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: u32 = 1000115001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: u32 = 1000119000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: u32 = 1000119001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: u32 = 1000119002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: u32 = 1000121000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: u32 = 1000121001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: u32 = 1000121002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: u32 = 1000121003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: u32 = 1000121004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK: u32 = 1000122000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK: u32 = 1000123000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: u32 = 1000128000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: u32 = 1000128001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: u32 = 1000128002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: u32 = 1000128003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: u32 = 1000128004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: u32 = 1000129000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: u32 = 1000129001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: u32 = 1000129002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: u32 = 1000129003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: u32 = 1000129004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: u32 = 1000129005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: u32 = 1000130000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: u32 = 1000130001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: u32 = 1000138000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: u32 = 1000138001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: u32 = 1000138002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: u32 = 1000138003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: u32 = 1000143000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: u32 = 1000143001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: u32 = 1000143002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: u32 = 1000143003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: u32 = 1000143004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: u32 = 1000147000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: u32 = 1000148000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: u32 = 1000148001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: u32 = 1000148002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: u32 = 1000149000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: u32 = 1000152000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: u32 = 1000158000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: u32 = 1000158001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: u32 = 1000158002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: u32 = 1000158003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: u32 = 1000158004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: u32 = 1000158005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: u32 = 1000160000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: u32 = 1000160001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: u32 = 1000161000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: u32 = 1000161001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: u32 = 1000161002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: u32 = 1000161003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: u32 = 1000161004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: u32 = 1000164000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: u32 = 1000164001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: u32 = 1000164002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: u32 = 1000164005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: u32 = 1000165000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: u32 = 1000165001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_GEOMETRY_NV: u32 = 1000165003u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: u32 = 1000165004u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_GEOMETRY_AABB_NV: u32 = 1000165005u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: u32 = 1000165006u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: u32 = 1000165007u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: u32 = 1000165008u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: u32 = 1000165009u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: u32 = 1000165011u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: u32 = 1000165012u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: u32 = 1000166000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: u32 = 1000166001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: u32 = 1000174000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: u32 = 1000177000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: u32 = 1000178000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: u32 = 1000178001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: u32 = 1000178002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: u32 = 1000180000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: u32 = 1000184000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: u32 = 1000185000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: u32 = 1000189000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: u32 = 1000190000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: u32 = 1000190001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: u32 = 1000190002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: u32 = 1000196000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: u32 = 1000197000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: u32 = 1000201000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: u32 = 1000202000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: u32 = 1000202001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: u32 = 1000203000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: u32 = 1000204000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: u32 = 1000205000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: u32 = 1000205002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_CHECKPOINT_DATA_NV: u32 = 1000206000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: u32 = 1000206001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: u32 = 1000211000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: u32 = 1000212000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: u32 = 1000214000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: u32 = 1000218000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: u32 = 1000218001u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: u32 = 1000218002u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: u32 = 1000221000u32;
#[doc(hidden)] pub const STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: u32 = 1000246000u32;

#[doc(hidden)] pub type SystemAllocationScope = u32;
#[doc(hidden)] pub const SYSTEM_ALLOCATION_SCOPE_COMMAND: u32 = 0u32;
#[doc(hidden)] pub const SYSTEM_ALLOCATION_SCOPE_OBJECT: u32 = 1u32;
#[doc(hidden)] pub const SYSTEM_ALLOCATION_SCOPE_CACHE: u32 = 2u32;
#[doc(hidden)] pub const SYSTEM_ALLOCATION_SCOPE_DEVICE: u32 = 3u32;
#[doc(hidden)] pub const SYSTEM_ALLOCATION_SCOPE_INSTANCE: u32 = 4u32;

#[doc(hidden)] pub type InternalAllocationType = u32;
#[doc(hidden)] pub const INTERNAL_ALLOCATION_TYPE_EXECUTABLE: u32 = 0u32;

#[doc(hidden)] pub type SamplerAddressMode = u32;
#[doc(hidden)] pub const SAMPLER_ADDRESS_MODE_REPEAT: u32 = 0u32;
#[doc(hidden)] pub const SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT: u32 = 1u32;
#[doc(hidden)] pub const SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: u32 = 2u32;
#[doc(hidden)] pub const SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: u32 = 3u32;

#[doc(hidden)] pub type Filter = u32;
#[doc(hidden)] pub const FILTER_NEAREST: u32 = 0u32;
#[doc(hidden)] pub const FILTER_LINEAR: u32 = 1u32;
#[doc(hidden)] pub const FILTER_CUBIC_IMG: u32 = 1000015000u32;

#[doc(hidden)] pub type SamplerMipmapMode = u32;
#[doc(hidden)] pub const SAMPLER_MIPMAP_MODE_NEAREST: u32 = 0u32;
#[doc(hidden)] pub const SAMPLER_MIPMAP_MODE_LINEAR: u32 = 1u32;

#[doc(hidden)] pub type VertexInputRate = u32;
#[doc(hidden)] pub const VERTEX_INPUT_RATE_VERTEX: u32 = 0u32;
#[doc(hidden)] pub const VERTEX_INPUT_RATE_INSTANCE: u32 = 1u32;

#[doc(hidden)] pub type PipelineStageFlagBits = u32;
#[doc(hidden)] pub const PIPELINE_STAGE_TOP_OF_PIPE_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const PIPELINE_STAGE_DRAW_INDIRECT_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const PIPELINE_STAGE_VERTEX_INPUT_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const PIPELINE_STAGE_VERTEX_SHADER_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const PIPELINE_STAGE_GEOMETRY_SHADER_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const PIPELINE_STAGE_FRAGMENT_SHADER_BIT: u32 = 0x80u32;
#[doc(hidden)] pub const PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: u32 = 0x100u32;
#[doc(hidden)] pub const PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: u32 = 0x200u32;
#[doc(hidden)] pub const PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: u32 = 0x400u32;
#[doc(hidden)] pub const PIPELINE_STAGE_COMPUTE_SHADER_BIT: u32 = 0x800u32;
#[doc(hidden)] pub const PIPELINE_STAGE_TRANSFER_BIT: u32 = 0x1000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: u32 = 0x2000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_HOST_BIT: u32 = 0x4000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_ALL_GRAPHICS_BIT: u32 = 0x8000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_ALL_COMMANDS_BIT: u32 = 0x10000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT: u32 = 0x1000000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT: u32 = 0x40000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX: u32 = 0x20000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV: u32 = 0x400000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV: u32 = 0x200000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV: u32 = 0x2000000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_TASK_SHADER_BIT_NV: u32 = 0x80000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_MESH_SHADER_BIT_NV: u32 = 0x100000u32;
#[doc(hidden)] pub const PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT: u32 = 0x800000u32;

#[doc(hidden)] pub type SparseImageFormatFlagBits = u32;
#[doc(hidden)] pub const SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: u32 = 0x4u32;

#[doc(hidden)] pub type SampleCountFlagBits = u32;
#[doc(hidden)] pub const SAMPLE_COUNT_1_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const SAMPLE_COUNT_2_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const SAMPLE_COUNT_4_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const SAMPLE_COUNT_8_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const SAMPLE_COUNT_16_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const SAMPLE_COUNT_32_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const SAMPLE_COUNT_64_BIT: u32 = 0x40u32;

#[doc(hidden)] pub type AttachmentDescriptionFlagBits = u32;
#[doc(hidden)] pub const ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type DescriptorPoolCreateFlagBits = u32;
#[doc(hidden)] pub const DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT: u32 = 0x2u32;

#[doc(hidden)] pub type DependencyFlagBits = u32;
#[doc(hidden)] pub const DEPENDENCY_BY_REGION_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const DEPENDENCY_DEVICE_GROUP_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const DEPENDENCY_VIEW_LOCAL_BIT: u32 = 0x2u32;

#[doc(hidden)] pub type ObjectType = u32;
#[doc(hidden)] pub const OBJECT_TYPE_UNKNOWN: u32 = 0u32;
#[doc(hidden)] pub const OBJECT_TYPE_INSTANCE: u32 = 1u32;
#[doc(hidden)] pub const OBJECT_TYPE_PHYSICAL_DEVICE: u32 = 2u32;
#[doc(hidden)] pub const OBJECT_TYPE_DEVICE: u32 = 3u32;
#[doc(hidden)] pub const OBJECT_TYPE_QUEUE: u32 = 4u32;
#[doc(hidden)] pub const OBJECT_TYPE_SEMAPHORE: u32 = 5u32;
#[doc(hidden)] pub const OBJECT_TYPE_COMMAND_BUFFER: u32 = 6u32;
#[doc(hidden)] pub const OBJECT_TYPE_FENCE: u32 = 7u32;
#[doc(hidden)] pub const OBJECT_TYPE_DEVICE_MEMORY: u32 = 8u32;
#[doc(hidden)] pub const OBJECT_TYPE_BUFFER: u32 = 9u32;
#[doc(hidden)] pub const OBJECT_TYPE_IMAGE: u32 = 10u32;
#[doc(hidden)] pub const OBJECT_TYPE_EVENT: u32 = 11u32;
#[doc(hidden)] pub const OBJECT_TYPE_QUERY_POOL: u32 = 12u32;
#[doc(hidden)] pub const OBJECT_TYPE_BUFFER_VIEW: u32 = 13u32;
#[doc(hidden)] pub const OBJECT_TYPE_IMAGE_VIEW: u32 = 14u32;
#[doc(hidden)] pub const OBJECT_TYPE_SHADER_MODULE: u32 = 15u32;
#[doc(hidden)] pub const OBJECT_TYPE_PIPELINE_CACHE: u32 = 16u32;
#[doc(hidden)] pub const OBJECT_TYPE_PIPELINE_LAYOUT: u32 = 17u32;
#[doc(hidden)] pub const OBJECT_TYPE_RENDER_PASS: u32 = 18u32;
#[doc(hidden)] pub const OBJECT_TYPE_PIPELINE: u32 = 19u32;
#[doc(hidden)] pub const OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT: u32 = 20u32;
#[doc(hidden)] pub const OBJECT_TYPE_SAMPLER: u32 = 21u32;
#[doc(hidden)] pub const OBJECT_TYPE_DESCRIPTOR_POOL: u32 = 22u32;
#[doc(hidden)] pub const OBJECT_TYPE_DESCRIPTOR_SET: u32 = 23u32;
#[doc(hidden)] pub const OBJECT_TYPE_FRAMEBUFFER: u32 = 24u32;
#[doc(hidden)] pub const OBJECT_TYPE_COMMAND_POOL: u32 = 25u32;
#[doc(hidden)] pub const OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION: u32 = 1000156000u32;
#[doc(hidden)] pub const OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE: u32 = 1000085000u32;
#[doc(hidden)] pub const OBJECT_TYPE_SURFACE_KHR: u32 = 1000000000u32;
#[doc(hidden)] pub const OBJECT_TYPE_SWAPCHAIN_KHR: u32 = 1000001000u32;
#[doc(hidden)] pub const OBJECT_TYPE_DISPLAY_KHR: u32 = 1000002000u32;
#[doc(hidden)] pub const OBJECT_TYPE_DISPLAY_MODE_KHR: u32 = 1000002001u32;
#[doc(hidden)] pub const OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT: u32 = 1000011000u32;
#[doc(hidden)] pub const OBJECT_TYPE_OBJECT_TABLE_NVX: u32 = 1000086000u32;
#[doc(hidden)] pub const OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX: u32 = 1000086001u32;
#[doc(hidden)] pub const OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT: u32 = 1000128000u32;
#[doc(hidden)] pub const OBJECT_TYPE_VALIDATION_CACHE_EXT: u32 = 1000160000u32;
#[doc(hidden)] pub const OBJECT_TYPE_ACCELERATION_STRUCTURE_NV: u32 = 1000165000u32;

#[doc(hidden)] pub type DescriptorBindingFlagBitsEXT = u32;
#[doc(hidden)] pub const DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT: u32 = 0x1u32;
#[doc(hidden)] pub const DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT: u32 = 0x2u32;
#[doc(hidden)] pub const DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT: u32 = 0x4u32;
#[doc(hidden)] pub const DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT: u32 = 0x8u32;

#[doc(hidden)] pub type ConditionalRenderingFlagBitsEXT = u32;
#[doc(hidden)] pub const CONDITIONAL_RENDERING_INVERTED_BIT_EXT: u32 = 0x1u32;

#[doc(hidden)] pub type IndirectCommandsLayoutUsageFlagBitsNVX = u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX: u32 = 0x1u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX: u32 = 0x2u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX: u32 = 0x4u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX: u32 = 0x8u32;

#[doc(hidden)] pub type IndirectCommandsTokenTypeNVX = u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX: u32 = 0u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX: u32 = 1u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX: u32 = 2u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX: u32 = 3u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX: u32 = 4u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX: u32 = 5u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX: u32 = 6u32;
#[doc(hidden)] pub const INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX: u32 = 7u32;

#[doc(hidden)] pub type ObjectEntryUsageFlagBitsNVX = u32;
#[doc(hidden)] pub const OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX: u32 = 0x1u32;
#[doc(hidden)] pub const OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX: u32 = 0x2u32;

#[doc(hidden)] pub type ObjectEntryTypeNVX = u32;
#[doc(hidden)] pub const OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX: u32 = 0u32;
#[doc(hidden)] pub const OBJECT_ENTRY_TYPE_PIPELINE_NVX: u32 = 1u32;
#[doc(hidden)] pub const OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX: u32 = 2u32;
#[doc(hidden)] pub const OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX: u32 = 3u32;
#[doc(hidden)] pub const OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX: u32 = 4u32;

#[doc(hidden)] pub type DescriptorUpdateTemplateType = u32;
#[doc(hidden)] pub const DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET: u32 = 0u32;

#[doc(hidden)] pub type ViewportCoordinateSwizzleNV = u32;
#[doc(hidden)] pub const VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV: u32 = 0u32;
#[doc(hidden)] pub const VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV: u32 = 1u32;
#[doc(hidden)] pub const VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV: u32 = 2u32;
#[doc(hidden)] pub const VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV: u32 = 3u32;
#[doc(hidden)] pub const VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV: u32 = 4u32;
#[doc(hidden)] pub const VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV: u32 = 5u32;
#[doc(hidden)] pub const VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV: u32 = 6u32;
#[doc(hidden)] pub const VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV: u32 = 7u32;

#[doc(hidden)] pub type DiscardRectangleModeEXT = u32;
#[doc(hidden)] pub const DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT: u32 = 0u32;
#[doc(hidden)] pub const DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT: u32 = 1u32;

#[doc(hidden)] pub type SubpassDescriptionFlagBits = u32;
#[doc(hidden)] pub const SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX: u32 = 0x1u32;
#[doc(hidden)] pub const SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX: u32 = 0x2u32;

#[doc(hidden)] pub type PointClippingBehavior = u32;
#[doc(hidden)] pub const POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES: u32 = 0u32;
#[doc(hidden)] pub const POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY: u32 = 1u32;

#[doc(hidden)] pub type CoverageModulationModeNV = u32;
#[doc(hidden)] pub const COVERAGE_MODULATION_MODE_NONE_NV: u32 = 0u32;
#[doc(hidden)] pub const COVERAGE_MODULATION_MODE_RGB_NV: u32 = 1u32;
#[doc(hidden)] pub const COVERAGE_MODULATION_MODE_ALPHA_NV: u32 = 2u32;
#[doc(hidden)] pub const COVERAGE_MODULATION_MODE_RGBA_NV: u32 = 3u32;

#[doc(hidden)] pub type ValidationCacheHeaderVersionEXT = u32;
#[doc(hidden)] pub const VALIDATION_CACHE_HEADER_VERSION_ONE_EXT: u32 = 1u32;

#[doc(hidden)] pub type ShaderInfoTypeAMD = u32;
#[doc(hidden)] pub const SHADER_INFO_TYPE_STATISTICS_AMD: u32 = 0u32;
#[doc(hidden)] pub const SHADER_INFO_TYPE_BINARY_AMD: u32 = 1u32;
#[doc(hidden)] pub const SHADER_INFO_TYPE_DISASSEMBLY_AMD: u32 = 2u32;

#[doc(hidden)] pub type QueueGlobalPriorityEXT = u32;
#[doc(hidden)] pub const QUEUE_GLOBAL_PRIORITY_LOW_EXT: u32 = 128u32;
#[doc(hidden)] pub const QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT: u32 = 256u32;
#[doc(hidden)] pub const QUEUE_GLOBAL_PRIORITY_HIGH_EXT: u32 = 512u32;
#[doc(hidden)] pub const QUEUE_GLOBAL_PRIORITY_REALTIME_EXT: u32 = 1024u32;

#[doc(hidden)] pub type TimeDomainEXT = u32;
#[doc(hidden)] pub const TIME_DOMAIN_DEVICE_EXT: u32 = 0u32;
#[doc(hidden)] pub const TIME_DOMAIN_CLOCK_MONOTONIC_EXT: u32 = 1u32;
#[doc(hidden)] pub const TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT: u32 = 2u32;
#[doc(hidden)] pub const TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT: u32 = 3u32;

#[doc(hidden)] pub type ConservativeRasterizationModeEXT = u32;
#[doc(hidden)] pub const CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT: u32 = 0u32;
#[doc(hidden)] pub const CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT: u32 = 1u32;
#[doc(hidden)] pub const CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT: u32 = 2u32;

#[doc(hidden)] pub type GeometryFlagBitsNV = u32;
#[doc(hidden)] pub const GEOMETRY_OPAQUE_BIT_NV: u32 = 0x1u32;
#[doc(hidden)] pub const GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV: u32 = 0x2u32;

#[doc(hidden)] pub type GeometryInstanceFlagBitsNV = u32;
#[doc(hidden)] pub const GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV: u32 = 0x1u32;
#[doc(hidden)] pub const GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV: u32 = 0x2u32;
#[doc(hidden)] pub const GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV: u32 = 0x4u32;
#[doc(hidden)] pub const GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV: u32 = 0x8u32;

#[doc(hidden)] pub type BuildAccelerationStructureFlagBitsNV = u32;
#[doc(hidden)] pub const BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV: u32 = 0x1u32;
#[doc(hidden)] pub const BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV: u32 = 0x2u32;
#[doc(hidden)] pub const BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV: u32 = 0x4u32;
#[doc(hidden)] pub const BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV: u32 = 0x8u32;
#[doc(hidden)] pub const BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV: u32 = 0x10u32;

#[doc(hidden)] pub type CopyAccelerationStructureModeNV = u32;
#[doc(hidden)] pub const COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV: u32 = 0u32;
#[doc(hidden)] pub const COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV: u32 = 1u32;

#[doc(hidden)] pub type AccelerationStructureTypeNV = u32;
#[doc(hidden)] pub const ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV: u32 = 0u32;
#[doc(hidden)] pub const ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV: u32 = 1u32;

#[doc(hidden)] pub type GeometryTypeNV = u32;
#[doc(hidden)] pub const GEOMETRY_TYPE_TRIANGLES_NV: u32 = 0u32;
#[doc(hidden)] pub const GEOMETRY_TYPE_AABBS_NV: u32 = 1u32;

#[doc(hidden)] pub type RayTracingShaderGroupTypeNV = u32;
#[doc(hidden)] pub const RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV: u32 = 0u32;
#[doc(hidden)] pub const RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV: u32 = 1u32;
#[doc(hidden)] pub const RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV: u32 = 2u32;

#[doc(hidden)] pub type AccelerationStructureMemoryRequirementsTypeNV = u32;
#[doc(hidden)] pub const ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV: u32 = 0u32;
#[doc(hidden)] pub const ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV: u32 = 1u32;
#[doc(hidden)] pub const ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV: u32 = 2u32;

#[doc(hidden)] pub type MemoryOverallocationBehaviorAMD = u32;
#[doc(hidden)] pub const MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD: u32 = 0u32;
#[doc(hidden)] pub const MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD: u32 = 1u32;
#[doc(hidden)] pub const MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD: u32 = 2u32;

#[doc(hidden)] pub type ColorSpaceKHR = u32;
#[doc(hidden)] pub const COLOR_SPACE_SRGB_NONLINEAR_KHR: u32 = 0u32;
#[doc(hidden)] pub const COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT: u32 = 1000104001u32;
#[doc(hidden)] pub const COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT: u32 = 1000104002u32;
#[doc(hidden)] pub const COLOR_SPACE_DCI_P3_LINEAR_EXT: u32 = 1000104003u32;
#[doc(hidden)] pub const COLOR_SPACE_DCI_P3_NONLINEAR_EXT: u32 = 1000104004u32;
#[doc(hidden)] pub const COLOR_SPACE_BT709_LINEAR_EXT: u32 = 1000104005u32;
#[doc(hidden)] pub const COLOR_SPACE_BT709_NONLINEAR_EXT: u32 = 1000104006u32;
#[doc(hidden)] pub const COLOR_SPACE_BT2020_LINEAR_EXT: u32 = 1000104007u32;
#[doc(hidden)] pub const COLOR_SPACE_HDR10_ST2084_EXT: u32 = 1000104008u32;
#[doc(hidden)] pub const COLOR_SPACE_DOLBYVISION_EXT: u32 = 1000104009u32;
#[doc(hidden)] pub const COLOR_SPACE_HDR10_HLG_EXT: u32 = 1000104010u32;
#[doc(hidden)] pub const COLOR_SPACE_ADOBERGB_LINEAR_EXT: u32 = 1000104011u32;
#[doc(hidden)] pub const COLOR_SPACE_ADOBERGB_NONLINEAR_EXT: u32 = 1000104012u32;
#[doc(hidden)] pub const COLOR_SPACE_PASS_THROUGH_EXT: u32 = 1000104013u32;
#[doc(hidden)] pub const COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT: u32 = 1000104014u32;

#[doc(hidden)] pub type CompositeAlphaFlagBitsKHR = u32;
#[doc(hidden)] pub const COMPOSITE_ALPHA_OPAQUE_BIT_KHR: u32 = 0x1u32;
#[doc(hidden)] pub const COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: u32 = 0x2u32;
#[doc(hidden)] pub const COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: u32 = 0x4u32;
#[doc(hidden)] pub const COMPOSITE_ALPHA_INHERIT_BIT_KHR: u32 = 0x8u32;

#[doc(hidden)] pub type DisplayPlaneAlphaFlagBitsKHR = u32;
#[doc(hidden)] pub const DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: u32 = 0x1u32;
#[doc(hidden)] pub const DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: u32 = 0x2u32;
#[doc(hidden)] pub const DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: u32 = 0x4u32;
#[doc(hidden)] pub const DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: u32 = 0x8u32;

#[doc(hidden)] pub type PresentModeKHR = u32;
#[doc(hidden)] pub const PRESENT_MODE_IMMEDIATE_KHR: u32 = 0u32;
#[doc(hidden)] pub const PRESENT_MODE_MAILBOX_KHR: u32 = 1u32;
#[doc(hidden)] pub const PRESENT_MODE_FIFO_KHR: u32 = 2u32;
#[doc(hidden)] pub const PRESENT_MODE_FIFO_RELAXED_KHR: u32 = 3u32;
#[doc(hidden)] pub const PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR: u32 = 1000111000u32;
#[doc(hidden)] pub const PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR: u32 = 1000111001u32;

#[doc(hidden)] pub type SurfaceTransformFlagBitsKHR = u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_IDENTITY_BIT_KHR: u32 = 0x1u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: u32 = 0x2u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: u32 = 0x4u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: u32 = 0x8u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: u32 = 0x10u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: u32 = 0x20u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: u32 = 0x40u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: u32 = 0x80u32;
#[doc(hidden)] pub const SURFACE_TRANSFORM_INHERIT_BIT_KHR: u32 = 0x100u32;

#[doc(hidden)] pub type DebugReportFlagBitsEXT = u32;
#[doc(hidden)] pub const DEBUG_REPORT_INFORMATION_BIT_EXT: u32 = 0x1u32;
#[doc(hidden)] pub const DEBUG_REPORT_WARNING_BIT_EXT: u32 = 0x2u32;
#[doc(hidden)] pub const DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT: u32 = 0x4u32;
#[doc(hidden)] pub const DEBUG_REPORT_ERROR_BIT_EXT: u32 = 0x8u32;
#[doc(hidden)] pub const DEBUG_REPORT_DEBUG_BIT_EXT: u32 = 0x10u32;

#[doc(hidden)] pub type DebugReportObjectTypeEXT = u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT: u32 = 0u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT: u32 = 1u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT: u32 = 2u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT: u32 = 3u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT: u32 = 4u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT: u32 = 5u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT: u32 = 6u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT: u32 = 7u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT: u32 = 8u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT: u32 = 9u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT: u32 = 10u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT: u32 = 11u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT: u32 = 12u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT: u32 = 13u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT: u32 = 14u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT: u32 = 15u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT: u32 = 16u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT: u32 = 17u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT: u32 = 18u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT: u32 = 19u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT: u32 = 20u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT: u32 = 21u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT: u32 = 22u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT: u32 = 23u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT: u32 = 24u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT: u32 = 25u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT: u32 = 26u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT: u32 = 27u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT: u32 = 28u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT: u32 = 29u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT: u32 = 30u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT: u32 = 31u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT: u32 = 32u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT: u32 = 33u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT: u32 = 1000156000u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT: u32 = 1000085000u32;
#[doc(hidden)] pub const DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT: u32 = 1000165000u32;

#[doc(hidden)] pub type RasterizationOrderAMD = u32;
#[doc(hidden)] pub const RASTERIZATION_ORDER_STRICT_AMD: u32 = 0u32;
#[doc(hidden)] pub const RASTERIZATION_ORDER_RELAXED_AMD: u32 = 1u32;

#[doc(hidden)] pub type ExternalMemoryHandleTypeFlagBitsNV = u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV: u32 = 0x1u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV: u32 = 0x2u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV: u32 = 0x4u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV: u32 = 0x8u32;

#[doc(hidden)] pub type ExternalMemoryFeatureFlagBitsNV = u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: u32 = 0x1u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: u32 = 0x2u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: u32 = 0x4u32;

#[doc(hidden)] pub type ValidationCheckEXT = u32;
#[doc(hidden)] pub const VALIDATION_CHECK_ALL_EXT: u32 = 0u32;
#[doc(hidden)] pub const VALIDATION_CHECK_SHADERS_EXT: u32 = 1u32;

#[doc(hidden)] pub type ExternalMemoryHandleTypeFlagBits = u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT: u32 = 0x200u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID: u32 = 0x400u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT: u32 = 0x80u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT: u32 = 0x100u32;

#[doc(hidden)] pub type ExternalMemoryFeatureFlagBits = u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: u32 = 0x4u32;

#[doc(hidden)] pub type ExternalSemaphoreHandleTypeFlagBits = u32;
#[doc(hidden)] pub const EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: u32 = 0x10u32;

#[doc(hidden)] pub type ExternalSemaphoreFeatureFlagBits = u32;
#[doc(hidden)] pub const EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: u32 = 0x2u32;

#[doc(hidden)] pub type SemaphoreImportFlagBits = u32;
#[doc(hidden)] pub const SEMAPHORE_IMPORT_TEMPORARY_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type ExternalFenceHandleTypeFlagBits = u32;
#[doc(hidden)] pub const EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: u32 = 0x8u32;

#[doc(hidden)] pub type ExternalFenceFeatureFlagBits = u32;
#[doc(hidden)] pub const EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: u32 = 0x2u32;

#[doc(hidden)] pub type FenceImportFlagBits = u32;
#[doc(hidden)] pub const FENCE_IMPORT_TEMPORARY_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type SurfaceCounterFlagBitsEXT = u32;
#[doc(hidden)] pub const SURFACE_COUNTER_VBLANK_EXT: u32 = 0x1u32;

#[doc(hidden)] pub type DisplayPowerStateEXT = u32;
#[doc(hidden)] pub const DISPLAY_POWER_STATE_OFF_EXT: u32 = 0u32;
#[doc(hidden)] pub const DISPLAY_POWER_STATE_SUSPEND_EXT: u32 = 1u32;
#[doc(hidden)] pub const DISPLAY_POWER_STATE_ON_EXT: u32 = 2u32;

#[doc(hidden)] pub type DeviceEventTypeEXT = u32;
#[doc(hidden)] pub const DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT: u32 = 0u32;

#[doc(hidden)] pub type DisplayEventTypeEXT = u32;
#[doc(hidden)] pub const DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT: u32 = 0u32;

#[doc(hidden)] pub type PeerMemoryFeatureFlagBits = u32;
#[doc(hidden)] pub const PEER_MEMORY_FEATURE_COPY_SRC_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const PEER_MEMORY_FEATURE_COPY_DST_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const PEER_MEMORY_FEATURE_GENERIC_DST_BIT: u32 = 0x8u32;

#[doc(hidden)] pub type MemoryAllocateFlagBits = u32;
#[doc(hidden)] pub const MEMORY_ALLOCATE_DEVICE_MASK_BIT: u32 = 0x1u32;

#[doc(hidden)] pub type DeviceGroupPresentModeFlagBitsKHR = u32;
#[doc(hidden)] pub const DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR: u32 = 0x1u32;
#[doc(hidden)] pub const DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR: u32 = 0x2u32;
#[doc(hidden)] pub const DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR: u32 = 0x4u32;
#[doc(hidden)] pub const DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR: u32 = 0x8u32;

#[doc(hidden)] pub type SwapchainCreateFlagBitsKHR = u32;
#[doc(hidden)] pub const SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: u32 = 0x1u32;
#[doc(hidden)] pub const SWAPCHAIN_CREATE_PROTECTED_BIT_KHR: u32 = 0x2u32;
#[doc(hidden)] pub const SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR: u32 = 0x4u32;

#[doc(hidden)] pub type SubgroupFeatureFlagBits = u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_BASIC_BIT: u32 = 0x1u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_VOTE_BIT: u32 = 0x2u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_ARITHMETIC_BIT: u32 = 0x4u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_BALLOT_BIT: u32 = 0x8u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_SHUFFLE_BIT: u32 = 0x10u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: u32 = 0x20u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_CLUSTERED_BIT: u32 = 0x40u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_QUAD_BIT: u32 = 0x80u32;
#[doc(hidden)] pub const SUBGROUP_FEATURE_PARTITIONED_BIT_NV: u32 = 0x100u32;

#[doc(hidden)] pub type TessellationDomainOrigin = u32;
#[doc(hidden)] pub const TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT: u32 = 0u32;
#[doc(hidden)] pub const TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT: u32 = 1u32;

#[doc(hidden)] pub type SamplerYcbcrModelConversion = u32;
#[doc(hidden)] pub const SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY: u32 = 0u32;
#[doc(hidden)] pub const SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY: u32 = 1u32;
#[doc(hidden)] pub const SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709: u32 = 2u32;
#[doc(hidden)] pub const SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601: u32 = 3u32;
#[doc(hidden)] pub const SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020: u32 = 4u32;

#[doc(hidden)] pub type SamplerYcbcrRange = u32;
#[doc(hidden)] pub const SAMPLER_YCBCR_RANGE_ITU_FULL: u32 = 0u32;
#[doc(hidden)] pub const SAMPLER_YCBCR_RANGE_ITU_NARROW: u32 = 1u32;

#[doc(hidden)] pub type ChromaLocation = u32;
#[doc(hidden)] pub const CHROMA_LOCATION_COSITED_EVEN: u32 = 0u32;
#[doc(hidden)] pub const CHROMA_LOCATION_MIDPOINT: u32 = 1u32;

#[doc(hidden)] pub type SamplerReductionModeEXT = u32;
#[doc(hidden)] pub const SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT: u32 = 0u32;
#[doc(hidden)] pub const SAMPLER_REDUCTION_MODE_MIN_EXT: u32 = 1u32;
#[doc(hidden)] pub const SAMPLER_REDUCTION_MODE_MAX_EXT: u32 = 2u32;

#[doc(hidden)] pub type BlendOverlapEXT = u32;
#[doc(hidden)] pub const BLEND_OVERLAP_UNCORRELATED_EXT: u32 = 0u32;
#[doc(hidden)] pub const BLEND_OVERLAP_DISJOINT_EXT: u32 = 1u32;
#[doc(hidden)] pub const BLEND_OVERLAP_CONJOINT_EXT: u32 = 2u32;

#[doc(hidden)] pub type DebugUtilsMessageSeverityFlagBitsEXT = u32;
#[doc(hidden)] pub const DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT: u32 = 0x1u32;
#[doc(hidden)] pub const DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT: u32 = 0x10u32;
#[doc(hidden)] pub const DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT: u32 = 0x100u32;
#[doc(hidden)] pub const DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT: u32 = 0x1000u32;

#[doc(hidden)] pub type DebugUtilsMessageTypeFlagBitsEXT = u32;
#[doc(hidden)] pub const DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT: u32 = 0x1u32;
#[doc(hidden)] pub const DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT: u32 = 0x2u32;
#[doc(hidden)] pub const DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT: u32 = 0x4u32;

#[doc(hidden)] pub type VendorId = u32;
#[doc(hidden)] pub const VENDOR_ID_VIV: u32 = 0x10001u32;
#[doc(hidden)] pub const VENDOR_ID_VSI: u32 = 0x10002u32;
#[doc(hidden)] pub const VENDOR_ID_KAZAN: u32 = 0x10003u32;

#[doc(hidden)] pub type DriverIdKHR = u32;
#[doc(hidden)] pub const DRIVER_ID_AMD_PROPRIETARY_KHR: u32 = 1u32;
#[doc(hidden)] pub const DRIVER_ID_AMD_OPEN_SOURCE_KHR: u32 = 2u32;
#[doc(hidden)] pub const DRIVER_ID_MESA_RADV_KHR: u32 = 3u32;
#[doc(hidden)] pub const DRIVER_ID_NVIDIA_PROPRIETARY_KHR: u32 = 4u32;
#[doc(hidden)] pub const DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR: u32 = 5u32;
#[doc(hidden)] pub const DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR: u32 = 6u32;
#[doc(hidden)] pub const DRIVER_ID_IMAGINATION_PROPRIETARY_KHR: u32 = 7u32;
#[doc(hidden)] pub const DRIVER_ID_QUALCOMM_PROPRIETARY_KHR: u32 = 8u32;
#[doc(hidden)] pub const DRIVER_ID_ARM_PROPRIETARY_KHR: u32 = 9u32;
#[doc(hidden)] pub const DRIVER_ID_GOOGLE_PASTEL_KHR: u32 = 10u32;

#[doc(hidden)] pub type ShadingRatePaletteEntryNV = u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV: u32 = 0u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV: u32 = 1u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV: u32 = 2u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV: u32 = 3u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV: u32 = 4u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV: u32 = 5u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV: u32 = 6u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV: u32 = 7u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV: u32 = 8u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV: u32 = 9u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV: u32 = 10u32;
#[doc(hidden)] pub const SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV: u32 = 11u32;

#[doc(hidden)] pub type CoarseSampleOrderTypeNV = u32;
#[doc(hidden)] pub const COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV: u32 = 0u32;
#[doc(hidden)] pub const COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV: u32 = 1u32;
#[doc(hidden)] pub const COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV: u32 = 2u32;
#[doc(hidden)] pub const COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV: u32 = 3u32;



#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BaseOutStructure {
  pub sType: StructureType,
  pub pNext: *mut BaseOutStructure,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BaseInStructure {
  pub sType: StructureType,
  pub pNext: *const BaseInStructure,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Offset2D {
  pub x: i32,
  pub y: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Offset3D {
  pub x: i32,
  pub y: i32,
  pub z: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Extent2D {
  pub width: u32,
  pub height: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Extent3D {
  pub width: u32,
  pub height: u32,
  pub depth: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Viewport {
  pub x: f32,
  pub y: f32,
  pub width: f32,
  pub height: f32,
  pub minDepth: f32,
  pub maxDepth: f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rect2D {
  pub offset: Offset2D,
  pub extent: Extent2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClearRect {
  pub rect: Rect2D,
  pub baseArrayLayer: u32,
  pub layerCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComponentMapping {
  pub r: ComponentSwizzle,
  pub g: ComponentSwizzle,
  pub b: ComponentSwizzle,
  pub a: ComponentSwizzle,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProperties {
  pub apiVersion: u32,
  pub driverVersion: u32,
  pub vendorID: u32,
  pub deviceID: u32,
  pub deviceType: PhysicalDeviceType,
  pub deviceName: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE as usize],
  pub pipelineCacheUUID: [u8; UUID_SIZE as usize],
  pub limits: PhysicalDeviceLimits,
  pub sparseProperties: PhysicalDeviceSparseProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExtensionProperties {
  pub extensionName: [c_char; MAX_EXTENSION_NAME_SIZE as usize],
  pub specVersion: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LayerProperties {
  pub layerName: [c_char; MAX_EXTENSION_NAME_SIZE as usize],
  pub specVersion: u32,
  pub implementationVersion: u32,
  pub description: [c_char; MAX_DESCRIPTION_SIZE as usize],
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ApplicationInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub pApplicationName: *const c_char,
  pub applicationVersion: u32,
  pub pEngineName: *const c_char,
  pub engineVersion: u32,
  pub apiVersion: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AllocationCallbacks {
  pub pUserData: *mut c_void,
  pub pfnAllocation: PFN_vkAllocationFunction,
  pub pfnReallocation: PFN_vkReallocationFunction,
  pub pfnFree: PFN_vkFreeFunction,
  pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
  pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceQueueCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DeviceQueueCreateFlags,
  pub queueFamilyIndex: u32,
  pub queueCount: u32,
  pub pQueuePriorities: *const f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DeviceCreateFlags,
  pub queueCreateInfoCount: u32,
  pub pQueueCreateInfos: *const DeviceQueueCreateInfo,
  pub enabledLayerCount: u32,
  pub ppEnabledLayerNames: *const *const c_char,
  pub enabledExtensionCount: u32,
  pub ppEnabledExtensionNames: *const *const c_char,
  pub pEnabledFeatures: *const PhysicalDeviceFeatures,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InstanceCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: InstanceCreateFlags,
  pub pApplicationInfo: *const ApplicationInfo,
  pub enabledLayerCount: u32,
  pub ppEnabledLayerNames: *const *const c_char,
  pub enabledExtensionCount: u32,
  pub ppEnabledExtensionNames: *const *const c_char,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueFamilyProperties {
  pub queueFlags: QueueFlags,
  pub queueCount: u32,
  pub timestampValidBits: u32,
  pub minImageTransferGranularity: Extent3D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryProperties {
  pub memoryTypeCount: u32,
  pub memoryTypes: [MemoryType; MAX_MEMORY_TYPES as usize],
  pub memoryHeapCount: u32,
  pub memoryHeaps: [MemoryHeap; MAX_MEMORY_HEAPS as usize],
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryAllocateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub allocationSize: DeviceSize,
  pub memoryTypeIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRequirements {
  pub size: DeviceSize,
  pub alignment: DeviceSize,
  pub memoryTypeBits: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseImageFormatProperties {
  pub aspectMask: ImageAspectFlags,
  pub imageGranularity: Extent3D,
  pub flags: SparseImageFormatFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseImageMemoryRequirements {
  pub formatProperties: SparseImageFormatProperties,
  pub imageMipTailFirstLod: u32,
  pub imageMipTailSize: DeviceSize,
  pub imageMipTailOffset: DeviceSize,
  pub imageMipTailStride: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryType {
  pub propertyFlags: MemoryPropertyFlags,
  pub heapIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryHeap {
  pub size: DeviceSize,
  pub flags: MemoryHeapFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MappedMemoryRange {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub memory: DeviceMemory,
  pub offset: DeviceSize,
  pub size: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormatProperties {
  pub linearTilingFeatures: FormatFeatureFlags,
  pub optimalTilingFeatures: FormatFeatureFlags,
  pub bufferFeatures: FormatFeatureFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageFormatProperties {
  pub maxExtent: Extent3D,
  pub maxMipLevels: u32,
  pub maxArrayLayers: u32,
  pub sampleCounts: SampleCountFlags,
  pub maxResourceSize: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorBufferInfo {
  pub buffer: Buffer,
  pub offset: DeviceSize,
  pub range: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorImageInfo {
  pub sampler: Sampler,
  pub imageView: ImageView,
  pub imageLayout: ImageLayout,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WriteDescriptorSet {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub dstSet: DescriptorSet,
  pub dstBinding: u32,
  pub dstArrayElement: u32,
  pub descriptorCount: u32,
  pub descriptorType: DescriptorType,
  pub pImageInfo: *const DescriptorImageInfo,
  pub pBufferInfo: *const DescriptorBufferInfo,
  pub pTexelBufferView: *const BufferView,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyDescriptorSet {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub srcSet: DescriptorSet,
  pub srcBinding: u32,
  pub srcArrayElement: u32,
  pub dstSet: DescriptorSet,
  pub dstBinding: u32,
  pub dstArrayElement: u32,
  pub descriptorCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: BufferCreateFlags,
  pub size: DeviceSize,
  pub usage: BufferUsageFlags,
  pub sharingMode: SharingMode,
  pub queueFamilyIndexCount: u32,
  pub pQueueFamilyIndices: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferViewCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: BufferViewCreateFlags,
  pub buffer: Buffer,
  pub format: Format,
  pub offset: DeviceSize,
  pub range: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageSubresource {
  pub aspectMask: ImageAspectFlags,
  pub mipLevel: u32,
  pub arrayLayer: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageSubresourceLayers {
  pub aspectMask: ImageAspectFlags,
  pub mipLevel: u32,
  pub baseArrayLayer: u32,
  pub layerCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageSubresourceRange {
  pub aspectMask: ImageAspectFlags,
  pub baseMipLevel: u32,
  pub levelCount: u32,
  pub baseArrayLayer: u32,
  pub layerCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryBarrier {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub srcAccessMask: AccessFlags,
  pub dstAccessMask: AccessFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferMemoryBarrier {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub srcAccessMask: AccessFlags,
  pub dstAccessMask: AccessFlags,
  pub srcQueueFamilyIndex: u32,
  pub dstQueueFamilyIndex: u32,
  pub buffer: Buffer,
  pub offset: DeviceSize,
  pub size: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageMemoryBarrier {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub srcAccessMask: AccessFlags,
  pub dstAccessMask: AccessFlags,
  pub oldLayout: ImageLayout,
  pub newLayout: ImageLayout,
  pub srcQueueFamilyIndex: u32,
  pub dstQueueFamilyIndex: u32,
  pub image: Image,
  pub subresourceRange: ImageSubresourceRange,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: ImageCreateFlags,
  pub imageType: ImageType,
  pub format: Format,
  pub extent: Extent3D,
  pub mipLevels: u32,
  pub arrayLayers: u32,
  pub samples: SampleCountFlagBits,
  pub tiling: ImageTiling,
  pub usage: ImageUsageFlags,
  pub sharingMode: SharingMode,
  pub queueFamilyIndexCount: u32,
  pub pQueueFamilyIndices: *const u32,
  pub initialLayout: ImageLayout,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubresourceLayout {
  pub offset: DeviceSize,
  pub size: DeviceSize,
  pub rowPitch: DeviceSize,
  pub arrayPitch: DeviceSize,
  pub depthPitch: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageViewCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: ImageViewCreateFlags,
  pub image: Image,
  pub viewType: ImageViewType,
  pub format: Format,
  pub components: ComponentMapping,
  pub subresourceRange: ImageSubresourceRange,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferCopy {
  pub srcOffset: DeviceSize,
  pub dstOffset: DeviceSize,
  pub size: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseMemoryBind {
  pub resourceOffset: DeviceSize,
  pub size: DeviceSize,
  pub memory: DeviceMemory,
  pub memoryOffset: DeviceSize,
  pub flags: SparseMemoryBindFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseImageMemoryBind {
  pub subresource: ImageSubresource,
  pub offset: Offset3D,
  pub extent: Extent3D,
  pub memory: DeviceMemory,
  pub memoryOffset: DeviceSize,
  pub flags: SparseMemoryBindFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseBufferMemoryBindInfo {
  pub buffer: Buffer,
  pub bindCount: u32,
  pub pBinds: *const SparseMemoryBind,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseImageOpaqueMemoryBindInfo {
  pub image: Image,
  pub bindCount: u32,
  pub pBinds: *const SparseMemoryBind,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseImageMemoryBindInfo {
  pub image: Image,
  pub bindCount: u32,
  pub pBinds: *const SparseImageMemoryBind,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindSparseInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub waitSemaphoreCount: u32,
  pub pWaitSemaphores: *const Semaphore,
  pub bufferBindCount: u32,
  pub pBufferBinds: *const SparseBufferMemoryBindInfo,
  pub imageOpaqueBindCount: u32,
  pub pImageOpaqueBinds: *const SparseImageOpaqueMemoryBindInfo,
  pub imageBindCount: u32,
  pub pImageBinds: *const SparseImageMemoryBindInfo,
  pub signalSemaphoreCount: u32,
  pub pSignalSemaphores: *const Semaphore,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageCopy {
  pub srcSubresource: ImageSubresourceLayers,
  pub srcOffset: Offset3D,
  pub dstSubresource: ImageSubresourceLayers,
  pub dstOffset: Offset3D,
  pub extent: Extent3D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImageBlit {
  pub srcSubresource: ImageSubresourceLayers,
  pub srcOffsets: [Offset3D; 2],
  pub dstSubresource: ImageSubresourceLayers,
  pub dstOffsets: [Offset3D; 2],
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferImageCopy {
  pub bufferOffset: DeviceSize,
  pub bufferRowLength: u32,
  pub bufferImageHeight: u32,
  pub imageSubresource: ImageSubresourceLayers,
  pub imageOffset: Offset3D,
  pub imageExtent: Extent3D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageResolve {
  pub srcSubresource: ImageSubresourceLayers,
  pub srcOffset: Offset3D,
  pub dstSubresource: ImageSubresourceLayers,
  pub dstOffset: Offset3D,
  pub extent: Extent3D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderModuleCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: ShaderModuleCreateFlags,
  pub codeSize: usize,
  pub pCode: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSetLayoutBinding {
  pub binding: u32,
  pub descriptorType: DescriptorType,
  pub descriptorCount: u32,
  pub stageFlags: ShaderStageFlags,
  pub pImmutableSamplers: *const Sampler,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSetLayoutCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DescriptorSetLayoutCreateFlags,
  pub bindingCount: u32,
  pub pBindings: *const DescriptorSetLayoutBinding,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorPoolSize {
  pub typ: DescriptorType,
  pub descriptorCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorPoolCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DescriptorPoolCreateFlags,
  pub maxSets: u32,
  pub poolSizeCount: u32,
  pub pPoolSizes: *const DescriptorPoolSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSetAllocateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub descriptorPool: DescriptorPool,
  pub descriptorSetCount: u32,
  pub pSetLayouts: *const DescriptorSetLayout,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpecializationMapEntry {
  pub constantID: u32,
  pub offset: u32,
  pub size: usize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpecializationInfo {
  pub mapEntryCount: u32,
  pub pMapEntries: *const SpecializationMapEntry,
  pub dataSize: usize,
  pub pData: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineShaderStageCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineShaderStageCreateFlags,
  pub stage: ShaderStageFlagBits,
  pub module: ShaderModule,
  pub pName: *const c_char,
  pub pSpecializationInfo: *const SpecializationInfo,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComputePipelineCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineCreateFlags,
  pub stage: PipelineShaderStageCreateInfo,
  pub layout: PipelineLayout,
  pub basePipelineHandle: Pipeline,
  pub basePipelineIndex: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VertexInputBindingDescription {
  pub binding: u32,
  pub stride: u32,
  pub inputRate: VertexInputRate,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VertexInputAttributeDescription {
  pub location: u32,
  pub binding: u32,
  pub format: Format,
  pub offset: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineVertexInputStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineVertexInputStateCreateFlags,
  pub vertexBindingDescriptionCount: u32,
  pub pVertexBindingDescriptions: *const VertexInputBindingDescription,
  pub vertexAttributeDescriptionCount: u32,
  pub pVertexAttributeDescriptions: *const VertexInputAttributeDescription,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineInputAssemblyStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineInputAssemblyStateCreateFlags,
  pub topology: PrimitiveTopology,
  pub primitiveRestartEnable: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineTessellationStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineTessellationStateCreateFlags,
  pub patchControlPoints: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineViewportStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineViewportStateCreateFlags,
  pub viewportCount: u32,
  pub pViewports: *const Viewport,
  pub scissorCount: u32,
  pub pScissors: *const Rect2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineRasterizationStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineRasterizationStateCreateFlags,
  pub depthClampEnable: Bool32,
  pub rasterizerDiscardEnable: Bool32,
  pub polygonMode: PolygonMode,
  pub cullMode: CullModeFlags,
  pub frontFace: FrontFace,
  pub depthBiasEnable: Bool32,
  pub depthBiasConstantFactor: f32,
  pub depthBiasClamp: f32,
  pub depthBiasSlopeFactor: f32,
  pub lineWidth: f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineMultisampleStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineMultisampleStateCreateFlags,
  pub rasterizationSamples: SampleCountFlagBits,
  pub sampleShadingEnable: Bool32,
  pub minSampleShading: f32,
  pub pSampleMask: *const SampleMask,
  pub alphaToCoverageEnable: Bool32,
  pub alphaToOneEnable: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineColorBlendAttachmentState {
  pub blendEnable: Bool32,
  pub srcColorBlendFactor: BlendFactor,
  pub dstColorBlendFactor: BlendFactor,
  pub colorBlendOp: BlendOp,
  pub srcAlphaBlendFactor: BlendFactor,
  pub dstAlphaBlendFactor: BlendFactor,
  pub alphaBlendOp: BlendOp,
  pub colorWriteMask: ColorComponentFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PipelineColorBlendStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineColorBlendStateCreateFlags,
  pub logicOpEnable: Bool32,
  pub logicOp: LogicOp,
  pub attachmentCount: u32,
  pub pAttachments: *const PipelineColorBlendAttachmentState,
  pub blendConstants: [f32; 4],
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDynamicStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineDynamicStateCreateFlags,
  pub dynamicStateCount: u32,
  pub pDynamicStates: *const DynamicState,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StencilOpState {
  pub failOp: StencilOp,
  pub passOp: StencilOp,
  pub depthFailOp: StencilOp,
  pub compareOp: CompareOp,
  pub compareMask: u32,
  pub writeMask: u32,
  pub reference: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDepthStencilStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineDepthStencilStateCreateFlags,
  pub depthTestEnable: Bool32,
  pub depthWriteEnable: Bool32,
  pub depthCompareOp: CompareOp,
  pub depthBoundsTestEnable: Bool32,
  pub stencilTestEnable: Bool32,
  pub front: StencilOpState,
  pub back: StencilOpState,
  pub minDepthBounds: f32,
  pub maxDepthBounds: f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GraphicsPipelineCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineCreateFlags,
  pub stageCount: u32,
  pub pStages: *const PipelineShaderStageCreateInfo,
  pub pVertexInputState: *const PipelineVertexInputStateCreateInfo,
  pub pInputAssemblyState: *const PipelineInputAssemblyStateCreateInfo,
  pub pTessellationState: *const PipelineTessellationStateCreateInfo,
  pub pViewportState: *const PipelineViewportStateCreateInfo,
  pub pRasterizationState: *const PipelineRasterizationStateCreateInfo,
  pub pMultisampleState: *const PipelineMultisampleStateCreateInfo,
  pub pDepthStencilState: *const PipelineDepthStencilStateCreateInfo,
  pub pColorBlendState: *const PipelineColorBlendStateCreateInfo,
  pub pDynamicState: *const PipelineDynamicStateCreateInfo,
  pub layout: PipelineLayout,
  pub renderPass: RenderPass,
  pub subpass: u32,
  pub basePipelineHandle: Pipeline,
  pub basePipelineIndex: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineCacheCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineCacheCreateFlags,
  pub initialDataSize: usize,
  pub pInitialData: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PushConstantRange {
  pub stageFlags: ShaderStageFlags,
  pub offset: u32,
  pub size: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineLayoutCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineLayoutCreateFlags,
  pub setLayoutCount: u32,
  pub pSetLayouts: *const DescriptorSetLayout,
  pub pushConstantRangeCount: u32,
  pub pPushConstantRanges: *const PushConstantRange,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: SamplerCreateFlags,
  pub magFilter: Filter,
  pub minFilter: Filter,
  pub mipmapMode: SamplerMipmapMode,
  pub addressModeU: SamplerAddressMode,
  pub addressModeV: SamplerAddressMode,
  pub addressModeW: SamplerAddressMode,
  pub mipLodBias: f32,
  pub anisotropyEnable: Bool32,
  pub maxAnisotropy: f32,
  pub compareEnable: Bool32,
  pub compareOp: CompareOp,
  pub minLod: f32,
  pub maxLod: f32,
  pub borderColor: BorderColor,
  pub unnormalizedCoordinates: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandPoolCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: CommandPoolCreateFlags,
  pub queueFamilyIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandBufferAllocateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub commandPool: CommandPool,
  pub level: CommandBufferLevel,
  pub commandBufferCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandBufferInheritanceInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub renderPass: RenderPass,
  pub subpass: u32,
  pub framebuffer: Framebuffer,
  pub occlusionQueryEnable: Bool32,
  pub queryFlags: QueryControlFlags,
  pub pipelineStatistics: QueryPipelineStatisticFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandBufferBeginInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: CommandBufferUsageFlags,
  pub pInheritanceInfo: *const CommandBufferInheritanceInfo,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RenderPassBeginInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub renderPass: RenderPass,
  pub framebuffer: Framebuffer,
  pub renderArea: Rect2D,
  pub clearValueCount: u32,
  pub pClearValues: *const ClearValue,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ClearColorValue {
  pub float32: [f32; 4],
  pub int32: [i32; 4],
  pub uint32: [u32; 4],
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClearDepthStencilValue {
  pub depth: f32,
  pub stencil: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ClearValue {
  pub color: ClearColorValue,
  pub depthStencil: ClearDepthStencilValue,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ClearAttachment {
  pub aspectMask: ImageAspectFlags,
  pub colorAttachment: u32,
  pub clearValue: ClearValue,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttachmentDescription {
  pub flags: AttachmentDescriptionFlags,
  pub format: Format,
  pub samples: SampleCountFlagBits,
  pub loadOp: AttachmentLoadOp,
  pub storeOp: AttachmentStoreOp,
  pub stencilLoadOp: AttachmentLoadOp,
  pub stencilStoreOp: AttachmentStoreOp,
  pub initialLayout: ImageLayout,
  pub finalLayout: ImageLayout,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttachmentReference {
  pub attachment: u32,
  pub layout: ImageLayout,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubpassDescription {
  pub flags: SubpassDescriptionFlags,
  pub pipelineBindPoint: PipelineBindPoint,
  pub inputAttachmentCount: u32,
  pub pInputAttachments: *const AttachmentReference,
  pub colorAttachmentCount: u32,
  pub pColorAttachments: *const AttachmentReference,
  pub pResolveAttachments: *const AttachmentReference,
  pub pDepthStencilAttachment: *const AttachmentReference,
  pub preserveAttachmentCount: u32,
  pub pPreserveAttachments: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubpassDependency {
  pub srcSubpass: u32,
  pub dstSubpass: u32,
  pub srcStageMask: PipelineStageFlags,
  pub dstStageMask: PipelineStageFlags,
  pub srcAccessMask: AccessFlags,
  pub dstAccessMask: AccessFlags,
  pub dependencyFlags: DependencyFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderPassCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: RenderPassCreateFlags,
  pub attachmentCount: u32,
  pub pAttachments: *const AttachmentDescription,
  pub subpassCount: u32,
  pub pSubpasses: *const SubpassDescription,
  pub dependencyCount: u32,
  pub pDependencies: *const SubpassDependency,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: EventCreateFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FenceCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: FenceCreateFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceFeatures {
  pub robustBufferAccess: Bool32,
  pub fullDrawIndexUint32: Bool32,
  pub imageCubeArray: Bool32,
  pub independentBlend: Bool32,
  pub geometryShader: Bool32,
  pub tessellationShader: Bool32,
  pub sampleRateShading: Bool32,
  pub dualSrcBlend: Bool32,
  pub logicOp: Bool32,
  pub multiDrawIndirect: Bool32,
  pub drawIndirectFirstInstance: Bool32,
  pub depthClamp: Bool32,
  pub depthBiasClamp: Bool32,
  pub fillModeNonSolid: Bool32,
  pub depthBounds: Bool32,
  pub wideLines: Bool32,
  pub largePoints: Bool32,
  pub alphaToOne: Bool32,
  pub multiViewport: Bool32,
  pub samplerAnisotropy: Bool32,
  pub textureCompressionETC2: Bool32,
  pub textureCompressionASTC_LDR: Bool32,
  pub textureCompressionBC: Bool32,
  pub occlusionQueryPrecise: Bool32,
  pub pipelineStatisticsQuery: Bool32,
  pub vertexPipelineStoresAndAtomics: Bool32,
  pub fragmentStoresAndAtomics: Bool32,
  pub shaderTessellationAndGeometryPointSize: Bool32,
  pub shaderImageGatherExtended: Bool32,
  pub shaderStorageImageExtendedFormats: Bool32,
  pub shaderStorageImageMultisample: Bool32,
  pub shaderStorageImageReadWithoutFormat: Bool32,
  pub shaderStorageImageWriteWithoutFormat: Bool32,
  pub shaderUniformBufferArrayDynamicIndexing: Bool32,
  pub shaderSampledImageArrayDynamicIndexing: Bool32,
  pub shaderStorageBufferArrayDynamicIndexing: Bool32,
  pub shaderStorageImageArrayDynamicIndexing: Bool32,
  pub shaderClipDistance: Bool32,
  pub shaderCullDistance: Bool32,
  pub shaderFloat64: Bool32,
  pub shaderInt64: Bool32,
  pub shaderInt16: Bool32,
  pub shaderResourceResidency: Bool32,
  pub shaderResourceMinLod: Bool32,
  pub sparseBinding: Bool32,
  pub sparseResidencyBuffer: Bool32,
  pub sparseResidencyImage2D: Bool32,
  pub sparseResidencyImage3D: Bool32,
  pub sparseResidency2Samples: Bool32,
  pub sparseResidency4Samples: Bool32,
  pub sparseResidency8Samples: Bool32,
  pub sparseResidency16Samples: Bool32,
  pub sparseResidencyAliased: Bool32,
  pub variableMultisampleRate: Bool32,
  pub inheritedQueries: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceSparseProperties {
  pub residencyStandard2DBlockShape: Bool32,
  pub residencyStandard2DMultisampleBlockShape: Bool32,
  pub residencyStandard3DBlockShape: Bool32,
  pub residencyAlignedMipSize: Bool32,
  pub residencyNonResidentStrict: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceLimits {
  pub maxImageDimension1D: u32,
  pub maxImageDimension2D: u32,
  pub maxImageDimension3D: u32,
  pub maxImageDimensionCube: u32,
  pub maxImageArrayLayers: u32,
  pub maxTexelBufferElements: u32,
  pub maxUniformBufferRange: u32,
  pub maxStorageBufferRange: u32,
  pub maxPushConstantsSize: u32,
  pub maxMemoryAllocationCount: u32,
  pub maxSamplerAllocationCount: u32,
  pub bufferImageGranularity: DeviceSize,
  pub sparseAddressSpaceSize: DeviceSize,
  pub maxBoundDescriptorSets: u32,
  pub maxPerStageDescriptorSamplers: u32,
  pub maxPerStageDescriptorUniformBuffers: u32,
  pub maxPerStageDescriptorStorageBuffers: u32,
  pub maxPerStageDescriptorSampledImages: u32,
  pub maxPerStageDescriptorStorageImages: u32,
  pub maxPerStageDescriptorInputAttachments: u32,
  pub maxPerStageResources: u32,
  pub maxDescriptorSetSamplers: u32,
  pub maxDescriptorSetUniformBuffers: u32,
  pub maxDescriptorSetUniformBuffersDynamic: u32,
  pub maxDescriptorSetStorageBuffers: u32,
  pub maxDescriptorSetStorageBuffersDynamic: u32,
  pub maxDescriptorSetSampledImages: u32,
  pub maxDescriptorSetStorageImages: u32,
  pub maxDescriptorSetInputAttachments: u32,
  pub maxVertexInputAttributes: u32,
  pub maxVertexInputBindings: u32,
  pub maxVertexInputAttributeOffset: u32,
  pub maxVertexInputBindingStride: u32,
  pub maxVertexOutputComponents: u32,
  pub maxTessellationGenerationLevel: u32,
  pub maxTessellationPatchSize: u32,
  pub maxTessellationControlPerVertexInputComponents: u32,
  pub maxTessellationControlPerVertexOutputComponents: u32,
  pub maxTessellationControlPerPatchOutputComponents: u32,
  pub maxTessellationControlTotalOutputComponents: u32,
  pub maxTessellationEvaluationInputComponents: u32,
  pub maxTessellationEvaluationOutputComponents: u32,
  pub maxGeometryShaderInvocations: u32,
  pub maxGeometryInputComponents: u32,
  pub maxGeometryOutputComponents: u32,
  pub maxGeometryOutputVertices: u32,
  pub maxGeometryTotalOutputComponents: u32,
  pub maxFragmentInputComponents: u32,
  pub maxFragmentOutputAttachments: u32,
  pub maxFragmentDualSrcAttachments: u32,
  pub maxFragmentCombinedOutputResources: u32,
  pub maxComputeSharedMemorySize: u32,
  pub maxComputeWorkGroupCount: [u32; 3],
  pub maxComputeWorkGroupInvocations: u32,
  pub maxComputeWorkGroupSize: [u32; 3],
  pub subPixelPrecisionBits: u32,
  pub subTexelPrecisionBits: u32,
  pub mipmapPrecisionBits: u32,
  pub maxDrawIndexedIndexValue: u32,
  pub maxDrawIndirectCount: u32,
  pub maxSamplerLodBias: f32,
  pub maxSamplerAnisotropy: f32,
  pub maxViewports: u32,
  pub maxViewportDimensions: [u32; 2],
  pub viewportBoundsRange: [f32; 2],
  pub viewportSubPixelBits: u32,
  pub minMemoryMapAlignment: usize,
  pub minTexelBufferOffsetAlignment: DeviceSize,
  pub minUniformBufferOffsetAlignment: DeviceSize,
  pub minStorageBufferOffsetAlignment: DeviceSize,
  pub minTexelOffset: i32,
  pub maxTexelOffset: u32,
  pub minTexelGatherOffset: i32,
  pub maxTexelGatherOffset: u32,
  pub minInterpolationOffset: f32,
  pub maxInterpolationOffset: f32,
  pub subPixelInterpolationOffsetBits: u32,
  pub maxFramebufferWidth: u32,
  pub maxFramebufferHeight: u32,
  pub maxFramebufferLayers: u32,
  pub framebufferColorSampleCounts: SampleCountFlags,
  pub framebufferDepthSampleCounts: SampleCountFlags,
  pub framebufferStencilSampleCounts: SampleCountFlags,
  pub framebufferNoAttachmentsSampleCounts: SampleCountFlags,
  pub maxColorAttachments: u32,
  pub sampledImageColorSampleCounts: SampleCountFlags,
  pub sampledImageIntegerSampleCounts: SampleCountFlags,
  pub sampledImageDepthSampleCounts: SampleCountFlags,
  pub sampledImageStencilSampleCounts: SampleCountFlags,
  pub storageImageSampleCounts: SampleCountFlags,
  pub maxSampleMaskWords: u32,
  pub timestampComputeAndGraphics: Bool32,
  pub timestampPeriod: f32,
  pub maxClipDistances: u32,
  pub maxCullDistances: u32,
  pub maxCombinedClipAndCullDistances: u32,
  pub discreteQueuePriorities: u32,
  pub pointSizeRange: [f32; 2],
  pub lineWidthRange: [f32; 2],
  pub pointSizeGranularity: f32,
  pub lineWidthGranularity: f32,
  pub strictLines: Bool32,
  pub standardSampleLocations: Bool32,
  pub optimalBufferCopyOffsetAlignment: DeviceSize,
  pub optimalBufferCopyRowPitchAlignment: DeviceSize,
  pub nonCoherentAtomSize: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SemaphoreCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: SemaphoreCreateFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryPoolCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: QueryPoolCreateFlags,
  pub queryType: QueryType,
  pub queryCount: u32,
  pub pipelineStatistics: QueryPipelineStatisticFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FramebufferCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: FramebufferCreateFlags,
  pub renderPass: RenderPass,
  pub attachmentCount: u32,
  pub pAttachments: *const ImageView,
  pub width: u32,
  pub height: u32,
  pub layers: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DrawIndirectCommand {
  pub vertexCount: u32,
  pub instanceCount: u32,
  pub firstVertex: u32,
  pub firstInstance: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DrawIndexedIndirectCommand {
  pub indexCount: u32,
  pub instanceCount: u32,
  pub firstIndex: u32,
  pub vertexOffset: i32,
  pub firstInstance: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DispatchIndirectCommand {
  pub x: u32,
  pub y: u32,
  pub z: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubmitInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub waitSemaphoreCount: u32,
  pub pWaitSemaphores: *const Semaphore,
  pub pWaitDstStageMask: *const PipelineStageFlags,
  pub commandBufferCount: u32,
  pub pCommandBuffers: *const CommandBuffer,
  pub signalSemaphoreCount: u32,
  pub pSignalSemaphores: *const Semaphore,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayPropertiesKHR {
  pub display: DisplayKHR,
  pub displayName: *const c_char,
  pub physicalDimensions: Extent2D,
  pub physicalResolution: Extent2D,
  pub supportedTransforms: SurfaceTransformFlagsKHR,
  pub planeReorderPossible: Bool32,
  pub persistentContent: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayPlanePropertiesKHR {
  pub currentDisplay: DisplayKHR,
  pub currentStackIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayModeParametersKHR {
  pub visibleRegion: Extent2D,
  pub refreshRate: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayModePropertiesKHR {
  pub displayMode: DisplayModeKHR,
  pub parameters: DisplayModeParametersKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayModeCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DisplayModeCreateFlagsKHR,
  pub parameters: DisplayModeParametersKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayPlaneCapabilitiesKHR {
  pub supportedAlpha: DisplayPlaneAlphaFlagsKHR,
  pub minSrcPosition: Offset2D,
  pub maxSrcPosition: Offset2D,
  pub minSrcExtent: Extent2D,
  pub maxSrcExtent: Extent2D,
  pub minDstPosition: Offset2D,
  pub maxDstPosition: Offset2D,
  pub minDstExtent: Extent2D,
  pub maxDstExtent: Extent2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplaySurfaceCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DisplaySurfaceCreateFlagsKHR,
  pub displayMode: DisplayModeKHR,
  pub planeIndex: u32,
  pub planeStackIndex: u32,
  pub transform: SurfaceTransformFlagBitsKHR,
  pub globalAlpha: f32,
  pub alphaMode: DisplayPlaneAlphaFlagBitsKHR,
  pub imageExtent: Extent2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayPresentInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub srcRect: Rect2D,
  pub dstRect: Rect2D,
  pub persistent: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SurfaceCapabilitiesKHR {
  pub minImageCount: u32,
  pub maxImageCount: u32,
  pub currentExtent: Extent2D,
  pub minImageExtent: Extent2D,
  pub maxImageExtent: Extent2D,
  pub maxImageArrayLayers: u32,
  pub supportedTransforms: SurfaceTransformFlagsKHR,
  pub currentTransform: SurfaceTransformFlagBitsKHR,
  pub supportedCompositeAlpha: CompositeAlphaFlagsKHR,
  pub supportedUsageFlags: ImageUsageFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AndroidSurfaceCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: AndroidSurfaceCreateFlagsKHR,
  pub window: *mut ANativeWindow,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViSurfaceCreateInfoNN {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: ViSurfaceCreateFlagsNN,
  pub window: *mut c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaylandSurfaceCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: WaylandSurfaceCreateFlagsKHR,
  pub display: *mut wl_display,
  pub surface: *mut wl_surface,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Win32SurfaceCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: Win32SurfaceCreateFlagsKHR,
  pub hinstance: HINSTANCE,
  pub hwnd: HWND,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XlibSurfaceCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: XlibSurfaceCreateFlagsKHR,
  pub dpy: *mut Display,
  pub window: Window,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XcbSurfaceCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: XcbSurfaceCreateFlagsKHR,
  pub connection: *mut xcb_connection_t,
  pub window: xcb_window_t,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImagePipeSurfaceCreateInfoFUCHSIA {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: ImagePipeSurfaceCreateFlagsFUCHSIA,
  pub imagePipeHandle: zx_handle_t,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SurfaceFormatKHR {
  pub format: Format,
  pub colorSpace: ColorSpaceKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwapchainCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: SwapchainCreateFlagsKHR,
  pub surface: SurfaceKHR,
  pub minImageCount: u32,
  pub imageFormat: Format,
  pub imageColorSpace: ColorSpaceKHR,
  pub imageExtent: Extent2D,
  pub imageArrayLayers: u32,
  pub imageUsage: ImageUsageFlags,
  pub imageSharingMode: SharingMode,
  pub queueFamilyIndexCount: u32,
  pub pQueueFamilyIndices: *const u32,
  pub preTransform: SurfaceTransformFlagBitsKHR,
  pub compositeAlpha: CompositeAlphaFlagBitsKHR,
  pub presentMode: PresentModeKHR,
  pub clipped: Bool32,
  pub oldSwapchain: SwapchainKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PresentInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub waitSemaphoreCount: u32,
  pub pWaitSemaphores: *const Semaphore,
  pub swapchainCount: u32,
  pub pSwapchains: *const SwapchainKHR,
  pub pImageIndices: *const u32,
  pub pResults: *mut Result,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugReportCallbackCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DebugReportFlagsEXT,
  pub pfnCallback: PFN_vkDebugReportCallbackEXT,
  pub pUserData: *mut c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidationFlagsEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub disabledValidationCheckCount: u32,
  pub pDisabledValidationChecks: *const ValidationCheckEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineRasterizationStateRasterizationOrderAMD {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub rasterizationOrder: RasterizationOrderAMD,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DebugMarkerObjectNameInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub objectType: DebugReportObjectTypeEXT,
  pub object: u64,
  pub pObjectName: *const c_char,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DebugMarkerObjectTagInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub objectType: DebugReportObjectTypeEXT,
  pub object: u64,
  pub tagName: u64,
  pub tagSize: usize,
  pub pTag: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugMarkerMarkerInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub pMarkerName: *const c_char,
  pub color: [f32; 4],
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DedicatedAllocationImageCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub dedicatedAllocation: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DedicatedAllocationBufferCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub dedicatedAllocation: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DedicatedAllocationMemoryAllocateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub image: Image,
  pub buffer: Buffer,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalImageFormatPropertiesNV {
  pub imageFormatProperties: ImageFormatProperties,
  pub externalMemoryFeatures: ExternalMemoryFeatureFlagsNV,
  pub exportFromImportedHandleTypes: ExternalMemoryHandleTypeFlagsNV,
  pub compatibleHandleTypes: ExternalMemoryHandleTypeFlagsNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalMemoryImageCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleTypes: ExternalMemoryHandleTypeFlagsNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportMemoryAllocateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleTypes: ExternalMemoryHandleTypeFlagsNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportMemoryWin32HandleInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleType: ExternalMemoryHandleTypeFlagsNV,
  pub handle: HANDLE,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportMemoryWin32HandleInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub pAttributes: *const n32_SECURITY_ATTRIBUTES,
  pub dwAccess: DWORD,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Win32KeyedMutexAcquireReleaseInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub acquireCount: u32,
  pub pAcquireSyncs: *const DeviceMemory,
  pub pAcquireKeys: *const u64,
  pub pAcquireTimeoutMilliseconds: *const u32,
  pub releaseCount: u32,
  pub pReleaseSyncs: *const DeviceMemory,
  pub pReleaseKeys: *const u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGeneratedCommandsFeaturesNVX {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub computeBindingPointSupport: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGeneratedCommandsLimitsNVX {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub maxIndirectCommandsLayoutTokenCount: u32,
  pub maxObjectEntryCounts: u32,
  pub minSequenceCountBufferOffsetAlignment: u32,
  pub minSequenceIndexBufferOffsetAlignment: u32,
  pub minCommandsTokenBufferOffsetAlignment: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndirectCommandsTokenNVX {
  pub tokenType: IndirectCommandsTokenTypeNVX,
  pub buffer: Buffer,
  pub offset: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndirectCommandsLayoutTokenNVX {
  pub tokenType: IndirectCommandsTokenTypeNVX,
  pub bindingUnit: u32,
  pub dynamicCount: u32,
  pub divisor: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndirectCommandsLayoutCreateInfoNVX {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub pipelineBindPoint: PipelineBindPoint,
  pub flags: IndirectCommandsLayoutUsageFlagsNVX,
  pub tokenCount: u32,
  pub pTokens: *const IndirectCommandsLayoutTokenNVX,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CmdProcessCommandsInfoNVX {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub objectTable: ObjectTableNVX,
  pub indirectCommandsLayout: IndirectCommandsLayoutNVX,
  pub indirectCommandsTokenCount: u32,
  pub pIndirectCommandsTokens: *const IndirectCommandsTokenNVX,
  pub maxSequencesCount: u32,
  pub targetCommandBuffer: CommandBuffer,
  pub sequencesCountBuffer: Buffer,
  pub sequencesCountOffset: DeviceSize,
  pub sequencesIndexBuffer: Buffer,
  pub sequencesIndexOffset: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CmdReserveSpaceForCommandsInfoNVX {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub objectTable: ObjectTableNVX,
  pub indirectCommandsLayout: IndirectCommandsLayoutNVX,
  pub maxSequencesCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectTableCreateInfoNVX {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub objectCount: u32,
  pub pObjectEntryTypes: *const ObjectEntryTypeNVX,
  pub pObjectEntryCounts: *const u32,
  pub pObjectEntryUsageFlags: *const ObjectEntryUsageFlagsNVX,
  pub maxUniformBuffersPerDescriptor: u32,
  pub maxStorageBuffersPerDescriptor: u32,
  pub maxStorageImagesPerDescriptor: u32,
  pub maxSampledImagesPerDescriptor: u32,
  pub maxPipelineLayouts: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectTableEntryNVX {
  pub typ: ObjectEntryTypeNVX,
  pub flags: ObjectEntryUsageFlagsNVX,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectTablePipelineEntryNVX {
  pub typ: ObjectEntryTypeNVX,
  pub flags: ObjectEntryUsageFlagsNVX,
  pub pipeline: Pipeline,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectTableDescriptorSetEntryNVX {
  pub typ: ObjectEntryTypeNVX,
  pub flags: ObjectEntryUsageFlagsNVX,
  pub pipelineLayout: PipelineLayout,
  pub descriptorSet: DescriptorSet,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectTableVertexBufferEntryNVX {
  pub typ: ObjectEntryTypeNVX,
  pub flags: ObjectEntryUsageFlagsNVX,
  pub buffer: Buffer,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectTableIndexBufferEntryNVX {
  pub typ: ObjectEntryTypeNVX,
  pub flags: ObjectEntryUsageFlagsNVX,
  pub buffer: Buffer,
  pub indexType: IndexType,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectTablePushConstantEntryNVX {
  pub typ: ObjectEntryTypeNVX,
  pub flags: ObjectEntryUsageFlagsNVX,
  pub pipelineLayout: PipelineLayout,
  pub stageFlags: ShaderStageFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceFeatures2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub features: PhysicalDeviceFeatures,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceProperties2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub properties: PhysicalDeviceProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormatProperties2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub formatProperties: FormatProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageFormatProperties2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub imageFormatProperties: ImageFormatProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceImageFormatInfo2 {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub format: Format,
  pub typ: ImageType,
  pub tiling: ImageTiling,
  pub usage: ImageUsageFlags,
  pub flags: ImageCreateFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueFamilyProperties2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub queueFamilyProperties: QueueFamilyProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMemoryProperties2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub memoryProperties: PhysicalDeviceMemoryProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseImageFormatProperties2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub properties: SparseImageFormatProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceSparseImageFormatInfo2 {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub format: Format,
  pub typ: ImageType,
  pub samples: SampleCountFlagBits,
  pub usage: ImageUsageFlags,
  pub tiling: ImageTiling,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDevicePushDescriptorPropertiesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxPushDescriptors: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConformanceVersionKHR {
  pub major: u8,
  pub minor: u8,
  pub subminor: u8,
  pub patch: u8,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceDriverPropertiesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub driverID: DriverIdKHR,
  pub driverName: [c_char; MAX_DRIVER_NAME_SIZE_KHR as usize],
  pub driverInfo: [c_char; MAX_DRIVER_INFO_SIZE_KHR as usize],
  pub conformanceVersion: ConformanceVersionKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PresentRegionsKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub swapchainCount: u32,
  pub pRegions: *const PresentRegionKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PresentRegionKHR {
  pub rectangleCount: u32,
  pub pRectangles: *const RectLayerKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RectLayerKHR {
  pub offset: Offset2D,
  pub extent: Extent2D,
  pub layer: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceVariablePointerFeatures {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub variablePointersStorageBuffer: Bool32,
  pub variablePointers: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalMemoryProperties {
  pub externalMemoryFeatures: ExternalMemoryFeatureFlags,
  pub exportFromImportedHandleTypes: ExternalMemoryHandleTypeFlags,
  pub compatibleHandleTypes: ExternalMemoryHandleTypeFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceExternalImageFormatInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleType: ExternalMemoryHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalImageFormatProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub externalMemoryProperties: ExternalMemoryProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceExternalBufferInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: BufferCreateFlags,
  pub usage: BufferUsageFlags,
  pub handleType: ExternalMemoryHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalBufferProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub externalMemoryProperties: ExternalMemoryProperties,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceIDProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub deviceUUID: [u8; UUID_SIZE as usize],
  pub driverUUID: [u8; UUID_SIZE as usize],
  pub deviceLUID: [u8; LUID_SIZE as usize],
  pub deviceNodeMask: u32,
  pub deviceLUIDValid: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalMemoryImageCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleTypes: ExternalMemoryHandleTypeFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalMemoryBufferCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleTypes: ExternalMemoryHandleTypeFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportMemoryAllocateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleTypes: ExternalMemoryHandleTypeFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportMemoryWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleType: ExternalMemoryHandleTypeFlagBits,
  pub handle: HANDLE,
  pub name: LPCWSTR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportMemoryWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub pAttributes: *const n32_SECURITY_ATTRIBUTES,
  pub dwAccess: DWORD,
  pub name: LPCWSTR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryWin32HandlePropertiesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub memoryTypeBits: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryGetWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub memory: DeviceMemory,
  pub handleType: ExternalMemoryHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportMemoryFdInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleType: ExternalMemoryHandleTypeFlagBits,
  pub fd: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryFdPropertiesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub memoryTypeBits: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryGetFdInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub memory: DeviceMemory,
  pub handleType: ExternalMemoryHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Win32KeyedMutexAcquireReleaseInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub acquireCount: u32,
  pub pAcquireSyncs: *const DeviceMemory,
  pub pAcquireKeys: *const u64,
  pub pAcquireTimeouts: *const u32,
  pub releaseCount: u32,
  pub pReleaseSyncs: *const DeviceMemory,
  pub pReleaseKeys: *const u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceExternalSemaphoreInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleType: ExternalSemaphoreHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalSemaphoreProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub exportFromImportedHandleTypes: ExternalSemaphoreHandleTypeFlags,
  pub compatibleHandleTypes: ExternalSemaphoreHandleTypeFlags,
  pub externalSemaphoreFeatures: ExternalSemaphoreFeatureFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportSemaphoreCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleTypes: ExternalSemaphoreHandleTypeFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportSemaphoreWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub semaphore: Semaphore,
  pub flags: SemaphoreImportFlags,
  pub handleType: ExternalSemaphoreHandleTypeFlagBits,
  pub handle: HANDLE,
  pub name: LPCWSTR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportSemaphoreWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub pAttributes: *const n32_SECURITY_ATTRIBUTES,
  pub dwAccess: DWORD,
  pub name: LPCWSTR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct D3D12FenceSubmitInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub waitSemaphoreValuesCount: u32,
  pub pWaitSemaphoreValues: *const u64,
  pub signalSemaphoreValuesCount: u32,
  pub pSignalSemaphoreValues: *const u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SemaphoreGetWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub semaphore: Semaphore,
  pub handleType: ExternalSemaphoreHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportSemaphoreFdInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub semaphore: Semaphore,
  pub flags: SemaphoreImportFlags,
  pub handleType: ExternalSemaphoreHandleTypeFlagBits,
  pub fd: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SemaphoreGetFdInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub semaphore: Semaphore,
  pub handleType: ExternalSemaphoreHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceExternalFenceInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleType: ExternalFenceHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalFenceProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub exportFromImportedHandleTypes: ExternalFenceHandleTypeFlags,
  pub compatibleHandleTypes: ExternalFenceHandleTypeFlags,
  pub externalFenceFeatures: ExternalFenceFeatureFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportFenceCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleTypes: ExternalFenceHandleTypeFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportFenceWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub fence: Fence,
  pub flags: FenceImportFlags,
  pub handleType: ExternalFenceHandleTypeFlagBits,
  pub handle: HANDLE,
  pub name: LPCWSTR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportFenceWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub pAttributes: *const n32_SECURITY_ATTRIBUTES,
  pub dwAccess: DWORD,
  pub name: LPCWSTR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FenceGetWin32HandleInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub fence: Fence,
  pub handleType: ExternalFenceHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportFenceFdInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub fence: Fence,
  pub flags: FenceImportFlags,
  pub handleType: ExternalFenceHandleTypeFlagBits,
  pub fd: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FenceGetFdInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub fence: Fence,
  pub handleType: ExternalFenceHandleTypeFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceMultiviewFeatures {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub multiview: Bool32,
  pub multiviewGeometryShader: Bool32,
  pub multiviewTessellationShader: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceMultiviewProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxMultiviewViewCount: u32,
  pub maxMultiviewInstanceIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderPassMultiviewCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub subpassCount: u32,
  pub pViewMasks: *const u32,
  pub dependencyCount: u32,
  pub pViewOffsets: *const i32,
  pub correlationMaskCount: u32,
  pub pCorrelationMasks: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SurfaceCapabilities2EXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub minImageCount: u32,
  pub maxImageCount: u32,
  pub currentExtent: Extent2D,
  pub minImageExtent: Extent2D,
  pub maxImageExtent: Extent2D,
  pub maxImageArrayLayers: u32,
  pub supportedTransforms: SurfaceTransformFlagsKHR,
  pub currentTransform: SurfaceTransformFlagBitsKHR,
  pub supportedCompositeAlpha: CompositeAlphaFlagsKHR,
  pub supportedUsageFlags: ImageUsageFlags,
  pub supportedSurfaceCounters: SurfaceCounterFlagsEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayPowerInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub powerState: DisplayPowerStateEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceEventInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub deviceEvent: DeviceEventTypeEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayEventInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub displayEvent: DisplayEventTypeEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwapchainCounterCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub surfaceCounters: SurfaceCounterFlagsEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceGroupProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub physicalDeviceCount: u32,
  pub physicalDevices: [PhysicalDevice; MAX_DEVICE_GROUP_SIZE as usize],
  pub subsetAllocation: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryAllocateFlagsInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: MemoryAllocateFlags,
  pub deviceMask: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindBufferMemoryInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub buffer: Buffer,
  pub memory: DeviceMemory,
  pub memoryOffset: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindBufferMemoryDeviceGroupInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub deviceIndexCount: u32,
  pub pDeviceIndices: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindImageMemoryInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub image: Image,
  pub memory: DeviceMemory,
  pub memoryOffset: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindImageMemoryDeviceGroupInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub deviceIndexCount: u32,
  pub pDeviceIndices: *const u32,
  pub splitInstanceBindRegionCount: u32,
  pub pSplitInstanceBindRegions: *const Rect2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGroupRenderPassBeginInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub deviceMask: u32,
  pub deviceRenderAreaCount: u32,
  pub pDeviceRenderAreas: *const Rect2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGroupCommandBufferBeginInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub deviceMask: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGroupSubmitInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub waitSemaphoreCount: u32,
  pub pWaitSemaphoreDeviceIndices: *const u32,
  pub commandBufferCount: u32,
  pub pCommandBufferDeviceMasks: *const u32,
  pub signalSemaphoreCount: u32,
  pub pSignalSemaphoreDeviceIndices: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGroupBindSparseInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub resourceDeviceIndex: u32,
  pub memoryDeviceIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceGroupPresentCapabilitiesKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub presentMask: [u32; MAX_DEVICE_GROUP_SIZE as usize],
  pub modes: DeviceGroupPresentModeFlagsKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageSwapchainCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub swapchain: SwapchainKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindImageMemorySwapchainInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub swapchain: SwapchainKHR,
  pub imageIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AcquireNextImageInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub swapchain: SwapchainKHR,
  pub timeout: u64,
  pub semaphore: Semaphore,
  pub fence: Fence,
  pub deviceMask: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGroupPresentInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub swapchainCount: u32,
  pub pDeviceMasks: *const u32,
  pub mode: DeviceGroupPresentModeFlagBitsKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGroupDeviceCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub physicalDeviceCount: u32,
  pub pPhysicalDevices: *const PhysicalDevice,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceGroupSwapchainCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub modes: DeviceGroupPresentModeFlagsKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorUpdateTemplateEntry {
  pub dstBinding: u32,
  pub dstArrayElement: u32,
  pub descriptorCount: u32,
  pub descriptorType: DescriptorType,
  pub offset: usize,
  pub stride: usize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorUpdateTemplateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DescriptorUpdateTemplateCreateFlags,
  pub descriptorUpdateEntryCount: u32,
  pub pDescriptorUpdateEntries: *const DescriptorUpdateTemplateEntry,
  pub templateType: DescriptorUpdateTemplateType,
  pub descriptorSetLayout: DescriptorSetLayout,
  pub pipelineBindPoint: PipelineBindPoint,
  pub pipelineLayout: PipelineLayout,
  pub set: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XYColorEXT {
  pub x: f32,
  pub y: f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdrMetadataEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub displayPrimaryRed: XYColorEXT,
  pub displayPrimaryGreen: XYColorEXT,
  pub displayPrimaryBlue: XYColorEXT,
  pub whitePoint: XYColorEXT,
  pub maxLuminance: f32,
  pub minLuminance: f32,
  pub maxContentLightLevel: f32,
  pub maxFrameAverageLightLevel: f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefreshCycleDurationGOOGLE {
  pub refreshDuration: u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PastPresentationTimingGOOGLE {
  pub presentID: u32,
  pub desiredPresentTime: u64,
  pub actualPresentTime: u64,
  pub earliestPresentTime: u64,
  pub presentMargin: u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PresentTimesInfoGOOGLE {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub swapchainCount: u32,
  pub pTimes: *const PresentTimeGOOGLE,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PresentTimeGOOGLE {
  pub presentID: u32,
  pub desiredPresentTime: u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOSSurfaceCreateInfoMVK {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: IOSSurfaceCreateFlagsMVK,
  pub pView: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MacOSSurfaceCreateInfoMVK {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: MacOSSurfaceCreateFlagsMVK,
  pub pView: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewportWScalingNV {
  pub xcoeff: f32,
  pub ycoeff: f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineViewportWScalingStateCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub viewportWScalingEnable: Bool32,
  pub viewportCount: u32,
  pub pViewportWScalings: *const ViewportWScalingNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewportSwizzleNV {
  pub x: ViewportCoordinateSwizzleNV,
  pub y: ViewportCoordinateSwizzleNV,
  pub z: ViewportCoordinateSwizzleNV,
  pub w: ViewportCoordinateSwizzleNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineViewportSwizzleStateCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineViewportSwizzleStateCreateFlagsNV,
  pub viewportCount: u32,
  pub pViewportSwizzles: *const ViewportSwizzleNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceDiscardRectanglePropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxDiscardRectangles: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDiscardRectangleStateCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineDiscardRectangleStateCreateFlagsEXT,
  pub discardRectangleMode: DiscardRectangleModeEXT,
  pub discardRectangleCount: u32,
  pub pDiscardRectangles: *const Rect2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub perViewPositionAllComponents: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputAttachmentAspectReference {
  pub subpass: u32,
  pub inputAttachmentIndex: u32,
  pub aspectMask: ImageAspectFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderPassInputAttachmentAspectCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub aspectReferenceCount: u32,
  pub pAspectReferences: *const InputAttachmentAspectReference,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceSurfaceInfo2KHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub surface: SurfaceKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SurfaceCapabilities2KHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub surfaceCapabilities: SurfaceCapabilitiesKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SurfaceFormat2KHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub surfaceFormat: SurfaceFormatKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayProperties2KHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub displayProperties: DisplayPropertiesKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayPlaneProperties2KHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub displayPlaneProperties: DisplayPlanePropertiesKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayModeProperties2KHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub displayModeProperties: DisplayModePropertiesKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayPlaneInfo2KHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub mode: DisplayModeKHR,
  pub planeIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayPlaneCapabilities2KHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub capabilities: DisplayPlaneCapabilitiesKHR,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedPresentSurfaceCapabilitiesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub sharedPresentSupportedUsageFlags: ImageUsageFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDevice16BitStorageFeatures {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub storageBuffer16BitAccess: Bool32,
  pub uniformAndStorageBuffer16BitAccess: Bool32,
  pub storagePushConstant16: Bool32,
  pub storageInputOutput16: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceSubgroupProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub subgroupSize: u32,
  pub supportedStages: ShaderStageFlags,
  pub supportedOperations: SubgroupFeatureFlags,
  pub quadOperationsInAllStages: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferMemoryRequirementsInfo2 {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub buffer: Buffer,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageMemoryRequirementsInfo2 {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub image: Image,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageSparseMemoryRequirementsInfo2 {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub image: Image,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRequirements2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub memoryRequirements: MemoryRequirements,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SparseImageMemoryRequirements2 {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub memoryRequirements: SparseImageMemoryRequirements,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDevicePointClippingProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub pointClippingBehavior: PointClippingBehavior,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryDedicatedRequirements {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub prefersDedicatedAllocation: Bool32,
  pub requiresDedicatedAllocation: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryDedicatedAllocateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub image: Image,
  pub buffer: Buffer,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageViewUsageCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub usage: ImageUsageFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineTessellationDomainOriginStateCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub domainOrigin: TessellationDomainOrigin,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerYcbcrConversionInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub conversion: SamplerYcbcrConversion,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerYcbcrConversionCreateInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub format: Format,
  pub ycbcrModel: SamplerYcbcrModelConversion,
  pub ycbcrRange: SamplerYcbcrRange,
  pub components: ComponentMapping,
  pub xChromaOffset: ChromaLocation,
  pub yChromaOffset: ChromaLocation,
  pub chromaFilter: Filter,
  pub forceExplicitReconstruction: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindImagePlaneMemoryInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub planeAspect: ImageAspectFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImagePlaneMemoryRequirementsInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub planeAspect: ImageAspectFlagBits,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceSamplerYcbcrConversionFeatures {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub samplerYcbcrConversion: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerYcbcrConversionImageFormatProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub combinedImageSamplerDescriptorCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextureLODGatherFormatPropertiesAMD {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub supportsTextureGatherLODBiasAMD: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConditionalRenderingBeginInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub buffer: Buffer,
  pub offset: DeviceSize,
  pub flags: ConditionalRenderingFlagsEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtectedSubmitInfo {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub protectedSubmit: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceProtectedMemoryFeatures {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub protectedMemory: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceProtectedMemoryProperties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub protectedNoFault: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceQueueInfo2 {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DeviceQueueCreateFlags,
  pub queueFamilyIndex: u32,
  pub queueIndex: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineCoverageToColorStateCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineCoverageToColorStateCreateFlagsNV,
  pub coverageToColorEnable: Bool32,
  pub coverageToColorLocation: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub filterMinmaxSingleComponentFormats: Bool32,
  pub filterMinmaxImageComponentMapping: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleLocationEXT {
  pub x: f32,
  pub y: f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleLocationsInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub sampleLocationsPerPixel: SampleCountFlagBits,
  pub sampleLocationGridSize: Extent2D,
  pub sampleLocationsCount: u32,
  pub pSampleLocations: *const SampleLocationEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttachmentSampleLocationsEXT {
  pub attachmentIndex: u32,
  pub sampleLocationsInfo: SampleLocationsInfoEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubpassSampleLocationsEXT {
  pub subpassIndex: u32,
  pub sampleLocationsInfo: SampleLocationsInfoEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderPassSampleLocationsBeginInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub attachmentInitialSampleLocationsCount: u32,
  pub pAttachmentInitialSampleLocations: *const AttachmentSampleLocationsEXT,
  pub postSubpassSampleLocationsCount: u32,
  pub pPostSubpassSampleLocations: *const SubpassSampleLocationsEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineSampleLocationsStateCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub sampleLocationsEnable: Bool32,
  pub sampleLocationsInfo: SampleLocationsInfoEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceSampleLocationsPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub sampleLocationSampleCounts: SampleCountFlags,
  pub maxSampleLocationGridSize: Extent2D,
  pub sampleLocationCoordinateRange: [f32; 2],
  pub sampleLocationSubPixelBits: u32,
  pub variableSampleLocations: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MultisamplePropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxSampleLocationGridSize: Extent2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerReductionModeCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub reductionMode: SamplerReductionModeEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub advancedBlendCoherentOperations: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub advancedBlendMaxColorAttachments: u32,
  pub advancedBlendIndependentBlend: Bool32,
  pub advancedBlendNonPremultipliedSrcColor: Bool32,
  pub advancedBlendNonPremultipliedDstColor: Bool32,
  pub advancedBlendCorrelatedOverlap: Bool32,
  pub advancedBlendAllOperations: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineColorBlendAdvancedStateCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub srcPremultiplied: Bool32,
  pub dstPremultiplied: Bool32,
  pub blendOverlap: BlendOverlapEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceInlineUniformBlockFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub inlineUniformBlock: Bool32,
  pub descriptorBindingInlineUniformBlockUpdateAfterBind: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceInlineUniformBlockPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxInlineUniformBlockSize: u32,
  pub maxPerStageDescriptorInlineUniformBlocks: u32,
  pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
  pub maxDescriptorSetInlineUniformBlocks: u32,
  pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WriteDescriptorSetInlineUniformBlockEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub dataSize: u32,
  pub pData: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorPoolInlineUniformBlockCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub maxInlineUniformBlockBindings: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineCoverageModulationStateCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineCoverageModulationStateCreateFlagsNV,
  pub coverageModulationMode: CoverageModulationModeNV,
  pub coverageModulationTableEnable: Bool32,
  pub coverageModulationTableCount: u32,
  pub pCoverageModulationTable: *const f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageFormatListCreateInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub viewFormatCount: u32,
  pub pViewFormats: *const Format,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidationCacheCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: ValidationCacheCreateFlagsEXT,
  pub initialDataSize: usize,
  pub pInitialData: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderModuleValidationCacheCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub validationCache: ValidationCacheEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceMaintenance3Properties {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxPerSetDescriptors: u32,
  pub maxMemoryAllocationSize: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSetLayoutSupport {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub supported: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceShaderDrawParameterFeatures {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub shaderDrawParameters: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceFloat16Int8FeaturesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub shaderFloat16: Bool32,
  pub shaderInt8: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceFloatControlsPropertiesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub separateDenormSettings: Bool32,
  pub separateRoundingModeSettings: Bool32,
  pub shaderSignedZeroInfNanPreserveFloat16: Bool32,
  pub shaderSignedZeroInfNanPreserveFloat32: Bool32,
  pub shaderSignedZeroInfNanPreserveFloat64: Bool32,
  pub shaderDenormPreserveFloat16: Bool32,
  pub shaderDenormPreserveFloat32: Bool32,
  pub shaderDenormPreserveFloat64: Bool32,
  pub shaderDenormFlushToZeroFloat16: Bool32,
  pub shaderDenormFlushToZeroFloat32: Bool32,
  pub shaderDenormFlushToZeroFloat64: Bool32,
  pub shaderRoundingModeRTEFloat16: Bool32,
  pub shaderRoundingModeRTEFloat32: Bool32,
  pub shaderRoundingModeRTEFloat64: Bool32,
  pub shaderRoundingModeRTZFloat16: Bool32,
  pub shaderRoundingModeRTZFloat32: Bool32,
  pub shaderRoundingModeRTZFloat64: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderResourceUsageAMD {
  pub numUsedVgprs: u32,
  pub numUsedSgprs: u32,
  pub ldsSizePerLocalWorkGroup: u32,
  pub ldsUsageSizeInBytes: usize,
  pub scratchMemUsageInBytes: usize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ShaderStatisticsInfoAMD {
  pub shaderStageMask: ShaderStageFlags,
  pub resourceUsage: ShaderResourceUsageAMD,
  pub numPhysicalVgprs: u32,
  pub numPhysicalSgprs: u32,
  pub numAvailableVgprs: u32,
  pub numAvailableSgprs: u32,
  pub computeWorkGroupSize: [u32; 3],
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceQueueGlobalPriorityCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub globalPriority: QueueGlobalPriorityEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DebugUtilsObjectNameInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub objectType: ObjectType,
  pub objectHandle: u64,
  pub pObjectName: *const c_char,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DebugUtilsObjectTagInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub objectType: ObjectType,
  pub objectHandle: u64,
  pub tagName: u64,
  pub tagSize: usize,
  pub pTag: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsLabelEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub pLabelName: *const c_char,
  pub color: [f32; 4],
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsMessengerCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DebugUtilsMessengerCreateFlagsEXT,
  pub messageSeverity: DebugUtilsMessageSeverityFlagsEXT,
  pub messageType: DebugUtilsMessageTypeFlagsEXT,
  pub pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT,
  pub pUserData: *mut c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugUtilsMessengerCallbackDataEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: DebugUtilsMessengerCallbackDataFlagsEXT,
  pub pMessageIdName: *const c_char,
  pub messageIdNumber: i32,
  pub pMessage: *const c_char,
  pub queueLabelCount: u32,
  pub pQueueLabels: *const DebugUtilsLabelEXT,
  pub cmdBufLabelCount: u32,
  pub pCmdBufLabels: *const DebugUtilsLabelEXT,
  pub objectCount: u32,
  pub pObjects: *const DebugUtilsObjectNameInfoEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportMemoryHostPointerInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub handleType: ExternalMemoryHandleTypeFlagBits,
  pub pHostPointer: *mut c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryHostPointerPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub memoryTypeBits: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceExternalMemoryHostPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub minImportedHostPointerAlignment: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceConservativeRasterizationPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub primitiveOverestimationSize: f32,
  pub maxExtraPrimitiveOverestimationSize: f32,
  pub extraPrimitiveOverestimationSizeGranularity: f32,
  pub primitiveUnderestimation: Bool32,
  pub conservativePointAndLineRasterization: Bool32,
  pub degenerateTrianglesRasterized: Bool32,
  pub degenerateLinesRasterized: Bool32,
  pub fullyCoveredFragmentShaderInputVariable: Bool32,
  pub conservativeRasterizationPostDepthCoverage: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CalibratedTimestampInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub timeDomain: TimeDomainEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceShaderCorePropertiesAMD {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub shaderEngineCount: u32,
  pub shaderArraysPerEngineCount: u32,
  pub computeUnitsPerShaderArray: u32,
  pub simdPerComputeUnit: u32,
  pub wavefrontsPerSimd: u32,
  pub wavefrontSize: u32,
  pub sgprsPerSimd: u32,
  pub minSgprAllocation: u32,
  pub maxSgprAllocation: u32,
  pub sgprAllocationGranularity: u32,
  pub vgprsPerSimd: u32,
  pub minVgprAllocation: u32,
  pub maxVgprAllocation: u32,
  pub vgprAllocationGranularity: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineRasterizationConservativeStateCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineRasterizationConservativeStateCreateFlagsEXT,
  pub conservativeRasterizationMode: ConservativeRasterizationModeEXT,
  pub extraPrimitiveOverestimationSize: f32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceDescriptorIndexingFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub shaderInputAttachmentArrayDynamicIndexing: Bool32,
  pub shaderUniformTexelBufferArrayDynamicIndexing: Bool32,
  pub shaderStorageTexelBufferArrayDynamicIndexing: Bool32,
  pub shaderUniformBufferArrayNonUniformIndexing: Bool32,
  pub shaderSampledImageArrayNonUniformIndexing: Bool32,
  pub shaderStorageBufferArrayNonUniformIndexing: Bool32,
  pub shaderStorageImageArrayNonUniformIndexing: Bool32,
  pub shaderInputAttachmentArrayNonUniformIndexing: Bool32,
  pub shaderUniformTexelBufferArrayNonUniformIndexing: Bool32,
  pub shaderStorageTexelBufferArrayNonUniformIndexing: Bool32,
  pub descriptorBindingUniformBufferUpdateAfterBind: Bool32,
  pub descriptorBindingSampledImageUpdateAfterBind: Bool32,
  pub descriptorBindingStorageImageUpdateAfterBind: Bool32,
  pub descriptorBindingStorageBufferUpdateAfterBind: Bool32,
  pub descriptorBindingUniformTexelBufferUpdateAfterBind: Bool32,
  pub descriptorBindingStorageTexelBufferUpdateAfterBind: Bool32,
  pub descriptorBindingUpdateUnusedWhilePending: Bool32,
  pub descriptorBindingPartiallyBound: Bool32,
  pub descriptorBindingVariableDescriptorCount: Bool32,
  pub runtimeDescriptorArray: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceDescriptorIndexingPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxUpdateAfterBindDescriptorsInAllPools: u32,
  pub shaderUniformBufferArrayNonUniformIndexingNative: Bool32,
  pub shaderSampledImageArrayNonUniformIndexingNative: Bool32,
  pub shaderStorageBufferArrayNonUniformIndexingNative: Bool32,
  pub shaderStorageImageArrayNonUniformIndexingNative: Bool32,
  pub shaderInputAttachmentArrayNonUniformIndexingNative: Bool32,
  pub robustBufferAccessUpdateAfterBind: Bool32,
  pub quadDivergentImplicitLod: Bool32,
  pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
  pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
  pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
  pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
  pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
  pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
  pub maxPerStageUpdateAfterBindResources: u32,
  pub maxDescriptorSetUpdateAfterBindSamplers: u32,
  pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
  pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
  pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
  pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
  pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
  pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
  pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSetLayoutBindingFlagsCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub bindingCount: u32,
  pub pBindingFlags: *const DescriptorBindingFlagsEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSetVariableDescriptorCountAllocateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub descriptorSetCount: u32,
  pub pDescriptorCounts: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DescriptorSetVariableDescriptorCountLayoutSupportEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxVariableDescriptorCount: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttachmentDescription2KHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: AttachmentDescriptionFlags,
  pub format: Format,
  pub samples: SampleCountFlagBits,
  pub loadOp: AttachmentLoadOp,
  pub storeOp: AttachmentStoreOp,
  pub stencilLoadOp: AttachmentLoadOp,
  pub stencilStoreOp: AttachmentStoreOp,
  pub initialLayout: ImageLayout,
  pub finalLayout: ImageLayout,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttachmentReference2KHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub attachment: u32,
  pub layout: ImageLayout,
  pub aspectMask: ImageAspectFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubpassDescription2KHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: SubpassDescriptionFlags,
  pub pipelineBindPoint: PipelineBindPoint,
  pub viewMask: u32,
  pub inputAttachmentCount: u32,
  pub pInputAttachments: *const AttachmentReference2KHR,
  pub colorAttachmentCount: u32,
  pub pColorAttachments: *const AttachmentReference2KHR,
  pub pResolveAttachments: *const AttachmentReference2KHR,
  pub pDepthStencilAttachment: *const AttachmentReference2KHR,
  pub preserveAttachmentCount: u32,
  pub pPreserveAttachments: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubpassDependency2KHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub srcSubpass: u32,
  pub dstSubpass: u32,
  pub srcStageMask: PipelineStageFlags,
  pub dstStageMask: PipelineStageFlags,
  pub srcAccessMask: AccessFlags,
  pub dstAccessMask: AccessFlags,
  pub dependencyFlags: DependencyFlags,
  pub viewOffset: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderPassCreateInfo2KHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: RenderPassCreateFlags,
  pub attachmentCount: u32,
  pub pAttachments: *const AttachmentDescription2KHR,
  pub subpassCount: u32,
  pub pSubpasses: *const SubpassDescription2KHR,
  pub dependencyCount: u32,
  pub pDependencies: *const SubpassDependency2KHR,
  pub correlatedViewMaskCount: u32,
  pub pCorrelatedViewMasks: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubpassBeginInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub contents: SubpassContents,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubpassEndInfoKHR {
  pub sType: StructureType,
  pub pNext: *const c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VertexInputBindingDivisorDescriptionEXT {
  pub binding: u32,
  pub divisor: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineVertexInputDivisorStateCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub vertexBindingDivisorCount: u32,
  pub pVertexBindingDivisors: *const VertexInputBindingDivisorDescriptionEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxVertexAttribDivisor: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDevicePCIBusInfoPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub pciDomain: u16,
  pub pciBus: u8,
  pub pciDevice: u8,
  pub pciFunction: u8,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportAndroidHardwareBufferInfoANDROID {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub buffer: *mut AHardwareBuffer,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AndroidHardwareBufferUsageANDROID {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub androidHardwareBufferUsage: u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AndroidHardwareBufferPropertiesANDROID {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub allocationSize: DeviceSize,
  pub memoryTypeBits: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryGetAndroidHardwareBufferInfoANDROID {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub memory: DeviceMemory,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AndroidHardwareBufferFormatPropertiesANDROID {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub format: Format,
  pub externalFormat: u64,
  pub formatFeatures: FormatFeatureFlags,
  pub samplerYcbcrConversionComponents: ComponentMapping,
  pub suggestedYcbcrModel: SamplerYcbcrModelConversion,
  pub suggestedYcbcrRange: SamplerYcbcrRange,
  pub suggestedXChromaOffset: ChromaLocation,
  pub suggestedYChromaOffset: ChromaLocation,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandBufferInheritanceConditionalRenderingInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub conditionalRenderingEnable: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalFormatANDROID {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub externalFormat: u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDevice8BitStorageFeaturesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub storageBuffer8BitAccess: Bool32,
  pub uniformAndStorageBuffer8BitAccess: Bool32,
  pub storagePushConstant8: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceConditionalRenderingFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub conditionalRendering: Bool32,
  pub inheritedConditionalRendering: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceVulkanMemoryModelFeaturesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub vulkanMemoryModel: Bool32,
  pub vulkanMemoryModelDeviceScope: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceShaderAtomicInt64FeaturesKHR {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub shaderBufferInt64Atomics: Bool32,
  pub shaderSharedInt64Atomics: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub vertexAttributeInstanceRateDivisor: Bool32,
  pub vertexAttributeInstanceRateZeroDivisor: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueFamilyCheckpointPropertiesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub checkpointExecutionStageMask: PipelineStageFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheckpointDataNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub stage: PipelineStageFlagBits,
  pub pCheckpointMarker: *mut c_void,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageViewASTCDecodeModeEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub decodeMode: Format,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceASTCDecodeFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub decodeModeSharedExponent: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceTransformFeedbackFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub transformFeedback: Bool32,
  pub geometryStreams: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceTransformFeedbackPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxTransformFeedbackStreams: u32,
  pub maxTransformFeedbackBuffers: u32,
  pub maxTransformFeedbackBufferSize: DeviceSize,
  pub maxTransformFeedbackStreamDataSize: u32,
  pub maxTransformFeedbackBufferDataSize: u32,
  pub maxTransformFeedbackBufferDataStride: u32,
  pub transformFeedbackQueries: Bool32,
  pub transformFeedbackStreamsLinesTriangles: Bool32,
  pub transformFeedbackRasterizationStreamSelect: Bool32,
  pub transformFeedbackDraw: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineRasterizationStateStreamCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineRasterizationStateStreamCreateFlagsEXT,
  pub rasterizationStream: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub representativeFragmentTest: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineRepresentativeFragmentTestStateCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub representativeFragmentTestEnable: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceExclusiveScissorFeaturesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub exclusiveScissor: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineViewportExclusiveScissorStateCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub exclusiveScissorCount: u32,
  pub pExclusiveScissors: *const Rect2D,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceCornerSampledImageFeaturesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub cornerSampledImage: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceComputeShaderDerivativesFeaturesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub computeDerivativeGroupQuads: Bool32,
  pub computeDerivativeGroupLinear: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub fragmentShaderBarycentric: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceShaderImageFootprintFeaturesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub imageFootprint: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShadingRatePaletteNV {
  pub shadingRatePaletteEntryCount: u32,
  pub pShadingRatePaletteEntries: *const ShadingRatePaletteEntryNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineViewportShadingRateImageStateCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub shadingRateImageEnable: Bool32,
  pub viewportCount: u32,
  pub pShadingRatePalettes: *const ShadingRatePaletteNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceShadingRateImageFeaturesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub shadingRateImage: Bool32,
  pub shadingRateCoarseSampleOrder: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceShadingRateImagePropertiesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub shadingRateTexelSize: Extent2D,
  pub shadingRatePaletteSize: u32,
  pub shadingRateMaxCoarseSamples: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoarseSampleLocationNV {
  pub pixelX: u32,
  pub pixelY: u32,
  pub sample: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoarseSampleOrderCustomNV {
  pub shadingRate: ShadingRatePaletteEntryNV,
  pub sampleCount: u32,
  pub sampleLocationCount: u32,
  pub pSampleLocations: *const CoarseSampleLocationNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineViewportCoarseSampleOrderStateCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub sampleOrderType: CoarseSampleOrderTypeNV,
  pub customSampleOrderCount: u32,
  pub pCustomSampleOrders: *const CoarseSampleOrderCustomNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceMeshShaderFeaturesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub taskShader: Bool32,
  pub meshShader: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhysicalDeviceMeshShaderPropertiesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub maxDrawMeshTasksCount: u32,
  pub maxTaskWorkGroupInvocations: u32,
  pub maxTaskWorkGroupSize: [u32; 3],
  pub maxTaskTotalMemorySize: u32,
  pub maxTaskOutputCount: u32,
  pub maxMeshWorkGroupInvocations: u32,
  pub maxMeshWorkGroupSize: [u32; 3],
  pub maxMeshTotalMemorySize: u32,
  pub maxMeshOutputVertices: u32,
  pub maxMeshOutputPrimitives: u32,
  pub maxMeshMultiviewViewCount: u32,
  pub meshOutputPerVertexGranularity: u32,
  pub meshOutputPerPrimitiveGranularity: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DrawMeshTasksIndirectCommandNV {
  pub taskCount: u32,
  pub firstTask: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingShaderGroupCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub typ: RayTracingShaderGroupTypeNV,
  pub generalShader: u32,
  pub closestHitShader: u32,
  pub anyHitShader: u32,
  pub intersectionShader: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingPipelineCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub flags: PipelineCreateFlags,
  pub stageCount: u32,
  pub pStages: *const PipelineShaderStageCreateInfo,
  pub groupCount: u32,
  pub pGroups: *const RayTracingShaderGroupCreateInfoNV,
  pub maxRecursionDepth: u32,
  pub layout: PipelineLayout,
  pub basePipelineHandle: Pipeline,
  pub basePipelineIndex: i32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeometryTrianglesNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub vertexData: Buffer,
  pub vertexOffset: DeviceSize,
  pub vertexCount: u32,
  pub vertexStride: DeviceSize,
  pub vertexFormat: Format,
  pub indexData: Buffer,
  pub indexOffset: DeviceSize,
  pub indexCount: u32,
  pub indexType: IndexType,
  pub transformData: Buffer,
  pub transformOffset: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeometryAABBNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub aabbData: Buffer,
  pub numAABBs: u32,
  pub stride: u32,
  pub offset: DeviceSize,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeometryDataNV {
  pub triangles: GeometryTrianglesNV,
  pub aabbs: GeometryAABBNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeometryNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub geometryType: GeometryTypeNV,
  pub geometry: GeometryDataNV,
  pub flags: GeometryFlagsNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelerationStructureInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub typ: AccelerationStructureTypeNV,
  pub flags: BuildAccelerationStructureFlagsNV,
  pub instanceCount: u32,
  pub geometryCount: u32,
  pub pGeometries: *const GeometryNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelerationStructureCreateInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub compactedSize: DeviceSize,
  pub info: AccelerationStructureInfoNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindAccelerationStructureMemoryInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub accelerationStructure: AccelerationStructureNV,
  pub memory: DeviceMemory,
  pub memoryOffset: DeviceSize,
  pub deviceIndexCount: u32,
  pub pDeviceIndices: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WriteDescriptorSetAccelerationStructureNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub accelerationStructureCount: u32,
  pub pAccelerationStructures: *const AccelerationStructureNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelerationStructureMemoryRequirementsInfoNV {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub typ: AccelerationStructureMemoryRequirementsTypeNV,
  pub accelerationStructure: AccelerationStructureNV,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceRayTracingPropertiesNV {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub shaderGroupHandleSize: u32,
  pub maxRecursionDepth: u32,
  pub maxShaderGroupStride: u32,
  pub shaderGroupBaseAlignment: u32,
  pub maxGeometryCount: u64,
  pub maxInstanceCount: u64,
  pub maxTriangleCount: u64,
  pub maxDescriptorSetAccelerationStructures: u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DrmFormatModifierPropertiesListEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub drmFormatModifierCount: u32,
  pub pDrmFormatModifierProperties: *mut DrmFormatModifierPropertiesEXT,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DrmFormatModifierPropertiesEXT {
  pub drmFormatModifier: u64,
  pub drmFormatModifierPlaneCount: u32,
  pub drmFormatModifierTilingFeatures: FormatFeatureFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceImageDrmFormatModifierInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub drmFormatModifier: u64,
  pub sharingMode: SharingMode,
  pub queueFamilyIndexCount: u32,
  pub pQueueFamilyIndices: *const u32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageDrmFormatModifierListCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub drmFormatModifierCount: u32,
  pub pDrmFormatModifiers: *const u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageDrmFormatModifierExplicitCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub drmFormatModifier: u64,
  pub drmFormatModifierPlaneCount: u32,
  pub pPlaneLayouts: *const SubresourceLayout,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageDrmFormatModifierPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub drmFormatModifier: u64,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageStencilUsageCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub stencilUsage: ImageUsageFlags,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceMemoryOverallocationCreateInfoAMD {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub overallocationBehavior: MemoryOverallocationBehaviorAMD,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMapFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub fragmentDensityMap: Bool32,
  pub fragmentDensityMapDynamic: Bool32,
  pub fragmentDensityMapNonSubsampledImages: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceFragmentDensityMapPropertiesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub minFragmentDensityTexelSize: Extent2D,
  pub maxFragmentDensityTexelSize: Extent2D,
  pub fragmentDensityInvocations: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderPassFragmentDensityMapCreateInfoEXT {
  pub sType: StructureType,
  pub pNext: *const c_void,
  pub fragmentDensityMapAttachment: AttachmentReference,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalDeviceScalarBlockLayoutFeaturesEXT {
  pub sType: StructureType,
  pub pNext: *mut c_void,
  pub scalarBlockLayout: Bool32,
}
#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct n32_SECURITY_ATTRIBUTES {
  pub nLenght: DWORD,
  pub lpSecurityDescriptor: LPVOID,
  pub bInheritHandle: BOOL,
}


#[doc(hidden)] pub type Display = c_void;
#[doc(hidden)] pub type Window = c_ulong;
#[doc(hidden)] pub type RROutput = c_ulong;
#[doc(hidden)] pub type VisualID = u32;
#[doc(hidden)] pub type xcb_connection_t = c_void;
#[doc(hidden)] pub type xcb_window_t = u32;
#[doc(hidden)] pub type xcb_visualid_t = u32;
#[doc(hidden)] pub type wl_display = c_void;
#[doc(hidden)] pub type wl_surface = c_void;
#[doc(hidden)] pub type HINSTANCE = *mut c_void;
#[doc(hidden)] pub type HWND = *mut c_void;
#[doc(hidden)] pub type HANDLE = *mut c_void;
#[doc(hidden)] pub type DWORD = c_ulong;
#[doc(hidden)] pub type LPVOID = *mut c_void;
#[doc(hidden)] pub type BOOL = i32;
#[doc(hidden)] pub type LPCWSTR = *mut c_ushort;
#[doc(hidden)] pub type ANativeWindow = c_void;
#[doc(hidden)] pub type AHardwareBuffer = c_void;
#[doc(hidden)] pub type zx_handle_t = u32;


/// Create a version number from a major, minor and patch as it is defined in
/// [vulkan version numbers and semantics](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#fundamentals-versionnum)
/// 
/// May be used to set the `applicationVersion`, `pEngineName` and `apiVersion` fields in [ApplicationInfo](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkApplicationInfo.htm)
#[macro_export]
macro_rules! make_version {
  ($major:expr, $minor:expr, $patch:expr) => ((($major) << 22) | (($minor) << 12) | ($patch))
}
/// Extract major number from version, created with [make_version](macro.make_version.html) or retrieved from vulkan
#[macro_export]
macro_rules! version_major {
  ($ver:expr) => ($ver >> 22)
}
/// Extract minor number from version, created with [make_version](macro.make_version.html) or retrieved from vulkan
#[macro_export]
macro_rules! version_minor {
  ($ver:expr) => (($ver >> 12) & 0x3ff)
}
/// Extract patch number from version, created with [make_version](macro.make_version.html) or retrieved from vulkan
#[macro_export]
macro_rules! version_patch {
  ($ver:expr) => ($ver & 0xfff)
}
pub const VERSION_1_0: u32 = make_version!(1, 0, 0);
pub const VERSION_1_1: u32 = make_version!(1, 1, 0);


/// Vulkan core commands
///
/// This struct is used to initialize vulkan core commands and holds function pointers to them.
/// Function pointers are initialized during construction.
///
/// After successfull instantiation the global core functions are ready to use.
/// There must be always at maximum a single instance of this struct.
pub struct Core {
  #[allow(dead_code)]
  lib: shared_library::dynamic_library::DynamicLibrary,
  feature: u32,
  CreateInstance_ptr: extern "system" fn (pCreateInfo: *const InstanceCreateInfo, pAllocator: *const AllocationCallbacks, pInstance: *mut Instance) -> Result,
  DestroyInstance_ptr: extern "system" fn (instance: Instance, pAllocator: *const AllocationCallbacks),
  EnumeratePhysicalDevices_ptr: extern "system" fn (instance: Instance, pPhysicalDeviceCount: *mut u32, pPhysicalDevices: *mut PhysicalDevice) -> Result,
  GetPhysicalDeviceFeatures_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pFeatures: *mut PhysicalDeviceFeatures),
  GetPhysicalDeviceFormatProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *mut FormatProperties),
  GetPhysicalDeviceImageFormatProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, format: Format, typ: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, pImageFormatProperties: *mut ImageFormatProperties) -> Result,
  GetPhysicalDeviceProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pProperties: *mut PhysicalDeviceProperties),
  GetPhysicalDeviceQueueFamilyProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut QueueFamilyProperties),
  GetPhysicalDeviceMemoryProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pMemoryProperties: *mut PhysicalDeviceMemoryProperties),
  GetInstanceProcAddr_ptr: extern "system" fn (instance: Instance, pName: *const c_char) -> PFN_vkVoidFunction,
  GetDeviceProcAddr_ptr: extern "system" fn (device: Device, pName: *const c_char) -> PFN_vkVoidFunction,
  CreateDevice_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pCreateInfo: *const DeviceCreateInfo, pAllocator: *const AllocationCallbacks, pDevice: *mut Device) -> Result,
  DestroyDevice_ptr: extern "system" fn (device: Device, pAllocator: *const AllocationCallbacks),
  EnumerateInstanceExtensionProperties_ptr: extern "system" fn (pLayerName: *const c_char, pPropertyCount: *mut u32, pProperties: *mut ExtensionProperties) -> Result,
  EnumerateDeviceExtensionProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pLayerName: *const c_char, pPropertyCount: *mut u32, pProperties: *mut ExtensionProperties) -> Result,
  EnumerateInstanceLayerProperties_ptr: extern "system" fn (pPropertyCount: *mut u32, pProperties: *mut LayerProperties) -> Result,
  EnumerateDeviceLayerProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut LayerProperties) -> Result,
  GetDeviceQueue_ptr: extern "system" fn (device: Device, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut Queue),
  QueueSubmit_ptr: extern "system" fn (queue: Queue, submitCount: u32, pSubmits: *const SubmitInfo, fence: Fence) -> Result,
  QueueWaitIdle_ptr: extern "system" fn (queue: Queue) -> Result,
  DeviceWaitIdle_ptr: extern "system" fn (device: Device) -> Result,
  AllocateMemory_ptr: extern "system" fn (device: Device, pAllocateInfo: *const MemoryAllocateInfo, pAllocator: *const AllocationCallbacks, pMemory: *mut DeviceMemory) -> Result,
  FreeMemory_ptr: extern "system" fn (device: Device, memory: DeviceMemory, pAllocator: *const AllocationCallbacks),
  MapMemory_ptr: extern "system" fn (device: Device, memory: DeviceMemory, offset: DeviceSize, size: DeviceSize, flags: MemoryMapFlags, ppData: *mut *mut c_void) -> Result,
  UnmapMemory_ptr: extern "system" fn (device: Device, memory: DeviceMemory),
  FlushMappedMemoryRanges_ptr: extern "system" fn (device: Device, memoryRangeCount: u32, pMemoryRanges: *const MappedMemoryRange) -> Result,
  InvalidateMappedMemoryRanges_ptr: extern "system" fn (device: Device, memoryRangeCount: u32, pMemoryRanges: *const MappedMemoryRange) -> Result,
  GetDeviceMemoryCommitment_ptr: extern "system" fn (device: Device, memory: DeviceMemory, pCommittedMemoryInBytes: *mut DeviceSize),
  BindBufferMemory_ptr: extern "system" fn (device: Device, buffer: Buffer, memory: DeviceMemory, memoryOffset: DeviceSize) -> Result,
  BindImageMemory_ptr: extern "system" fn (device: Device, image: Image, memory: DeviceMemory, memoryOffset: DeviceSize) -> Result,
  GetBufferMemoryRequirements_ptr: extern "system" fn (device: Device, buffer: Buffer, pMemoryRequirements: *mut MemoryRequirements),
  GetImageMemoryRequirements_ptr: extern "system" fn (device: Device, image: Image, pMemoryRequirements: *mut MemoryRequirements),
  GetImageSparseMemoryRequirements_ptr: extern "system" fn (device: Device, image: Image, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut SparseImageMemoryRequirements),
  GetPhysicalDeviceSparseImageFormatProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, format: Format, typ: ImageType, samples: SampleCountFlagBits, usage: ImageUsageFlags, tiling: ImageTiling, pPropertyCount: *mut u32, pProperties: *mut SparseImageFormatProperties),
  QueueBindSparse_ptr: extern "system" fn (queue: Queue, bindInfoCount: u32, pBindInfo: *const BindSparseInfo, fence: Fence) -> Result,
  CreateFence_ptr: extern "system" fn (device: Device, pCreateInfo: *const FenceCreateInfo, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result,
  DestroyFence_ptr: extern "system" fn (device: Device, fence: Fence, pAllocator: *const AllocationCallbacks),
  ResetFences_ptr: extern "system" fn (device: Device, fenceCount: u32, pFences: *const Fence) -> Result,
  GetFenceStatus_ptr: extern "system" fn (device: Device, fence: Fence) -> Result,
  WaitForFences_ptr: extern "system" fn (device: Device, fenceCount: u32, pFences: *const Fence, waitAll: Bool32, timeout: u64) -> Result,
  CreateSemaphore_ptr: extern "system" fn (device: Device, pCreateInfo: *const SemaphoreCreateInfo, pAllocator: *const AllocationCallbacks, pSemaphore: *mut Semaphore) -> Result,
  DestroySemaphore_ptr: extern "system" fn (device: Device, semaphore: Semaphore, pAllocator: *const AllocationCallbacks),
  CreateEvent_ptr: extern "system" fn (device: Device, pCreateInfo: *const EventCreateInfo, pAllocator: *const AllocationCallbacks, pEvent: *mut Event) -> Result,
  DestroyEvent_ptr: extern "system" fn (device: Device, event: Event, pAllocator: *const AllocationCallbacks),
  GetEventStatus_ptr: extern "system" fn (device: Device, event: Event) -> Result,
  SetEvent_ptr: extern "system" fn (device: Device, event: Event) -> Result,
  ResetEvent_ptr: extern "system" fn (device: Device, event: Event) -> Result,
  CreateQueryPool_ptr: extern "system" fn (device: Device, pCreateInfo: *const QueryPoolCreateInfo, pAllocator: *const AllocationCallbacks, pQueryPool: *mut QueryPool) -> Result,
  DestroyQueryPool_ptr: extern "system" fn (device: Device, queryPool: QueryPool, pAllocator: *const AllocationCallbacks),
  GetQueryPoolResults_ptr: extern "system" fn (device: Device, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: DeviceSize, flags: QueryResultFlags) -> Result,
  CreateBuffer_ptr: extern "system" fn (device: Device, pCreateInfo: *const BufferCreateInfo, pAllocator: *const AllocationCallbacks, pBuffer: *mut Buffer) -> Result,
  DestroyBuffer_ptr: extern "system" fn (device: Device, buffer: Buffer, pAllocator: *const AllocationCallbacks),
  CreateBufferView_ptr: extern "system" fn (device: Device, pCreateInfo: *const BufferViewCreateInfo, pAllocator: *const AllocationCallbacks, pView: *mut BufferView) -> Result,
  DestroyBufferView_ptr: extern "system" fn (device: Device, bufferView: BufferView, pAllocator: *const AllocationCallbacks),
  CreateImage_ptr: extern "system" fn (device: Device, pCreateInfo: *const ImageCreateInfo, pAllocator: *const AllocationCallbacks, pImage: *mut Image) -> Result,
  DestroyImage_ptr: extern "system" fn (device: Device, image: Image, pAllocator: *const AllocationCallbacks),
  GetImageSubresourceLayout_ptr: extern "system" fn (device: Device, image: Image, pSubresource: *const ImageSubresource, pLayout: *mut SubresourceLayout),
  CreateImageView_ptr: extern "system" fn (device: Device, pCreateInfo: *const ImageViewCreateInfo, pAllocator: *const AllocationCallbacks, pView: *mut ImageView) -> Result,
  DestroyImageView_ptr: extern "system" fn (device: Device, imageView: ImageView, pAllocator: *const AllocationCallbacks),
  CreateShaderModule_ptr: extern "system" fn (device: Device, pCreateInfo: *const ShaderModuleCreateInfo, pAllocator: *const AllocationCallbacks, pShaderModule: *mut ShaderModule) -> Result,
  DestroyShaderModule_ptr: extern "system" fn (device: Device, shaderModule: ShaderModule, pAllocator: *const AllocationCallbacks),
  CreatePipelineCache_ptr: extern "system" fn (device: Device, pCreateInfo: *const PipelineCacheCreateInfo, pAllocator: *const AllocationCallbacks, pPipelineCache: *mut PipelineCache) -> Result,
  DestroyPipelineCache_ptr: extern "system" fn (device: Device, pipelineCache: PipelineCache, pAllocator: *const AllocationCallbacks),
  GetPipelineCacheData_ptr: extern "system" fn (device: Device, pipelineCache: PipelineCache, pDataSize: *mut usize, pData: *mut c_void) -> Result,
  MergePipelineCaches_ptr: extern "system" fn (device: Device, dstCache: PipelineCache, srcCacheCount: u32, pSrcCaches: *const PipelineCache) -> Result,
  CreateGraphicsPipelines_ptr: extern "system" fn (device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const GraphicsPipelineCreateInfo, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result,
  CreateComputePipelines_ptr: extern "system" fn (device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const ComputePipelineCreateInfo, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result,
  DestroyPipeline_ptr: extern "system" fn (device: Device, pipeline: Pipeline, pAllocator: *const AllocationCallbacks),
  CreatePipelineLayout_ptr: extern "system" fn (device: Device, pCreateInfo: *const PipelineLayoutCreateInfo, pAllocator: *const AllocationCallbacks, pPipelineLayout: *mut PipelineLayout) -> Result,
  DestroyPipelineLayout_ptr: extern "system" fn (device: Device, pipelineLayout: PipelineLayout, pAllocator: *const AllocationCallbacks),
  CreateSampler_ptr: extern "system" fn (device: Device, pCreateInfo: *const SamplerCreateInfo, pAllocator: *const AllocationCallbacks, pSampler: *mut Sampler) -> Result,
  DestroySampler_ptr: extern "system" fn (device: Device, sampler: Sampler, pAllocator: *const AllocationCallbacks),
  CreateDescriptorSetLayout_ptr: extern "system" fn (device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pAllocator: *const AllocationCallbacks, pSetLayout: *mut DescriptorSetLayout) -> Result,
  DestroyDescriptorSetLayout_ptr: extern "system" fn (device: Device, descriptorSetLayout: DescriptorSetLayout, pAllocator: *const AllocationCallbacks),
  CreateDescriptorPool_ptr: extern "system" fn (device: Device, pCreateInfo: *const DescriptorPoolCreateInfo, pAllocator: *const AllocationCallbacks, pDescriptorPool: *mut DescriptorPool) -> Result,
  DestroyDescriptorPool_ptr: extern "system" fn (device: Device, descriptorPool: DescriptorPool, pAllocator: *const AllocationCallbacks),
  ResetDescriptorPool_ptr: extern "system" fn (device: Device, descriptorPool: DescriptorPool, flags: DescriptorPoolResetFlags) -> Result,
  AllocateDescriptorSets_ptr: extern "system" fn (device: Device, pAllocateInfo: *const DescriptorSetAllocateInfo, pDescriptorSets: *mut DescriptorSet) -> Result,
  FreeDescriptorSets_ptr: extern "system" fn (device: Device, descriptorPool: DescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const DescriptorSet) -> Result,
  UpdateDescriptorSets_ptr: extern "system" fn (device: Device, descriptorWriteCount: u32, pDescriptorWrites: *const WriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const CopyDescriptorSet),
  CreateFramebuffer_ptr: extern "system" fn (device: Device, pCreateInfo: *const FramebufferCreateInfo, pAllocator: *const AllocationCallbacks, pFramebuffer: *mut Framebuffer) -> Result,
  DestroyFramebuffer_ptr: extern "system" fn (device: Device, framebuffer: Framebuffer, pAllocator: *const AllocationCallbacks),
  CreateRenderPass_ptr: extern "system" fn (device: Device, pCreateInfo: *const RenderPassCreateInfo, pAllocator: *const AllocationCallbacks, pRenderPass: *mut RenderPass) -> Result,
  DestroyRenderPass_ptr: extern "system" fn (device: Device, renderPass: RenderPass, pAllocator: *const AllocationCallbacks),
  GetRenderAreaGranularity_ptr: extern "system" fn (device: Device, renderPass: RenderPass, pGranularity: *mut Extent2D),
  CreateCommandPool_ptr: extern "system" fn (device: Device, pCreateInfo: *const CommandPoolCreateInfo, pAllocator: *const AllocationCallbacks, pCommandPool: *mut CommandPool) -> Result,
  DestroyCommandPool_ptr: extern "system" fn (device: Device, commandPool: CommandPool, pAllocator: *const AllocationCallbacks),
  ResetCommandPool_ptr: extern "system" fn (device: Device, commandPool: CommandPool, flags: CommandPoolResetFlags) -> Result,
  AllocateCommandBuffers_ptr: extern "system" fn (device: Device, pAllocateInfo: *const CommandBufferAllocateInfo, pCommandBuffers: *mut CommandBuffer) -> Result,
  FreeCommandBuffers_ptr: extern "system" fn (device: Device, commandPool: CommandPool, commandBufferCount: u32, pCommandBuffers: *const CommandBuffer),
  BeginCommandBuffer_ptr: extern "system" fn (commandBuffer: CommandBuffer, pBeginInfo: *const CommandBufferBeginInfo) -> Result,
  EndCommandBuffer_ptr: extern "system" fn (commandBuffer: CommandBuffer) -> Result,
  ResetCommandBuffer_ptr: extern "system" fn (commandBuffer: CommandBuffer, flags: CommandBufferResetFlags) -> Result,
  CmdBindPipeline_ptr: extern "system" fn (commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, pipeline: Pipeline),
  CmdSetViewport_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const Viewport),
  CmdSetScissor_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const Rect2D),
  CmdSetLineWidth_ptr: extern "system" fn (commandBuffer: CommandBuffer, lineWidth: f32),
  CmdSetDepthBias_ptr: extern "system" fn (commandBuffer: CommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32),
  CmdSetBlendConstants_ptr: extern "system" fn (commandBuffer: CommandBuffer, blendConstants: [f32; 4]),
  CmdSetDepthBounds_ptr: extern "system" fn (commandBuffer: CommandBuffer, minDepthBounds: f32, maxDepthBounds: f32),
  CmdSetStencilCompareMask_ptr: extern "system" fn (commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, compareMask: u32),
  CmdSetStencilWriteMask_ptr: extern "system" fn (commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, writeMask: u32),
  CmdSetStencilReference_ptr: extern "system" fn (commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, reference: u32),
  CmdBindDescriptorSets_ptr: extern "system" fn (commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const DescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const u32),
  CmdBindIndexBuffer_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, indexType: IndexType),
  CmdBindVertexBuffers_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const Buffer, pOffsets: *const DeviceSize),
  CmdDraw_ptr: extern "system" fn (commandBuffer: CommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32),
  CmdDrawIndexed_ptr: extern "system" fn (commandBuffer: CommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32),
  CmdDrawIndirect_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32),
  CmdDrawIndexedIndirect_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32),
  CmdDispatch_ptr: extern "system" fn (commandBuffer: CommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32),
  CmdDispatchIndirect_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize),
  CmdCopyBuffer_ptr: extern "system" fn (commandBuffer: CommandBuffer, srcBuffer: Buffer, dstBuffer: Buffer, regionCount: u32, pRegions: *const BufferCopy),
  CmdCopyImage_ptr: extern "system" fn (commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageCopy),
  CmdBlitImage_ptr: extern "system" fn (commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageBlit, filter: Filter),
  CmdCopyBufferToImage_ptr: extern "system" fn (commandBuffer: CommandBuffer, srcBuffer: Buffer, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const BufferImageCopy),
  CmdCopyImageToBuffer_ptr: extern "system" fn (commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstBuffer: Buffer, regionCount: u32, pRegions: *const BufferImageCopy),
  CmdUpdateBuffer_ptr: extern "system" fn (commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, dataSize: DeviceSize, pData: *const c_void),
  CmdFillBuffer_ptr: extern "system" fn (commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, size: DeviceSize, data: u32),
  CmdClearColorImage_ptr: extern "system" fn (commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pColor: *const ClearColorValue, rangeCount: u32, pRanges: *const ImageSubresourceRange),
  CmdClearDepthStencilImage_ptr: extern "system" fn (commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pDepthStencil: *const ClearDepthStencilValue, rangeCount: u32, pRanges: *const ImageSubresourceRange),
  CmdClearAttachments_ptr: extern "system" fn (commandBuffer: CommandBuffer, attachmentCount: u32, pAttachments: *const ClearAttachment, rectCount: u32, pRects: *const ClearRect),
  CmdResolveImage_ptr: extern "system" fn (commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageResolve),
  CmdSetEvent_ptr: extern "system" fn (commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags),
  CmdResetEvent_ptr: extern "system" fn (commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags),
  CmdWaitEvents_ptr: extern "system" fn (commandBuffer: CommandBuffer, eventCount: u32, pEvents: *const Event, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const ImageMemoryBarrier),
  CmdPipelineBarrier_ptr: extern "system" fn (commandBuffer: CommandBuffer, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, dependencyFlags: DependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const ImageMemoryBarrier),
  CmdBeginQuery_ptr: extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags),
  CmdEndQuery_ptr: extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32),
  CmdResetQueryPool_ptr: extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32),
  CmdWriteTimestamp_ptr: extern "system" fn (commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlagBits, queryPool: QueryPool, query: u32),
  CmdCopyQueryPoolResults_ptr: extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dstBuffer: Buffer, dstOffset: DeviceSize, stride: DeviceSize, flags: QueryResultFlags),
  CmdPushConstants_ptr: extern "system" fn (commandBuffer: CommandBuffer, layout: PipelineLayout, stageFlags: ShaderStageFlags, offset: u32, size: u32, pValues: *const c_void),
  CmdBeginRenderPass_ptr: extern "system" fn (commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, contents: SubpassContents),
  CmdNextSubpass_ptr: extern "system" fn (commandBuffer: CommandBuffer, contents: SubpassContents),
  CmdEndRenderPass_ptr: extern "system" fn (commandBuffer: CommandBuffer),
  CmdExecuteCommands_ptr: extern "system" fn (commandBuffer: CommandBuffer, commandBufferCount: u32, pCommandBuffers: *const CommandBuffer),
  EnumerateInstanceVersion_ptr: extern "system" fn (pApiVersion: *mut u32) -> Result,
  BindBufferMemory2_ptr: extern "system" fn (device: Device, bindInfoCount: u32, pBindInfos: *const BindBufferMemoryInfo) -> Result,
  BindImageMemory2_ptr: extern "system" fn (device: Device, bindInfoCount: u32, pBindInfos: *const BindImageMemoryInfo) -> Result,
  GetDeviceGroupPeerMemoryFeatures_ptr: extern "system" fn (device: Device, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut PeerMemoryFeatureFlags),
  CmdSetDeviceMask_ptr: extern "system" fn (commandBuffer: CommandBuffer, deviceMask: u32),
  CmdDispatchBase_ptr: extern "system" fn (commandBuffer: CommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32),
  EnumeratePhysicalDeviceGroups_ptr: extern "system" fn (instance: Instance, pPhysicalDeviceGroupCount: *mut u32, pPhysicalDeviceGroupProperties: *mut PhysicalDeviceGroupProperties) -> Result,
  GetImageMemoryRequirements2_ptr: extern "system" fn (device: Device, pInfo: *const ImageMemoryRequirementsInfo2, pMemoryRequirements: *mut MemoryRequirements2),
  GetBufferMemoryRequirements2_ptr: extern "system" fn (device: Device, pInfo: *const BufferMemoryRequirementsInfo2, pMemoryRequirements: *mut MemoryRequirements2),
  GetImageSparseMemoryRequirements2_ptr: extern "system" fn (device: Device, pInfo: *const ImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut SparseImageMemoryRequirements2),
  GetPhysicalDeviceFeatures2_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pFeatures: *mut PhysicalDeviceFeatures2),
  GetPhysicalDeviceProperties2_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pProperties: *mut PhysicalDeviceProperties2),
  GetPhysicalDeviceFormatProperties2_ptr: extern "system" fn (physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *mut FormatProperties2),
  GetPhysicalDeviceImageFormatProperties2_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pImageFormatInfo: *const PhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut ImageFormatProperties2) -> Result,
  GetPhysicalDeviceQueueFamilyProperties2_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut QueueFamilyProperties2),
  GetPhysicalDeviceMemoryProperties2_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pMemoryProperties: *mut PhysicalDeviceMemoryProperties2),
  GetPhysicalDeviceSparseImageFormatProperties2_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pFormatInfo: *const PhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut u32, pProperties: *mut SparseImageFormatProperties2),
  TrimCommandPool_ptr: extern "system" fn (device: Device, commandPool: CommandPool, flags: CommandPoolTrimFlags),
  GetDeviceQueue2_ptr: extern "system" fn (device: Device, pQueueInfo: *const DeviceQueueInfo2, pQueue: *mut Queue),
  CreateSamplerYcbcrConversion_ptr: extern "system" fn (device: Device, pCreateInfo: *const SamplerYcbcrConversionCreateInfo, pAllocator: *const AllocationCallbacks, pYcbcrConversion: *mut SamplerYcbcrConversion) -> Result,
  DestroySamplerYcbcrConversion_ptr: extern "system" fn (device: Device, ycbcrConversion: SamplerYcbcrConversion, pAllocator: *const AllocationCallbacks),
  CreateDescriptorUpdateTemplate_ptr: extern "system" fn (device: Device, pCreateInfo: *const DescriptorUpdateTemplateCreateInfo, pAllocator: *const AllocationCallbacks, pDescriptorUpdateTemplate: *mut DescriptorUpdateTemplate) -> Result,
  DestroyDescriptorUpdateTemplate_ptr: extern "system" fn (device: Device, descriptorUpdateTemplate: DescriptorUpdateTemplate, pAllocator: *const AllocationCallbacks),
  UpdateDescriptorSetWithTemplate_ptr: extern "system" fn (device: Device, descriptorSet: DescriptorSet, descriptorUpdateTemplate: DescriptorUpdateTemplate, pData: *const c_void),
  GetPhysicalDeviceExternalBufferProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pExternalBufferInfo: *const PhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut ExternalBufferProperties),
  GetPhysicalDeviceExternalFenceProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pExternalFenceInfo: *const PhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut ExternalFenceProperties),
  GetPhysicalDeviceExternalSemaphoreProperties_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pExternalSemaphoreInfo: *const PhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut ExternalSemaphoreProperties),
  GetDescriptorSetLayoutSupport_ptr: extern "system" fn (device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pSupport: *mut DescriptorSetLayoutSupport),
}


extern "system" fn CreateInstance_panic(_pCreateInfo: *const InstanceCreateInfo, _pAllocator: *const AllocationCallbacks, _pInstance: *mut Instance) -> Result{
    panic!("extension vkCreateInstance not loaded")
}
extern "system" fn DestroyInstance_panic(_instance: Instance, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyInstance not loaded")
}
extern "system" fn EnumeratePhysicalDevices_panic(_instance: Instance, _pPhysicalDeviceCount: *mut u32, _pPhysicalDevices: *mut PhysicalDevice) -> Result{
    panic!("extension vkEnumeratePhysicalDevices not loaded")
}
extern "system" fn GetPhysicalDeviceFeatures_panic(_physicalDevice: PhysicalDevice, _pFeatures: *mut PhysicalDeviceFeatures){
    panic!("extension vkGetPhysicalDeviceFeatures not loaded")
}
extern "system" fn GetPhysicalDeviceFormatProperties_panic(_physicalDevice: PhysicalDevice, _format: Format, _pFormatProperties: *mut FormatProperties){
    panic!("extension vkGetPhysicalDeviceFormatProperties not loaded")
}
extern "system" fn GetPhysicalDeviceImageFormatProperties_panic(_physicalDevice: PhysicalDevice, _format: Format, _typ: ImageType, _tiling: ImageTiling, _usage: ImageUsageFlags, _flags: ImageCreateFlags, _pImageFormatProperties: *mut ImageFormatProperties) -> Result{
    panic!("extension vkGetPhysicalDeviceImageFormatProperties not loaded")
}
extern "system" fn GetPhysicalDeviceProperties_panic(_physicalDevice: PhysicalDevice, _pProperties: *mut PhysicalDeviceProperties){
    panic!("extension vkGetPhysicalDeviceProperties not loaded")
}
extern "system" fn GetPhysicalDeviceQueueFamilyProperties_panic(_physicalDevice: PhysicalDevice, _pQueueFamilyPropertyCount: *mut u32, _pQueueFamilyProperties: *mut QueueFamilyProperties){
    panic!("extension vkGetPhysicalDeviceQueueFamilyProperties not loaded")
}
extern "system" fn GetPhysicalDeviceMemoryProperties_panic(_physicalDevice: PhysicalDevice, _pMemoryProperties: *mut PhysicalDeviceMemoryProperties){
    panic!("extension vkGetPhysicalDeviceMemoryProperties not loaded")
}
extern "system" fn GetInstanceProcAddr_panic(_instance: Instance, _pName: *const c_char) -> PFN_vkVoidFunction{
    panic!("extension vkGetInstanceProcAddr not loaded")
}
extern "system" fn GetDeviceProcAddr_panic(_device: Device, _pName: *const c_char) -> PFN_vkVoidFunction{
    panic!("extension vkGetDeviceProcAddr not loaded")
}
extern "system" fn CreateDevice_panic(_physicalDevice: PhysicalDevice, _pCreateInfo: *const DeviceCreateInfo, _pAllocator: *const AllocationCallbacks, _pDevice: *mut Device) -> Result{
    panic!("extension vkCreateDevice not loaded")
}
extern "system" fn DestroyDevice_panic(_device: Device, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyDevice not loaded")
}
extern "system" fn EnumerateInstanceExtensionProperties_panic(_pLayerName: *const c_char, _pPropertyCount: *mut u32, _pProperties: *mut ExtensionProperties) -> Result{
    panic!("extension vkEnumerateInstanceExtensionProperties not loaded")
}
extern "system" fn EnumerateDeviceExtensionProperties_panic(_physicalDevice: PhysicalDevice, _pLayerName: *const c_char, _pPropertyCount: *mut u32, _pProperties: *mut ExtensionProperties) -> Result{
    panic!("extension vkEnumerateDeviceExtensionProperties not loaded")
}
extern "system" fn EnumerateInstanceLayerProperties_panic(_pPropertyCount: *mut u32, _pProperties: *mut LayerProperties) -> Result{
    panic!("extension vkEnumerateInstanceLayerProperties not loaded")
}
extern "system" fn EnumerateDeviceLayerProperties_panic(_physicalDevice: PhysicalDevice, _pPropertyCount: *mut u32, _pProperties: *mut LayerProperties) -> Result{
    panic!("extension vkEnumerateDeviceLayerProperties not loaded")
}
extern "system" fn GetDeviceQueue_panic(_device: Device, _queueFamilyIndex: u32, _queueIndex: u32, _pQueue: *mut Queue){
    panic!("extension vkGetDeviceQueue not loaded")
}
extern "system" fn QueueSubmit_panic(_queue: Queue, _submitCount: u32, _pSubmits: *const SubmitInfo, _fence: Fence) -> Result{
    panic!("extension vkQueueSubmit not loaded")
}
extern "system" fn QueueWaitIdle_panic(_queue: Queue) -> Result{
    panic!("extension vkQueueWaitIdle not loaded")
}
extern "system" fn DeviceWaitIdle_panic(_device: Device) -> Result{
    panic!("extension vkDeviceWaitIdle not loaded")
}
extern "system" fn AllocateMemory_panic(_device: Device, _pAllocateInfo: *const MemoryAllocateInfo, _pAllocator: *const AllocationCallbacks, _pMemory: *mut DeviceMemory) -> Result{
    panic!("extension vkAllocateMemory not loaded")
}
extern "system" fn FreeMemory_panic(_device: Device, _memory: DeviceMemory, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkFreeMemory not loaded")
}
extern "system" fn MapMemory_panic(_device: Device, _memory: DeviceMemory, _offset: DeviceSize, _size: DeviceSize, _flags: MemoryMapFlags, _ppData: *mut *mut c_void) -> Result{
    panic!("extension vkMapMemory not loaded")
}
extern "system" fn UnmapMemory_panic(_device: Device, _memory: DeviceMemory){
    panic!("extension vkUnmapMemory not loaded")
}
extern "system" fn FlushMappedMemoryRanges_panic(_device: Device, _memoryRangeCount: u32, _pMemoryRanges: *const MappedMemoryRange) -> Result{
    panic!("extension vkFlushMappedMemoryRanges not loaded")
}
extern "system" fn InvalidateMappedMemoryRanges_panic(_device: Device, _memoryRangeCount: u32, _pMemoryRanges: *const MappedMemoryRange) -> Result{
    panic!("extension vkInvalidateMappedMemoryRanges not loaded")
}
extern "system" fn GetDeviceMemoryCommitment_panic(_device: Device, _memory: DeviceMemory, _pCommittedMemoryInBytes: *mut DeviceSize){
    panic!("extension vkGetDeviceMemoryCommitment not loaded")
}
extern "system" fn BindBufferMemory_panic(_device: Device, _buffer: Buffer, _memory: DeviceMemory, _memoryOffset: DeviceSize) -> Result{
    panic!("extension vkBindBufferMemory not loaded")
}
extern "system" fn BindImageMemory_panic(_device: Device, _image: Image, _memory: DeviceMemory, _memoryOffset: DeviceSize) -> Result{
    panic!("extension vkBindImageMemory not loaded")
}
extern "system" fn GetBufferMemoryRequirements_panic(_device: Device, _buffer: Buffer, _pMemoryRequirements: *mut MemoryRequirements){
    panic!("extension vkGetBufferMemoryRequirements not loaded")
}
extern "system" fn GetImageMemoryRequirements_panic(_device: Device, _image: Image, _pMemoryRequirements: *mut MemoryRequirements){
    panic!("extension vkGetImageMemoryRequirements not loaded")
}
extern "system" fn GetImageSparseMemoryRequirements_panic(_device: Device, _image: Image, _pSparseMemoryRequirementCount: *mut u32, _pSparseMemoryRequirements: *mut SparseImageMemoryRequirements){
    panic!("extension vkGetImageSparseMemoryRequirements not loaded")
}
extern "system" fn GetPhysicalDeviceSparseImageFormatProperties_panic(_physicalDevice: PhysicalDevice, _format: Format, _typ: ImageType, _samples: SampleCountFlagBits, _usage: ImageUsageFlags, _tiling: ImageTiling, _pPropertyCount: *mut u32, _pProperties: *mut SparseImageFormatProperties){
    panic!("extension vkGetPhysicalDeviceSparseImageFormatProperties not loaded")
}
extern "system" fn QueueBindSparse_panic(_queue: Queue, _bindInfoCount: u32, _pBindInfo: *const BindSparseInfo, _fence: Fence) -> Result{
    panic!("extension vkQueueBindSparse not loaded")
}
extern "system" fn CreateFence_panic(_device: Device, _pCreateInfo: *const FenceCreateInfo, _pAllocator: *const AllocationCallbacks, _pFence: *mut Fence) -> Result{
    panic!("extension vkCreateFence not loaded")
}
extern "system" fn DestroyFence_panic(_device: Device, _fence: Fence, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyFence not loaded")
}
extern "system" fn ResetFences_panic(_device: Device, _fenceCount: u32, _pFences: *const Fence) -> Result{
    panic!("extension vkResetFences not loaded")
}
extern "system" fn GetFenceStatus_panic(_device: Device, _fence: Fence) -> Result{
    panic!("extension vkGetFenceStatus not loaded")
}
extern "system" fn WaitForFences_panic(_device: Device, _fenceCount: u32, _pFences: *const Fence, _waitAll: Bool32, _timeout: u64) -> Result{
    panic!("extension vkWaitForFences not loaded")
}
extern "system" fn CreateSemaphore_panic(_device: Device, _pCreateInfo: *const SemaphoreCreateInfo, _pAllocator: *const AllocationCallbacks, _pSemaphore: *mut Semaphore) -> Result{
    panic!("extension vkCreateSemaphore not loaded")
}
extern "system" fn DestroySemaphore_panic(_device: Device, _semaphore: Semaphore, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroySemaphore not loaded")
}
extern "system" fn CreateEvent_panic(_device: Device, _pCreateInfo: *const EventCreateInfo, _pAllocator: *const AllocationCallbacks, _pEvent: *mut Event) -> Result{
    panic!("extension vkCreateEvent not loaded")
}
extern "system" fn DestroyEvent_panic(_device: Device, _event: Event, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyEvent not loaded")
}
extern "system" fn GetEventStatus_panic(_device: Device, _event: Event) -> Result{
    panic!("extension vkGetEventStatus not loaded")
}
extern "system" fn SetEvent_panic(_device: Device, _event: Event) -> Result{
    panic!("extension vkSetEvent not loaded")
}
extern "system" fn ResetEvent_panic(_device: Device, _event: Event) -> Result{
    panic!("extension vkResetEvent not loaded")
}
extern "system" fn CreateQueryPool_panic(_device: Device, _pCreateInfo: *const QueryPoolCreateInfo, _pAllocator: *const AllocationCallbacks, _pQueryPool: *mut QueryPool) -> Result{
    panic!("extension vkCreateQueryPool not loaded")
}
extern "system" fn DestroyQueryPool_panic(_device: Device, _queryPool: QueryPool, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyQueryPool not loaded")
}
extern "system" fn GetQueryPoolResults_panic(_device: Device, _queryPool: QueryPool, _firstQuery: u32, _queryCount: u32, _dataSize: usize, _pData: *mut c_void, _stride: DeviceSize, _flags: QueryResultFlags) -> Result{
    panic!("extension vkGetQueryPoolResults not loaded")
}
extern "system" fn CreateBuffer_panic(_device: Device, _pCreateInfo: *const BufferCreateInfo, _pAllocator: *const AllocationCallbacks, _pBuffer: *mut Buffer) -> Result{
    panic!("extension vkCreateBuffer not loaded")
}
extern "system" fn DestroyBuffer_panic(_device: Device, _buffer: Buffer, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyBuffer not loaded")
}
extern "system" fn CreateBufferView_panic(_device: Device, _pCreateInfo: *const BufferViewCreateInfo, _pAllocator: *const AllocationCallbacks, _pView: *mut BufferView) -> Result{
    panic!("extension vkCreateBufferView not loaded")
}
extern "system" fn DestroyBufferView_panic(_device: Device, _bufferView: BufferView, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyBufferView not loaded")
}
extern "system" fn CreateImage_panic(_device: Device, _pCreateInfo: *const ImageCreateInfo, _pAllocator: *const AllocationCallbacks, _pImage: *mut Image) -> Result{
    panic!("extension vkCreateImage not loaded")
}
extern "system" fn DestroyImage_panic(_device: Device, _image: Image, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyImage not loaded")
}
extern "system" fn GetImageSubresourceLayout_panic(_device: Device, _image: Image, _pSubresource: *const ImageSubresource, _pLayout: *mut SubresourceLayout){
    panic!("extension vkGetImageSubresourceLayout not loaded")
}
extern "system" fn CreateImageView_panic(_device: Device, _pCreateInfo: *const ImageViewCreateInfo, _pAllocator: *const AllocationCallbacks, _pView: *mut ImageView) -> Result{
    panic!("extension vkCreateImageView not loaded")
}
extern "system" fn DestroyImageView_panic(_device: Device, _imageView: ImageView, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyImageView not loaded")
}
extern "system" fn CreateShaderModule_panic(_device: Device, _pCreateInfo: *const ShaderModuleCreateInfo, _pAllocator: *const AllocationCallbacks, _pShaderModule: *mut ShaderModule) -> Result{
    panic!("extension vkCreateShaderModule not loaded")
}
extern "system" fn DestroyShaderModule_panic(_device: Device, _shaderModule: ShaderModule, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyShaderModule not loaded")
}
extern "system" fn CreatePipelineCache_panic(_device: Device, _pCreateInfo: *const PipelineCacheCreateInfo, _pAllocator: *const AllocationCallbacks, _pPipelineCache: *mut PipelineCache) -> Result{
    panic!("extension vkCreatePipelineCache not loaded")
}
extern "system" fn DestroyPipelineCache_panic(_device: Device, _pipelineCache: PipelineCache, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyPipelineCache not loaded")
}
extern "system" fn GetPipelineCacheData_panic(_device: Device, _pipelineCache: PipelineCache, _pDataSize: *mut usize, _pData: *mut c_void) -> Result{
    panic!("extension vkGetPipelineCacheData not loaded")
}
extern "system" fn MergePipelineCaches_panic(_device: Device, _dstCache: PipelineCache, _srcCacheCount: u32, _pSrcCaches: *const PipelineCache) -> Result{
    panic!("extension vkMergePipelineCaches not loaded")
}
extern "system" fn CreateGraphicsPipelines_panic(_device: Device, _pipelineCache: PipelineCache, _createInfoCount: u32, _pCreateInfos: *const GraphicsPipelineCreateInfo, _pAllocator: *const AllocationCallbacks, _pPipelines: *mut Pipeline) -> Result{
    panic!("extension vkCreateGraphicsPipelines not loaded")
}
extern "system" fn CreateComputePipelines_panic(_device: Device, _pipelineCache: PipelineCache, _createInfoCount: u32, _pCreateInfos: *const ComputePipelineCreateInfo, _pAllocator: *const AllocationCallbacks, _pPipelines: *mut Pipeline) -> Result{
    panic!("extension vkCreateComputePipelines not loaded")
}
extern "system" fn DestroyPipeline_panic(_device: Device, _pipeline: Pipeline, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyPipeline not loaded")
}
extern "system" fn CreatePipelineLayout_panic(_device: Device, _pCreateInfo: *const PipelineLayoutCreateInfo, _pAllocator: *const AllocationCallbacks, _pPipelineLayout: *mut PipelineLayout) -> Result{
    panic!("extension vkCreatePipelineLayout not loaded")
}
extern "system" fn DestroyPipelineLayout_panic(_device: Device, _pipelineLayout: PipelineLayout, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyPipelineLayout not loaded")
}
extern "system" fn CreateSampler_panic(_device: Device, _pCreateInfo: *const SamplerCreateInfo, _pAllocator: *const AllocationCallbacks, _pSampler: *mut Sampler) -> Result{
    panic!("extension vkCreateSampler not loaded")
}
extern "system" fn DestroySampler_panic(_device: Device, _sampler: Sampler, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroySampler not loaded")
}
extern "system" fn CreateDescriptorSetLayout_panic(_device: Device, _pCreateInfo: *const DescriptorSetLayoutCreateInfo, _pAllocator: *const AllocationCallbacks, _pSetLayout: *mut DescriptorSetLayout) -> Result{
    panic!("extension vkCreateDescriptorSetLayout not loaded")
}
extern "system" fn DestroyDescriptorSetLayout_panic(_device: Device, _descriptorSetLayout: DescriptorSetLayout, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyDescriptorSetLayout not loaded")
}
extern "system" fn CreateDescriptorPool_panic(_device: Device, _pCreateInfo: *const DescriptorPoolCreateInfo, _pAllocator: *const AllocationCallbacks, _pDescriptorPool: *mut DescriptorPool) -> Result{
    panic!("extension vkCreateDescriptorPool not loaded")
}
extern "system" fn DestroyDescriptorPool_panic(_device: Device, _descriptorPool: DescriptorPool, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyDescriptorPool not loaded")
}
extern "system" fn ResetDescriptorPool_panic(_device: Device, _descriptorPool: DescriptorPool, _flags: DescriptorPoolResetFlags) -> Result{
    panic!("extension vkResetDescriptorPool not loaded")
}
extern "system" fn AllocateDescriptorSets_panic(_device: Device, _pAllocateInfo: *const DescriptorSetAllocateInfo, _pDescriptorSets: *mut DescriptorSet) -> Result{
    panic!("extension vkAllocateDescriptorSets not loaded")
}
extern "system" fn FreeDescriptorSets_panic(_device: Device, _descriptorPool: DescriptorPool, _descriptorSetCount: u32, _pDescriptorSets: *const DescriptorSet) -> Result{
    panic!("extension vkFreeDescriptorSets not loaded")
}
extern "system" fn UpdateDescriptorSets_panic(_device: Device, _descriptorWriteCount: u32, _pDescriptorWrites: *const WriteDescriptorSet, _descriptorCopyCount: u32, _pDescriptorCopies: *const CopyDescriptorSet){
    panic!("extension vkUpdateDescriptorSets not loaded")
}
extern "system" fn CreateFramebuffer_panic(_device: Device, _pCreateInfo: *const FramebufferCreateInfo, _pAllocator: *const AllocationCallbacks, _pFramebuffer: *mut Framebuffer) -> Result{
    panic!("extension vkCreateFramebuffer not loaded")
}
extern "system" fn DestroyFramebuffer_panic(_device: Device, _framebuffer: Framebuffer, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyFramebuffer not loaded")
}
extern "system" fn CreateRenderPass_panic(_device: Device, _pCreateInfo: *const RenderPassCreateInfo, _pAllocator: *const AllocationCallbacks, _pRenderPass: *mut RenderPass) -> Result{
    panic!("extension vkCreateRenderPass not loaded")
}
extern "system" fn DestroyRenderPass_panic(_device: Device, _renderPass: RenderPass, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyRenderPass not loaded")
}
extern "system" fn GetRenderAreaGranularity_panic(_device: Device, _renderPass: RenderPass, _pGranularity: *mut Extent2D){
    panic!("extension vkGetRenderAreaGranularity not loaded")
}
extern "system" fn CreateCommandPool_panic(_device: Device, _pCreateInfo: *const CommandPoolCreateInfo, _pAllocator: *const AllocationCallbacks, _pCommandPool: *mut CommandPool) -> Result{
    panic!("extension vkCreateCommandPool not loaded")
}
extern "system" fn DestroyCommandPool_panic(_device: Device, _commandPool: CommandPool, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyCommandPool not loaded")
}
extern "system" fn ResetCommandPool_panic(_device: Device, _commandPool: CommandPool, _flags: CommandPoolResetFlags) -> Result{
    panic!("extension vkResetCommandPool not loaded")
}
extern "system" fn AllocateCommandBuffers_panic(_device: Device, _pAllocateInfo: *const CommandBufferAllocateInfo, _pCommandBuffers: *mut CommandBuffer) -> Result{
    panic!("extension vkAllocateCommandBuffers not loaded")
}
extern "system" fn FreeCommandBuffers_panic(_device: Device, _commandPool: CommandPool, _commandBufferCount: u32, _pCommandBuffers: *const CommandBuffer){
    panic!("extension vkFreeCommandBuffers not loaded")
}
extern "system" fn BeginCommandBuffer_panic(_commandBuffer: CommandBuffer, _pBeginInfo: *const CommandBufferBeginInfo) -> Result{
    panic!("extension vkBeginCommandBuffer not loaded")
}
extern "system" fn EndCommandBuffer_panic(_commandBuffer: CommandBuffer) -> Result{
    panic!("extension vkEndCommandBuffer not loaded")
}
extern "system" fn ResetCommandBuffer_panic(_commandBuffer: CommandBuffer, _flags: CommandBufferResetFlags) -> Result{
    panic!("extension vkResetCommandBuffer not loaded")
}
extern "system" fn CmdBindPipeline_panic(_commandBuffer: CommandBuffer, _pipelineBindPoint: PipelineBindPoint, _pipeline: Pipeline){
    panic!("extension vkCmdBindPipeline not loaded")
}
extern "system" fn CmdSetViewport_panic(_commandBuffer: CommandBuffer, _firstViewport: u32, _viewportCount: u32, _pViewports: *const Viewport){
    panic!("extension vkCmdSetViewport not loaded")
}
extern "system" fn CmdSetScissor_panic(_commandBuffer: CommandBuffer, _firstScissor: u32, _scissorCount: u32, _pScissors: *const Rect2D){
    panic!("extension vkCmdSetScissor not loaded")
}
extern "system" fn CmdSetLineWidth_panic(_commandBuffer: CommandBuffer, _lineWidth: f32){
    panic!("extension vkCmdSetLineWidth not loaded")
}
extern "system" fn CmdSetDepthBias_panic(_commandBuffer: CommandBuffer, _depthBiasConstantFactor: f32, _depthBiasClamp: f32, _depthBiasSlopeFactor: f32){
    panic!("extension vkCmdSetDepthBias not loaded")
}
extern "system" fn CmdSetBlendConstants_panic(_commandBuffer: CommandBuffer, _blendConstants: [f32; 4]){
    panic!("extension vkCmdSetBlendConstants not loaded")
}
extern "system" fn CmdSetDepthBounds_panic(_commandBuffer: CommandBuffer, _minDepthBounds: f32, _maxDepthBounds: f32){
    panic!("extension vkCmdSetDepthBounds not loaded")
}
extern "system" fn CmdSetStencilCompareMask_panic(_commandBuffer: CommandBuffer, _faceMask: StencilFaceFlags, _compareMask: u32){
    panic!("extension vkCmdSetStencilCompareMask not loaded")
}
extern "system" fn CmdSetStencilWriteMask_panic(_commandBuffer: CommandBuffer, _faceMask: StencilFaceFlags, _writeMask: u32){
    panic!("extension vkCmdSetStencilWriteMask not loaded")
}
extern "system" fn CmdSetStencilReference_panic(_commandBuffer: CommandBuffer, _faceMask: StencilFaceFlags, _reference: u32){
    panic!("extension vkCmdSetStencilReference not loaded")
}
extern "system" fn CmdBindDescriptorSets_panic(_commandBuffer: CommandBuffer, _pipelineBindPoint: PipelineBindPoint, _layout: PipelineLayout, _firstSet: u32, _descriptorSetCount: u32, _pDescriptorSets: *const DescriptorSet, _dynamicOffsetCount: u32, _pDynamicOffsets: *const u32){
    panic!("extension vkCmdBindDescriptorSets not loaded")
}
extern "system" fn CmdBindIndexBuffer_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _indexType: IndexType){
    panic!("extension vkCmdBindIndexBuffer not loaded")
}
extern "system" fn CmdBindVertexBuffers_panic(_commandBuffer: CommandBuffer, _firstBinding: u32, _bindingCount: u32, _pBuffers: *const Buffer, _pOffsets: *const DeviceSize){
    panic!("extension vkCmdBindVertexBuffers not loaded")
}
extern "system" fn CmdDraw_panic(_commandBuffer: CommandBuffer, _vertexCount: u32, _instanceCount: u32, _firstVertex: u32, _firstInstance: u32){
    panic!("extension vkCmdDraw not loaded")
}
extern "system" fn CmdDrawIndexed_panic(_commandBuffer: CommandBuffer, _indexCount: u32, _instanceCount: u32, _firstIndex: u32, _vertexOffset: i32, _firstInstance: u32){
    panic!("extension vkCmdDrawIndexed not loaded")
}
extern "system" fn CmdDrawIndirect_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _drawCount: u32, _stride: u32){
    panic!("extension vkCmdDrawIndirect not loaded")
}
extern "system" fn CmdDrawIndexedIndirect_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _drawCount: u32, _stride: u32){
    panic!("extension vkCmdDrawIndexedIndirect not loaded")
}
extern "system" fn CmdDispatch_panic(_commandBuffer: CommandBuffer, _groupCountX: u32, _groupCountY: u32, _groupCountZ: u32){
    panic!("extension vkCmdDispatch not loaded")
}
extern "system" fn CmdDispatchIndirect_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize){
    panic!("extension vkCmdDispatchIndirect not loaded")
}
extern "system" fn CmdCopyBuffer_panic(_commandBuffer: CommandBuffer, _srcBuffer: Buffer, _dstBuffer: Buffer, _regionCount: u32, _pRegions: *const BufferCopy){
    panic!("extension vkCmdCopyBuffer not loaded")
}
extern "system" fn CmdCopyImage_panic(_commandBuffer: CommandBuffer, _srcImage: Image, _srcImageLayout: ImageLayout, _dstImage: Image, _dstImageLayout: ImageLayout, _regionCount: u32, _pRegions: *const ImageCopy){
    panic!("extension vkCmdCopyImage not loaded")
}
extern "system" fn CmdBlitImage_panic(_commandBuffer: CommandBuffer, _srcImage: Image, _srcImageLayout: ImageLayout, _dstImage: Image, _dstImageLayout: ImageLayout, _regionCount: u32, _pRegions: *const ImageBlit, _filter: Filter){
    panic!("extension vkCmdBlitImage not loaded")
}
extern "system" fn CmdCopyBufferToImage_panic(_commandBuffer: CommandBuffer, _srcBuffer: Buffer, _dstImage: Image, _dstImageLayout: ImageLayout, _regionCount: u32, _pRegions: *const BufferImageCopy){
    panic!("extension vkCmdCopyBufferToImage not loaded")
}
extern "system" fn CmdCopyImageToBuffer_panic(_commandBuffer: CommandBuffer, _srcImage: Image, _srcImageLayout: ImageLayout, _dstBuffer: Buffer, _regionCount: u32, _pRegions: *const BufferImageCopy){
    panic!("extension vkCmdCopyImageToBuffer not loaded")
}
extern "system" fn CmdUpdateBuffer_panic(_commandBuffer: CommandBuffer, _dstBuffer: Buffer, _dstOffset: DeviceSize, _dataSize: DeviceSize, _pData: *const c_void){
    panic!("extension vkCmdUpdateBuffer not loaded")
}
extern "system" fn CmdFillBuffer_panic(_commandBuffer: CommandBuffer, _dstBuffer: Buffer, _dstOffset: DeviceSize, _size: DeviceSize, _data: u32){
    panic!("extension vkCmdFillBuffer not loaded")
}
extern "system" fn CmdClearColorImage_panic(_commandBuffer: CommandBuffer, _image: Image, _imageLayout: ImageLayout, _pColor: *const ClearColorValue, _rangeCount: u32, _pRanges: *const ImageSubresourceRange){
    panic!("extension vkCmdClearColorImage not loaded")
}
extern "system" fn CmdClearDepthStencilImage_panic(_commandBuffer: CommandBuffer, _image: Image, _imageLayout: ImageLayout, _pDepthStencil: *const ClearDepthStencilValue, _rangeCount: u32, _pRanges: *const ImageSubresourceRange){
    panic!("extension vkCmdClearDepthStencilImage not loaded")
}
extern "system" fn CmdClearAttachments_panic(_commandBuffer: CommandBuffer, _attachmentCount: u32, _pAttachments: *const ClearAttachment, _rectCount: u32, _pRects: *const ClearRect){
    panic!("extension vkCmdClearAttachments not loaded")
}
extern "system" fn CmdResolveImage_panic(_commandBuffer: CommandBuffer, _srcImage: Image, _srcImageLayout: ImageLayout, _dstImage: Image, _dstImageLayout: ImageLayout, _regionCount: u32, _pRegions: *const ImageResolve){
    panic!("extension vkCmdResolveImage not loaded")
}
extern "system" fn CmdSetEvent_panic(_commandBuffer: CommandBuffer, _event: Event, _stageMask: PipelineStageFlags){
    panic!("extension vkCmdSetEvent not loaded")
}
extern "system" fn CmdResetEvent_panic(_commandBuffer: CommandBuffer, _event: Event, _stageMask: PipelineStageFlags){
    panic!("extension vkCmdResetEvent not loaded")
}
extern "system" fn CmdWaitEvents_panic(_commandBuffer: CommandBuffer, _eventCount: u32, _pEvents: *const Event, _srcStageMask: PipelineStageFlags, _dstStageMask: PipelineStageFlags, _memoryBarrierCount: u32, _pMemoryBarriers: *const MemoryBarrier, _bufferMemoryBarrierCount: u32, _pBufferMemoryBarriers: *const BufferMemoryBarrier, _imageMemoryBarrierCount: u32, _pImageMemoryBarriers: *const ImageMemoryBarrier){
    panic!("extension vkCmdWaitEvents not loaded")
}
extern "system" fn CmdPipelineBarrier_panic(_commandBuffer: CommandBuffer, _srcStageMask: PipelineStageFlags, _dstStageMask: PipelineStageFlags, _dependencyFlags: DependencyFlags, _memoryBarrierCount: u32, _pMemoryBarriers: *const MemoryBarrier, _bufferMemoryBarrierCount: u32, _pBufferMemoryBarriers: *const BufferMemoryBarrier, _imageMemoryBarrierCount: u32, _pImageMemoryBarriers: *const ImageMemoryBarrier){
    panic!("extension vkCmdPipelineBarrier not loaded")
}
extern "system" fn CmdBeginQuery_panic(_commandBuffer: CommandBuffer, _queryPool: QueryPool, _query: u32, _flags: QueryControlFlags){
    panic!("extension vkCmdBeginQuery not loaded")
}
extern "system" fn CmdEndQuery_panic(_commandBuffer: CommandBuffer, _queryPool: QueryPool, _query: u32){
    panic!("extension vkCmdEndQuery not loaded")
}
extern "system" fn CmdResetQueryPool_panic(_commandBuffer: CommandBuffer, _queryPool: QueryPool, _firstQuery: u32, _queryCount: u32){
    panic!("extension vkCmdResetQueryPool not loaded")
}
extern "system" fn CmdWriteTimestamp_panic(_commandBuffer: CommandBuffer, _pipelineStage: PipelineStageFlagBits, _queryPool: QueryPool, _query: u32){
    panic!("extension vkCmdWriteTimestamp not loaded")
}
extern "system" fn CmdCopyQueryPoolResults_panic(_commandBuffer: CommandBuffer, _queryPool: QueryPool, _firstQuery: u32, _queryCount: u32, _dstBuffer: Buffer, _dstOffset: DeviceSize, _stride: DeviceSize, _flags: QueryResultFlags){
    panic!("extension vkCmdCopyQueryPoolResults not loaded")
}
extern "system" fn CmdPushConstants_panic(_commandBuffer: CommandBuffer, _layout: PipelineLayout, _stageFlags: ShaderStageFlags, _offset: u32, _size: u32, _pValues: *const c_void){
    panic!("extension vkCmdPushConstants not loaded")
}
extern "system" fn CmdBeginRenderPass_panic(_commandBuffer: CommandBuffer, _pRenderPassBegin: *const RenderPassBeginInfo, _contents: SubpassContents){
    panic!("extension vkCmdBeginRenderPass not loaded")
}
extern "system" fn CmdNextSubpass_panic(_commandBuffer: CommandBuffer, _contents: SubpassContents){
    panic!("extension vkCmdNextSubpass not loaded")
}
extern "system" fn CmdEndRenderPass_panic(_commandBuffer: CommandBuffer){
    panic!("extension vkCmdEndRenderPass not loaded")
}
extern "system" fn CmdExecuteCommands_panic(_commandBuffer: CommandBuffer, _commandBufferCount: u32, _pCommandBuffers: *const CommandBuffer){
    panic!("extension vkCmdExecuteCommands not loaded")
}
extern "system" fn EnumerateInstanceVersion_panic(_pApiVersion: *mut u32) -> Result{
    panic!("extension vkEnumerateInstanceVersion not loaded")
}
extern "system" fn BindBufferMemory2_panic(_device: Device, _bindInfoCount: u32, _pBindInfos: *const BindBufferMemoryInfo) -> Result{
    panic!("extension vkBindBufferMemory2 not loaded")
}
extern "system" fn BindImageMemory2_panic(_device: Device, _bindInfoCount: u32, _pBindInfos: *const BindImageMemoryInfo) -> Result{
    panic!("extension vkBindImageMemory2 not loaded")
}
extern "system" fn GetDeviceGroupPeerMemoryFeatures_panic(_device: Device, _heapIndex: u32, _localDeviceIndex: u32, _remoteDeviceIndex: u32, _pPeerMemoryFeatures: *mut PeerMemoryFeatureFlags){
    panic!("extension vkGetDeviceGroupPeerMemoryFeatures not loaded")
}
extern "system" fn CmdSetDeviceMask_panic(_commandBuffer: CommandBuffer, _deviceMask: u32){
    panic!("extension vkCmdSetDeviceMask not loaded")
}
extern "system" fn CmdDispatchBase_panic(_commandBuffer: CommandBuffer, _baseGroupX: u32, _baseGroupY: u32, _baseGroupZ: u32, _groupCountX: u32, _groupCountY: u32, _groupCountZ: u32){
    panic!("extension vkCmdDispatchBase not loaded")
}
extern "system" fn EnumeratePhysicalDeviceGroups_panic(_instance: Instance, _pPhysicalDeviceGroupCount: *mut u32, _pPhysicalDeviceGroupProperties: *mut PhysicalDeviceGroupProperties) -> Result{
    panic!("extension vkEnumeratePhysicalDeviceGroups not loaded")
}
extern "system" fn GetImageMemoryRequirements2_panic(_device: Device, _pInfo: *const ImageMemoryRequirementsInfo2, _pMemoryRequirements: *mut MemoryRequirements2){
    panic!("extension vkGetImageMemoryRequirements2 not loaded")
}
extern "system" fn GetBufferMemoryRequirements2_panic(_device: Device, _pInfo: *const BufferMemoryRequirementsInfo2, _pMemoryRequirements: *mut MemoryRequirements2){
    panic!("extension vkGetBufferMemoryRequirements2 not loaded")
}
extern "system" fn GetImageSparseMemoryRequirements2_panic(_device: Device, _pInfo: *const ImageSparseMemoryRequirementsInfo2, _pSparseMemoryRequirementCount: *mut u32, _pSparseMemoryRequirements: *mut SparseImageMemoryRequirements2){
    panic!("extension vkGetImageSparseMemoryRequirements2 not loaded")
}
extern "system" fn GetPhysicalDeviceFeatures2_panic(_physicalDevice: PhysicalDevice, _pFeatures: *mut PhysicalDeviceFeatures2){
    panic!("extension vkGetPhysicalDeviceFeatures2 not loaded")
}
extern "system" fn GetPhysicalDeviceProperties2_panic(_physicalDevice: PhysicalDevice, _pProperties: *mut PhysicalDeviceProperties2){
    panic!("extension vkGetPhysicalDeviceProperties2 not loaded")
}
extern "system" fn GetPhysicalDeviceFormatProperties2_panic(_physicalDevice: PhysicalDevice, _format: Format, _pFormatProperties: *mut FormatProperties2){
    panic!("extension vkGetPhysicalDeviceFormatProperties2 not loaded")
}
extern "system" fn GetPhysicalDeviceImageFormatProperties2_panic(_physicalDevice: PhysicalDevice, _pImageFormatInfo: *const PhysicalDeviceImageFormatInfo2, _pImageFormatProperties: *mut ImageFormatProperties2) -> Result{
    panic!("extension vkGetPhysicalDeviceImageFormatProperties2 not loaded")
}
extern "system" fn GetPhysicalDeviceQueueFamilyProperties2_panic(_physicalDevice: PhysicalDevice, _pQueueFamilyPropertyCount: *mut u32, _pQueueFamilyProperties: *mut QueueFamilyProperties2){
    panic!("extension vkGetPhysicalDeviceQueueFamilyProperties2 not loaded")
}
extern "system" fn GetPhysicalDeviceMemoryProperties2_panic(_physicalDevice: PhysicalDevice, _pMemoryProperties: *mut PhysicalDeviceMemoryProperties2){
    panic!("extension vkGetPhysicalDeviceMemoryProperties2 not loaded")
}
extern "system" fn GetPhysicalDeviceSparseImageFormatProperties2_panic(_physicalDevice: PhysicalDevice, _pFormatInfo: *const PhysicalDeviceSparseImageFormatInfo2, _pPropertyCount: *mut u32, _pProperties: *mut SparseImageFormatProperties2){
    panic!("extension vkGetPhysicalDeviceSparseImageFormatProperties2 not loaded")
}
extern "system" fn TrimCommandPool_panic(_device: Device, _commandPool: CommandPool, _flags: CommandPoolTrimFlags){
    panic!("extension vkTrimCommandPool not loaded")
}
extern "system" fn GetDeviceQueue2_panic(_device: Device, _pQueueInfo: *const DeviceQueueInfo2, _pQueue: *mut Queue){
    panic!("extension vkGetDeviceQueue2 not loaded")
}
extern "system" fn CreateSamplerYcbcrConversion_panic(_device: Device, _pCreateInfo: *const SamplerYcbcrConversionCreateInfo, _pAllocator: *const AllocationCallbacks, _pYcbcrConversion: *mut SamplerYcbcrConversion) -> Result{
    panic!("extension vkCreateSamplerYcbcrConversion not loaded")
}
extern "system" fn DestroySamplerYcbcrConversion_panic(_device: Device, _ycbcrConversion: SamplerYcbcrConversion, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroySamplerYcbcrConversion not loaded")
}
extern "system" fn CreateDescriptorUpdateTemplate_panic(_device: Device, _pCreateInfo: *const DescriptorUpdateTemplateCreateInfo, _pAllocator: *const AllocationCallbacks, _pDescriptorUpdateTemplate: *mut DescriptorUpdateTemplate) -> Result{
    panic!("extension vkCreateDescriptorUpdateTemplate not loaded")
}
extern "system" fn DestroyDescriptorUpdateTemplate_panic(_device: Device, _descriptorUpdateTemplate: DescriptorUpdateTemplate, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyDescriptorUpdateTemplate not loaded")
}
extern "system" fn UpdateDescriptorSetWithTemplate_panic(_device: Device, _descriptorSet: DescriptorSet, _descriptorUpdateTemplate: DescriptorUpdateTemplate, _pData: *const c_void){
    panic!("extension vkUpdateDescriptorSetWithTemplate not loaded")
}
extern "system" fn GetPhysicalDeviceExternalBufferProperties_panic(_physicalDevice: PhysicalDevice, _pExternalBufferInfo: *const PhysicalDeviceExternalBufferInfo, _pExternalBufferProperties: *mut ExternalBufferProperties){
    panic!("extension vkGetPhysicalDeviceExternalBufferProperties not loaded")
}
extern "system" fn GetPhysicalDeviceExternalFenceProperties_panic(_physicalDevice: PhysicalDevice, _pExternalFenceInfo: *const PhysicalDeviceExternalFenceInfo, _pExternalFenceProperties: *mut ExternalFenceProperties){
    panic!("extension vkGetPhysicalDeviceExternalFenceProperties not loaded")
}
extern "system" fn GetPhysicalDeviceExternalSemaphoreProperties_panic(_physicalDevice: PhysicalDevice, _pExternalSemaphoreInfo: *const PhysicalDeviceExternalSemaphoreInfo, _pExternalSemaphoreProperties: *mut ExternalSemaphoreProperties){
    panic!("extension vkGetPhysicalDeviceExternalSemaphoreProperties not loaded")
}
extern "system" fn GetDescriptorSetLayoutSupport_panic(_device: Device, _pCreateInfo: *const DescriptorSetLayoutCreateInfo, _pSupport: *mut DescriptorSetLayoutSupport){
    panic!("extension vkGetDescriptorSetLayoutSupport not loaded")
}


impl Default for Core {
  /// Initializes all function pointers to functions that immediately panic.
  fn default() -> Core {
    Core {
      lib: shared_library::dynamic_library::DynamicLibrary::open(None).expect("can not open library"),
      feature: 0,
      CreateInstance_ptr: CreateInstance_panic,
      DestroyInstance_ptr: DestroyInstance_panic,
      EnumeratePhysicalDevices_ptr: EnumeratePhysicalDevices_panic,
      GetPhysicalDeviceFeatures_ptr: GetPhysicalDeviceFeatures_panic,
      GetPhysicalDeviceFormatProperties_ptr: GetPhysicalDeviceFormatProperties_panic,
      GetPhysicalDeviceImageFormatProperties_ptr: GetPhysicalDeviceImageFormatProperties_panic,
      GetPhysicalDeviceProperties_ptr: GetPhysicalDeviceProperties_panic,
      GetPhysicalDeviceQueueFamilyProperties_ptr: GetPhysicalDeviceQueueFamilyProperties_panic,
      GetPhysicalDeviceMemoryProperties_ptr: GetPhysicalDeviceMemoryProperties_panic,
      GetInstanceProcAddr_ptr: GetInstanceProcAddr_panic,
      GetDeviceProcAddr_ptr: GetDeviceProcAddr_panic,
      CreateDevice_ptr: CreateDevice_panic,
      DestroyDevice_ptr: DestroyDevice_panic,
      EnumerateInstanceExtensionProperties_ptr: EnumerateInstanceExtensionProperties_panic,
      EnumerateDeviceExtensionProperties_ptr: EnumerateDeviceExtensionProperties_panic,
      EnumerateInstanceLayerProperties_ptr: EnumerateInstanceLayerProperties_panic,
      EnumerateDeviceLayerProperties_ptr: EnumerateDeviceLayerProperties_panic,
      GetDeviceQueue_ptr: GetDeviceQueue_panic,
      QueueSubmit_ptr: QueueSubmit_panic,
      QueueWaitIdle_ptr: QueueWaitIdle_panic,
      DeviceWaitIdle_ptr: DeviceWaitIdle_panic,
      AllocateMemory_ptr: AllocateMemory_panic,
      FreeMemory_ptr: FreeMemory_panic,
      MapMemory_ptr: MapMemory_panic,
      UnmapMemory_ptr: UnmapMemory_panic,
      FlushMappedMemoryRanges_ptr: FlushMappedMemoryRanges_panic,
      InvalidateMappedMemoryRanges_ptr: InvalidateMappedMemoryRanges_panic,
      GetDeviceMemoryCommitment_ptr: GetDeviceMemoryCommitment_panic,
      BindBufferMemory_ptr: BindBufferMemory_panic,
      BindImageMemory_ptr: BindImageMemory_panic,
      GetBufferMemoryRequirements_ptr: GetBufferMemoryRequirements_panic,
      GetImageMemoryRequirements_ptr: GetImageMemoryRequirements_panic,
      GetImageSparseMemoryRequirements_ptr: GetImageSparseMemoryRequirements_panic,
      GetPhysicalDeviceSparseImageFormatProperties_ptr: GetPhysicalDeviceSparseImageFormatProperties_panic,
      QueueBindSparse_ptr: QueueBindSparse_panic,
      CreateFence_ptr: CreateFence_panic,
      DestroyFence_ptr: DestroyFence_panic,
      ResetFences_ptr: ResetFences_panic,
      GetFenceStatus_ptr: GetFenceStatus_panic,
      WaitForFences_ptr: WaitForFences_panic,
      CreateSemaphore_ptr: CreateSemaphore_panic,
      DestroySemaphore_ptr: DestroySemaphore_panic,
      CreateEvent_ptr: CreateEvent_panic,
      DestroyEvent_ptr: DestroyEvent_panic,
      GetEventStatus_ptr: GetEventStatus_panic,
      SetEvent_ptr: SetEvent_panic,
      ResetEvent_ptr: ResetEvent_panic,
      CreateQueryPool_ptr: CreateQueryPool_panic,
      DestroyQueryPool_ptr: DestroyQueryPool_panic,
      GetQueryPoolResults_ptr: GetQueryPoolResults_panic,
      CreateBuffer_ptr: CreateBuffer_panic,
      DestroyBuffer_ptr: DestroyBuffer_panic,
      CreateBufferView_ptr: CreateBufferView_panic,
      DestroyBufferView_ptr: DestroyBufferView_panic,
      CreateImage_ptr: CreateImage_panic,
      DestroyImage_ptr: DestroyImage_panic,
      GetImageSubresourceLayout_ptr: GetImageSubresourceLayout_panic,
      CreateImageView_ptr: CreateImageView_panic,
      DestroyImageView_ptr: DestroyImageView_panic,
      CreateShaderModule_ptr: CreateShaderModule_panic,
      DestroyShaderModule_ptr: DestroyShaderModule_panic,
      CreatePipelineCache_ptr: CreatePipelineCache_panic,
      DestroyPipelineCache_ptr: DestroyPipelineCache_panic,
      GetPipelineCacheData_ptr: GetPipelineCacheData_panic,
      MergePipelineCaches_ptr: MergePipelineCaches_panic,
      CreateGraphicsPipelines_ptr: CreateGraphicsPipelines_panic,
      CreateComputePipelines_ptr: CreateComputePipelines_panic,
      DestroyPipeline_ptr: DestroyPipeline_panic,
      CreatePipelineLayout_ptr: CreatePipelineLayout_panic,
      DestroyPipelineLayout_ptr: DestroyPipelineLayout_panic,
      CreateSampler_ptr: CreateSampler_panic,
      DestroySampler_ptr: DestroySampler_panic,
      CreateDescriptorSetLayout_ptr: CreateDescriptorSetLayout_panic,
      DestroyDescriptorSetLayout_ptr: DestroyDescriptorSetLayout_panic,
      CreateDescriptorPool_ptr: CreateDescriptorPool_panic,
      DestroyDescriptorPool_ptr: DestroyDescriptorPool_panic,
      ResetDescriptorPool_ptr: ResetDescriptorPool_panic,
      AllocateDescriptorSets_ptr: AllocateDescriptorSets_panic,
      FreeDescriptorSets_ptr: FreeDescriptorSets_panic,
      UpdateDescriptorSets_ptr: UpdateDescriptorSets_panic,
      CreateFramebuffer_ptr: CreateFramebuffer_panic,
      DestroyFramebuffer_ptr: DestroyFramebuffer_panic,
      CreateRenderPass_ptr: CreateRenderPass_panic,
      DestroyRenderPass_ptr: DestroyRenderPass_panic,
      GetRenderAreaGranularity_ptr: GetRenderAreaGranularity_panic,
      CreateCommandPool_ptr: CreateCommandPool_panic,
      DestroyCommandPool_ptr: DestroyCommandPool_panic,
      ResetCommandPool_ptr: ResetCommandPool_panic,
      AllocateCommandBuffers_ptr: AllocateCommandBuffers_panic,
      FreeCommandBuffers_ptr: FreeCommandBuffers_panic,
      BeginCommandBuffer_ptr: BeginCommandBuffer_panic,
      EndCommandBuffer_ptr: EndCommandBuffer_panic,
      ResetCommandBuffer_ptr: ResetCommandBuffer_panic,
      CmdBindPipeline_ptr: CmdBindPipeline_panic,
      CmdSetViewport_ptr: CmdSetViewport_panic,
      CmdSetScissor_ptr: CmdSetScissor_panic,
      CmdSetLineWidth_ptr: CmdSetLineWidth_panic,
      CmdSetDepthBias_ptr: CmdSetDepthBias_panic,
      CmdSetBlendConstants_ptr: CmdSetBlendConstants_panic,
      CmdSetDepthBounds_ptr: CmdSetDepthBounds_panic,
      CmdSetStencilCompareMask_ptr: CmdSetStencilCompareMask_panic,
      CmdSetStencilWriteMask_ptr: CmdSetStencilWriteMask_panic,
      CmdSetStencilReference_ptr: CmdSetStencilReference_panic,
      CmdBindDescriptorSets_ptr: CmdBindDescriptorSets_panic,
      CmdBindIndexBuffer_ptr: CmdBindIndexBuffer_panic,
      CmdBindVertexBuffers_ptr: CmdBindVertexBuffers_panic,
      CmdDraw_ptr: CmdDraw_panic,
      CmdDrawIndexed_ptr: CmdDrawIndexed_panic,
      CmdDrawIndirect_ptr: CmdDrawIndirect_panic,
      CmdDrawIndexedIndirect_ptr: CmdDrawIndexedIndirect_panic,
      CmdDispatch_ptr: CmdDispatch_panic,
      CmdDispatchIndirect_ptr: CmdDispatchIndirect_panic,
      CmdCopyBuffer_ptr: CmdCopyBuffer_panic,
      CmdCopyImage_ptr: CmdCopyImage_panic,
      CmdBlitImage_ptr: CmdBlitImage_panic,
      CmdCopyBufferToImage_ptr: CmdCopyBufferToImage_panic,
      CmdCopyImageToBuffer_ptr: CmdCopyImageToBuffer_panic,
      CmdUpdateBuffer_ptr: CmdUpdateBuffer_panic,
      CmdFillBuffer_ptr: CmdFillBuffer_panic,
      CmdClearColorImage_ptr: CmdClearColorImage_panic,
      CmdClearDepthStencilImage_ptr: CmdClearDepthStencilImage_panic,
      CmdClearAttachments_ptr: CmdClearAttachments_panic,
      CmdResolveImage_ptr: CmdResolveImage_panic,
      CmdSetEvent_ptr: CmdSetEvent_panic,
      CmdResetEvent_ptr: CmdResetEvent_panic,
      CmdWaitEvents_ptr: CmdWaitEvents_panic,
      CmdPipelineBarrier_ptr: CmdPipelineBarrier_panic,
      CmdBeginQuery_ptr: CmdBeginQuery_panic,
      CmdEndQuery_ptr: CmdEndQuery_panic,
      CmdResetQueryPool_ptr: CmdResetQueryPool_panic,
      CmdWriteTimestamp_ptr: CmdWriteTimestamp_panic,
      CmdCopyQueryPoolResults_ptr: CmdCopyQueryPoolResults_panic,
      CmdPushConstants_ptr: CmdPushConstants_panic,
      CmdBeginRenderPass_ptr: CmdBeginRenderPass_panic,
      CmdNextSubpass_ptr: CmdNextSubpass_panic,
      CmdEndRenderPass_ptr: CmdEndRenderPass_panic,
      CmdExecuteCommands_ptr: CmdExecuteCommands_panic,
      EnumerateInstanceVersion_ptr: EnumerateInstanceVersion_panic,
      BindBufferMemory2_ptr: BindBufferMemory2_panic,
      BindImageMemory2_ptr: BindImageMemory2_panic,
      GetDeviceGroupPeerMemoryFeatures_ptr: GetDeviceGroupPeerMemoryFeatures_panic,
      CmdSetDeviceMask_ptr: CmdSetDeviceMask_panic,
      CmdDispatchBase_ptr: CmdDispatchBase_panic,
      EnumeratePhysicalDeviceGroups_ptr: EnumeratePhysicalDeviceGroups_panic,
      GetImageMemoryRequirements2_ptr: GetImageMemoryRequirements2_panic,
      GetBufferMemoryRequirements2_ptr: GetBufferMemoryRequirements2_panic,
      GetImageSparseMemoryRequirements2_ptr: GetImageSparseMemoryRequirements2_panic,
      GetPhysicalDeviceFeatures2_ptr: GetPhysicalDeviceFeatures2_panic,
      GetPhysicalDeviceProperties2_ptr: GetPhysicalDeviceProperties2_panic,
      GetPhysicalDeviceFormatProperties2_ptr: GetPhysicalDeviceFormatProperties2_panic,
      GetPhysicalDeviceImageFormatProperties2_ptr: GetPhysicalDeviceImageFormatProperties2_panic,
      GetPhysicalDeviceQueueFamilyProperties2_ptr: GetPhysicalDeviceQueueFamilyProperties2_panic,
      GetPhysicalDeviceMemoryProperties2_ptr: GetPhysicalDeviceMemoryProperties2_panic,
      GetPhysicalDeviceSparseImageFormatProperties2_ptr: GetPhysicalDeviceSparseImageFormatProperties2_panic,
      TrimCommandPool_ptr: TrimCommandPool_panic,
      GetDeviceQueue2_ptr: GetDeviceQueue2_panic,
      CreateSamplerYcbcrConversion_ptr: CreateSamplerYcbcrConversion_panic,
      DestroySamplerYcbcrConversion_ptr: DestroySamplerYcbcrConversion_panic,
      CreateDescriptorUpdateTemplate_ptr: CreateDescriptorUpdateTemplate_panic,
      DestroyDescriptorUpdateTemplate_ptr: DestroyDescriptorUpdateTemplate_panic,
      UpdateDescriptorSetWithTemplate_ptr: UpdateDescriptorSetWithTemplate_panic,
      GetPhysicalDeviceExternalBufferProperties_ptr: GetPhysicalDeviceExternalBufferProperties_panic,
      GetPhysicalDeviceExternalFenceProperties_ptr: GetPhysicalDeviceExternalFenceProperties_panic,
      GetPhysicalDeviceExternalSemaphoreProperties_ptr: GetPhysicalDeviceExternalSemaphoreProperties_panic,
      GetDescriptorSetLayoutSupport_ptr: GetDescriptorSetLayoutSupport_panic,
    }
  }
}


impl Core {
  /// Initialized core commands for the newest available vulkan version
  /// 
  /// ```
  /// let vk_lib = nobs_vk::Core::new();
  /// ```
  /// is the same as
  /// ```
  /// let vk_lib = nobs_vk::Core::with_feature(nobs_vk::VERSION_1_1);
  /// ```
  pub fn new() -> std::boxed::Box<Core> {
    Self::with_feature(VERSION_1_1)
  }
  /// Initialized core commands for the specified vulkan feature
  /// 
  /// Select a feature either with the predefined constants `VERSION_x_x`,
  /// or use the [make_version](macro.make_version.html) macro
  pub fn with_feature(feature: u32) -> std::boxed::Box<Core> {
    #[cfg(windows)]
    fn open_lib() -> shared_library::dynamic_library::DynamicLibrary {
      shared_library::dynamic_library::DynamicLibrary::open(Some(std::path::Path::new("vulkan-1.dll"))).expect("vulkan not found");
    }
    #[cfg(all(unix, not(target_os = "android"), not(target_os = "macos")))]
    fn open_lib() -> shared_library::dynamic_library::DynamicLibrary {
      shared_library::dynamic_library::DynamicLibrary::open(Some(std::path::Path::new("libvulkan.so"))).expect("vulkan not found")
    }
    #[cfg(target_os = "macos")]
    fn open_lib() -> shared_library::dynamic_library::DynamicLibrary {
      shared_library::dynamic_library::DynamicLibrary::open(Some(std::path::Path::new("libvulkan.1.dylib"))).expect("vulkan not found")
    }
    let vk_dl = open_lib();

    unsafe { 
        let CreateInstance_ptr = if feature < VERSION_1_0 {
          CreateInstance_panic as extern "system" fn (pCreateInfo: *const InstanceCreateInfo, pAllocator: *const AllocationCallbacks, pInstance: *mut Instance) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateInstance").expect("could not find symbol for vkCreateInstance"))
        };
        let DestroyInstance_ptr = if feature < VERSION_1_0 {
          DestroyInstance_panic as extern "system" fn (instance: Instance, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyInstance").expect("could not find symbol for vkDestroyInstance"))
        };
        let EnumeratePhysicalDevices_ptr = if feature < VERSION_1_0 {
          EnumeratePhysicalDevices_panic as extern "system" fn (instance: Instance, pPhysicalDeviceCount: *mut u32, pPhysicalDevices: *mut PhysicalDevice) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkEnumeratePhysicalDevices").expect("could not find symbol for vkEnumeratePhysicalDevices"))
        };
        let GetPhysicalDeviceFeatures_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceFeatures_panic as extern "system" fn (physicalDevice: PhysicalDevice, pFeatures: *mut PhysicalDeviceFeatures)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceFeatures").expect("could not find symbol for vkGetPhysicalDeviceFeatures"))
        };
        let GetPhysicalDeviceFormatProperties_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceFormatProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *mut FormatProperties)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceFormatProperties").expect("could not find symbol for vkGetPhysicalDeviceFormatProperties"))
        };
        let GetPhysicalDeviceImageFormatProperties_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceImageFormatProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, format: Format, typ: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, pImageFormatProperties: *mut ImageFormatProperties) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceImageFormatProperties").expect("could not find symbol for vkGetPhysicalDeviceImageFormatProperties"))
        };
        let GetPhysicalDeviceProperties_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, pProperties: *mut PhysicalDeviceProperties)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceProperties").expect("could not find symbol for vkGetPhysicalDeviceProperties"))
        };
        let GetPhysicalDeviceQueueFamilyProperties_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceQueueFamilyProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut QueueFamilyProperties)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceQueueFamilyProperties").expect("could not find symbol for vkGetPhysicalDeviceQueueFamilyProperties"))
        };
        let GetPhysicalDeviceMemoryProperties_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceMemoryProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, pMemoryProperties: *mut PhysicalDeviceMemoryProperties)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceMemoryProperties").expect("could not find symbol for vkGetPhysicalDeviceMemoryProperties"))
        };
        let GetInstanceProcAddr_ptr = if feature < VERSION_1_0 {
          GetInstanceProcAddr_panic as extern "system" fn (instance: Instance, pName: *const c_char) -> PFN_vkVoidFunction
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetInstanceProcAddr").expect("could not find symbol for vkGetInstanceProcAddr"))
        };
        let GetDeviceProcAddr_ptr = if feature < VERSION_1_0 {
          GetDeviceProcAddr_panic as extern "system" fn (device: Device, pName: *const c_char) -> PFN_vkVoidFunction
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetDeviceProcAddr").expect("could not find symbol for vkGetDeviceProcAddr"))
        };
        let CreateDevice_ptr = if feature < VERSION_1_0 {
          CreateDevice_panic as extern "system" fn (physicalDevice: PhysicalDevice, pCreateInfo: *const DeviceCreateInfo, pAllocator: *const AllocationCallbacks, pDevice: *mut Device) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateDevice").expect("could not find symbol for vkCreateDevice"))
        };
        let DestroyDevice_ptr = if feature < VERSION_1_0 {
          DestroyDevice_panic as extern "system" fn (device: Device, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyDevice").expect("could not find symbol for vkDestroyDevice"))
        };
        let EnumerateInstanceExtensionProperties_ptr = if feature < VERSION_1_0 {
          EnumerateInstanceExtensionProperties_panic as extern "system" fn (pLayerName: *const c_char, pPropertyCount: *mut u32, pProperties: *mut ExtensionProperties) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkEnumerateInstanceExtensionProperties").expect("could not find symbol for vkEnumerateInstanceExtensionProperties"))
        };
        let EnumerateDeviceExtensionProperties_ptr = if feature < VERSION_1_0 {
          EnumerateDeviceExtensionProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, pLayerName: *const c_char, pPropertyCount: *mut u32, pProperties: *mut ExtensionProperties) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkEnumerateDeviceExtensionProperties").expect("could not find symbol for vkEnumerateDeviceExtensionProperties"))
        };
        let EnumerateInstanceLayerProperties_ptr = if feature < VERSION_1_0 {
          EnumerateInstanceLayerProperties_panic as extern "system" fn (pPropertyCount: *mut u32, pProperties: *mut LayerProperties) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkEnumerateInstanceLayerProperties").expect("could not find symbol for vkEnumerateInstanceLayerProperties"))
        };
        let EnumerateDeviceLayerProperties_ptr = if feature < VERSION_1_0 {
          EnumerateDeviceLayerProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut LayerProperties) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkEnumerateDeviceLayerProperties").expect("could not find symbol for vkEnumerateDeviceLayerProperties"))
        };
        let GetDeviceQueue_ptr = if feature < VERSION_1_0 {
          GetDeviceQueue_panic as extern "system" fn (device: Device, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut Queue)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetDeviceQueue").expect("could not find symbol for vkGetDeviceQueue"))
        };
        let QueueSubmit_ptr = if feature < VERSION_1_0 {
          QueueSubmit_panic as extern "system" fn (queue: Queue, submitCount: u32, pSubmits: *const SubmitInfo, fence: Fence) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkQueueSubmit").expect("could not find symbol for vkQueueSubmit"))
        };
        let QueueWaitIdle_ptr = if feature < VERSION_1_0 {
          QueueWaitIdle_panic as extern "system" fn (queue: Queue) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkQueueWaitIdle").expect("could not find symbol for vkQueueWaitIdle"))
        };
        let DeviceWaitIdle_ptr = if feature < VERSION_1_0 {
          DeviceWaitIdle_panic as extern "system" fn (device: Device) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDeviceWaitIdle").expect("could not find symbol for vkDeviceWaitIdle"))
        };
        let AllocateMemory_ptr = if feature < VERSION_1_0 {
          AllocateMemory_panic as extern "system" fn (device: Device, pAllocateInfo: *const MemoryAllocateInfo, pAllocator: *const AllocationCallbacks, pMemory: *mut DeviceMemory) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkAllocateMemory").expect("could not find symbol for vkAllocateMemory"))
        };
        let FreeMemory_ptr = if feature < VERSION_1_0 {
          FreeMemory_panic as extern "system" fn (device: Device, memory: DeviceMemory, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkFreeMemory").expect("could not find symbol for vkFreeMemory"))
        };
        let MapMemory_ptr = if feature < VERSION_1_0 {
          MapMemory_panic as extern "system" fn (device: Device, memory: DeviceMemory, offset: DeviceSize, size: DeviceSize, flags: MemoryMapFlags, ppData: *mut *mut c_void) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkMapMemory").expect("could not find symbol for vkMapMemory"))
        };
        let UnmapMemory_ptr = if feature < VERSION_1_0 {
          UnmapMemory_panic as extern "system" fn (device: Device, memory: DeviceMemory)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkUnmapMemory").expect("could not find symbol for vkUnmapMemory"))
        };
        let FlushMappedMemoryRanges_ptr = if feature < VERSION_1_0 {
          FlushMappedMemoryRanges_panic as extern "system" fn (device: Device, memoryRangeCount: u32, pMemoryRanges: *const MappedMemoryRange) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkFlushMappedMemoryRanges").expect("could not find symbol for vkFlushMappedMemoryRanges"))
        };
        let InvalidateMappedMemoryRanges_ptr = if feature < VERSION_1_0 {
          InvalidateMappedMemoryRanges_panic as extern "system" fn (device: Device, memoryRangeCount: u32, pMemoryRanges: *const MappedMemoryRange) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkInvalidateMappedMemoryRanges").expect("could not find symbol for vkInvalidateMappedMemoryRanges"))
        };
        let GetDeviceMemoryCommitment_ptr = if feature < VERSION_1_0 {
          GetDeviceMemoryCommitment_panic as extern "system" fn (device: Device, memory: DeviceMemory, pCommittedMemoryInBytes: *mut DeviceSize)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetDeviceMemoryCommitment").expect("could not find symbol for vkGetDeviceMemoryCommitment"))
        };
        let BindBufferMemory_ptr = if feature < VERSION_1_0 {
          BindBufferMemory_panic as extern "system" fn (device: Device, buffer: Buffer, memory: DeviceMemory, memoryOffset: DeviceSize) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkBindBufferMemory").expect("could not find symbol for vkBindBufferMemory"))
        };
        let BindImageMemory_ptr = if feature < VERSION_1_0 {
          BindImageMemory_panic as extern "system" fn (device: Device, image: Image, memory: DeviceMemory, memoryOffset: DeviceSize) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkBindImageMemory").expect("could not find symbol for vkBindImageMemory"))
        };
        let GetBufferMemoryRequirements_ptr = if feature < VERSION_1_0 {
          GetBufferMemoryRequirements_panic as extern "system" fn (device: Device, buffer: Buffer, pMemoryRequirements: *mut MemoryRequirements)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetBufferMemoryRequirements").expect("could not find symbol for vkGetBufferMemoryRequirements"))
        };
        let GetImageMemoryRequirements_ptr = if feature < VERSION_1_0 {
          GetImageMemoryRequirements_panic as extern "system" fn (device: Device, image: Image, pMemoryRequirements: *mut MemoryRequirements)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetImageMemoryRequirements").expect("could not find symbol for vkGetImageMemoryRequirements"))
        };
        let GetImageSparseMemoryRequirements_ptr = if feature < VERSION_1_0 {
          GetImageSparseMemoryRequirements_panic as extern "system" fn (device: Device, image: Image, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut SparseImageMemoryRequirements)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetImageSparseMemoryRequirements").expect("could not find symbol for vkGetImageSparseMemoryRequirements"))
        };
        let GetPhysicalDeviceSparseImageFormatProperties_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceSparseImageFormatProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, format: Format, typ: ImageType, samples: SampleCountFlagBits, usage: ImageUsageFlags, tiling: ImageTiling, pPropertyCount: *mut u32, pProperties: *mut SparseImageFormatProperties)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceSparseImageFormatProperties").expect("could not find symbol for vkGetPhysicalDeviceSparseImageFormatProperties"))
        };
        let QueueBindSparse_ptr = if feature < VERSION_1_0 {
          QueueBindSparse_panic as extern "system" fn (queue: Queue, bindInfoCount: u32, pBindInfo: *const BindSparseInfo, fence: Fence) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkQueueBindSparse").expect("could not find symbol for vkQueueBindSparse"))
        };
        let CreateFence_ptr = if feature < VERSION_1_0 {
          CreateFence_panic as extern "system" fn (device: Device, pCreateInfo: *const FenceCreateInfo, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateFence").expect("could not find symbol for vkCreateFence"))
        };
        let DestroyFence_ptr = if feature < VERSION_1_0 {
          DestroyFence_panic as extern "system" fn (device: Device, fence: Fence, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyFence").expect("could not find symbol for vkDestroyFence"))
        };
        let ResetFences_ptr = if feature < VERSION_1_0 {
          ResetFences_panic as extern "system" fn (device: Device, fenceCount: u32, pFences: *const Fence) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkResetFences").expect("could not find symbol for vkResetFences"))
        };
        let GetFenceStatus_ptr = if feature < VERSION_1_0 {
          GetFenceStatus_panic as extern "system" fn (device: Device, fence: Fence) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetFenceStatus").expect("could not find symbol for vkGetFenceStatus"))
        };
        let WaitForFences_ptr = if feature < VERSION_1_0 {
          WaitForFences_panic as extern "system" fn (device: Device, fenceCount: u32, pFences: *const Fence, waitAll: Bool32, timeout: u64) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkWaitForFences").expect("could not find symbol for vkWaitForFences"))
        };
        let CreateSemaphore_ptr = if feature < VERSION_1_0 {
          CreateSemaphore_panic as extern "system" fn (device: Device, pCreateInfo: *const SemaphoreCreateInfo, pAllocator: *const AllocationCallbacks, pSemaphore: *mut Semaphore) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateSemaphore").expect("could not find symbol for vkCreateSemaphore"))
        };
        let DestroySemaphore_ptr = if feature < VERSION_1_0 {
          DestroySemaphore_panic as extern "system" fn (device: Device, semaphore: Semaphore, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroySemaphore").expect("could not find symbol for vkDestroySemaphore"))
        };
        let CreateEvent_ptr = if feature < VERSION_1_0 {
          CreateEvent_panic as extern "system" fn (device: Device, pCreateInfo: *const EventCreateInfo, pAllocator: *const AllocationCallbacks, pEvent: *mut Event) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateEvent").expect("could not find symbol for vkCreateEvent"))
        };
        let DestroyEvent_ptr = if feature < VERSION_1_0 {
          DestroyEvent_panic as extern "system" fn (device: Device, event: Event, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyEvent").expect("could not find symbol for vkDestroyEvent"))
        };
        let GetEventStatus_ptr = if feature < VERSION_1_0 {
          GetEventStatus_panic as extern "system" fn (device: Device, event: Event) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetEventStatus").expect("could not find symbol for vkGetEventStatus"))
        };
        let SetEvent_ptr = if feature < VERSION_1_0 {
          SetEvent_panic as extern "system" fn (device: Device, event: Event) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkSetEvent").expect("could not find symbol for vkSetEvent"))
        };
        let ResetEvent_ptr = if feature < VERSION_1_0 {
          ResetEvent_panic as extern "system" fn (device: Device, event: Event) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkResetEvent").expect("could not find symbol for vkResetEvent"))
        };
        let CreateQueryPool_ptr = if feature < VERSION_1_0 {
          CreateQueryPool_panic as extern "system" fn (device: Device, pCreateInfo: *const QueryPoolCreateInfo, pAllocator: *const AllocationCallbacks, pQueryPool: *mut QueryPool) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateQueryPool").expect("could not find symbol for vkCreateQueryPool"))
        };
        let DestroyQueryPool_ptr = if feature < VERSION_1_0 {
          DestroyQueryPool_panic as extern "system" fn (device: Device, queryPool: QueryPool, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyQueryPool").expect("could not find symbol for vkDestroyQueryPool"))
        };
        let GetQueryPoolResults_ptr = if feature < VERSION_1_0 {
          GetQueryPoolResults_panic as extern "system" fn (device: Device, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: DeviceSize, flags: QueryResultFlags) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetQueryPoolResults").expect("could not find symbol for vkGetQueryPoolResults"))
        };
        let CreateBuffer_ptr = if feature < VERSION_1_0 {
          CreateBuffer_panic as extern "system" fn (device: Device, pCreateInfo: *const BufferCreateInfo, pAllocator: *const AllocationCallbacks, pBuffer: *mut Buffer) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateBuffer").expect("could not find symbol for vkCreateBuffer"))
        };
        let DestroyBuffer_ptr = if feature < VERSION_1_0 {
          DestroyBuffer_panic as extern "system" fn (device: Device, buffer: Buffer, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyBuffer").expect("could not find symbol for vkDestroyBuffer"))
        };
        let CreateBufferView_ptr = if feature < VERSION_1_0 {
          CreateBufferView_panic as extern "system" fn (device: Device, pCreateInfo: *const BufferViewCreateInfo, pAllocator: *const AllocationCallbacks, pView: *mut BufferView) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateBufferView").expect("could not find symbol for vkCreateBufferView"))
        };
        let DestroyBufferView_ptr = if feature < VERSION_1_0 {
          DestroyBufferView_panic as extern "system" fn (device: Device, bufferView: BufferView, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyBufferView").expect("could not find symbol for vkDestroyBufferView"))
        };
        let CreateImage_ptr = if feature < VERSION_1_0 {
          CreateImage_panic as extern "system" fn (device: Device, pCreateInfo: *const ImageCreateInfo, pAllocator: *const AllocationCallbacks, pImage: *mut Image) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateImage").expect("could not find symbol for vkCreateImage"))
        };
        let DestroyImage_ptr = if feature < VERSION_1_0 {
          DestroyImage_panic as extern "system" fn (device: Device, image: Image, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyImage").expect("could not find symbol for vkDestroyImage"))
        };
        let GetImageSubresourceLayout_ptr = if feature < VERSION_1_0 {
          GetImageSubresourceLayout_panic as extern "system" fn (device: Device, image: Image, pSubresource: *const ImageSubresource, pLayout: *mut SubresourceLayout)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetImageSubresourceLayout").expect("could not find symbol for vkGetImageSubresourceLayout"))
        };
        let CreateImageView_ptr = if feature < VERSION_1_0 {
          CreateImageView_panic as extern "system" fn (device: Device, pCreateInfo: *const ImageViewCreateInfo, pAllocator: *const AllocationCallbacks, pView: *mut ImageView) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateImageView").expect("could not find symbol for vkCreateImageView"))
        };
        let DestroyImageView_ptr = if feature < VERSION_1_0 {
          DestroyImageView_panic as extern "system" fn (device: Device, imageView: ImageView, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyImageView").expect("could not find symbol for vkDestroyImageView"))
        };
        let CreateShaderModule_ptr = if feature < VERSION_1_0 {
          CreateShaderModule_panic as extern "system" fn (device: Device, pCreateInfo: *const ShaderModuleCreateInfo, pAllocator: *const AllocationCallbacks, pShaderModule: *mut ShaderModule) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateShaderModule").expect("could not find symbol for vkCreateShaderModule"))
        };
        let DestroyShaderModule_ptr = if feature < VERSION_1_0 {
          DestroyShaderModule_panic as extern "system" fn (device: Device, shaderModule: ShaderModule, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyShaderModule").expect("could not find symbol for vkDestroyShaderModule"))
        };
        let CreatePipelineCache_ptr = if feature < VERSION_1_0 {
          CreatePipelineCache_panic as extern "system" fn (device: Device, pCreateInfo: *const PipelineCacheCreateInfo, pAllocator: *const AllocationCallbacks, pPipelineCache: *mut PipelineCache) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreatePipelineCache").expect("could not find symbol for vkCreatePipelineCache"))
        };
        let DestroyPipelineCache_ptr = if feature < VERSION_1_0 {
          DestroyPipelineCache_panic as extern "system" fn (device: Device, pipelineCache: PipelineCache, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyPipelineCache").expect("could not find symbol for vkDestroyPipelineCache"))
        };
        let GetPipelineCacheData_ptr = if feature < VERSION_1_0 {
          GetPipelineCacheData_panic as extern "system" fn (device: Device, pipelineCache: PipelineCache, pDataSize: *mut usize, pData: *mut c_void) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPipelineCacheData").expect("could not find symbol for vkGetPipelineCacheData"))
        };
        let MergePipelineCaches_ptr = if feature < VERSION_1_0 {
          MergePipelineCaches_panic as extern "system" fn (device: Device, dstCache: PipelineCache, srcCacheCount: u32, pSrcCaches: *const PipelineCache) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkMergePipelineCaches").expect("could not find symbol for vkMergePipelineCaches"))
        };
        let CreateGraphicsPipelines_ptr = if feature < VERSION_1_0 {
          CreateGraphicsPipelines_panic as extern "system" fn (device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const GraphicsPipelineCreateInfo, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateGraphicsPipelines").expect("could not find symbol for vkCreateGraphicsPipelines"))
        };
        let CreateComputePipelines_ptr = if feature < VERSION_1_0 {
          CreateComputePipelines_panic as extern "system" fn (device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const ComputePipelineCreateInfo, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateComputePipelines").expect("could not find symbol for vkCreateComputePipelines"))
        };
        let DestroyPipeline_ptr = if feature < VERSION_1_0 {
          DestroyPipeline_panic as extern "system" fn (device: Device, pipeline: Pipeline, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyPipeline").expect("could not find symbol for vkDestroyPipeline"))
        };
        let CreatePipelineLayout_ptr = if feature < VERSION_1_0 {
          CreatePipelineLayout_panic as extern "system" fn (device: Device, pCreateInfo: *const PipelineLayoutCreateInfo, pAllocator: *const AllocationCallbacks, pPipelineLayout: *mut PipelineLayout) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreatePipelineLayout").expect("could not find symbol for vkCreatePipelineLayout"))
        };
        let DestroyPipelineLayout_ptr = if feature < VERSION_1_0 {
          DestroyPipelineLayout_panic as extern "system" fn (device: Device, pipelineLayout: PipelineLayout, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyPipelineLayout").expect("could not find symbol for vkDestroyPipelineLayout"))
        };
        let CreateSampler_ptr = if feature < VERSION_1_0 {
          CreateSampler_panic as extern "system" fn (device: Device, pCreateInfo: *const SamplerCreateInfo, pAllocator: *const AllocationCallbacks, pSampler: *mut Sampler) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateSampler").expect("could not find symbol for vkCreateSampler"))
        };
        let DestroySampler_ptr = if feature < VERSION_1_0 {
          DestroySampler_panic as extern "system" fn (device: Device, sampler: Sampler, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroySampler").expect("could not find symbol for vkDestroySampler"))
        };
        let CreateDescriptorSetLayout_ptr = if feature < VERSION_1_0 {
          CreateDescriptorSetLayout_panic as extern "system" fn (device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pAllocator: *const AllocationCallbacks, pSetLayout: *mut DescriptorSetLayout) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateDescriptorSetLayout").expect("could not find symbol for vkCreateDescriptorSetLayout"))
        };
        let DestroyDescriptorSetLayout_ptr = if feature < VERSION_1_0 {
          DestroyDescriptorSetLayout_panic as extern "system" fn (device: Device, descriptorSetLayout: DescriptorSetLayout, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyDescriptorSetLayout").expect("could not find symbol for vkDestroyDescriptorSetLayout"))
        };
        let CreateDescriptorPool_ptr = if feature < VERSION_1_0 {
          CreateDescriptorPool_panic as extern "system" fn (device: Device, pCreateInfo: *const DescriptorPoolCreateInfo, pAllocator: *const AllocationCallbacks, pDescriptorPool: *mut DescriptorPool) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateDescriptorPool").expect("could not find symbol for vkCreateDescriptorPool"))
        };
        let DestroyDescriptorPool_ptr = if feature < VERSION_1_0 {
          DestroyDescriptorPool_panic as extern "system" fn (device: Device, descriptorPool: DescriptorPool, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyDescriptorPool").expect("could not find symbol for vkDestroyDescriptorPool"))
        };
        let ResetDescriptorPool_ptr = if feature < VERSION_1_0 {
          ResetDescriptorPool_panic as extern "system" fn (device: Device, descriptorPool: DescriptorPool, flags: DescriptorPoolResetFlags) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkResetDescriptorPool").expect("could not find symbol for vkResetDescriptorPool"))
        };
        let AllocateDescriptorSets_ptr = if feature < VERSION_1_0 {
          AllocateDescriptorSets_panic as extern "system" fn (device: Device, pAllocateInfo: *const DescriptorSetAllocateInfo, pDescriptorSets: *mut DescriptorSet) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkAllocateDescriptorSets").expect("could not find symbol for vkAllocateDescriptorSets"))
        };
        let FreeDescriptorSets_ptr = if feature < VERSION_1_0 {
          FreeDescriptorSets_panic as extern "system" fn (device: Device, descriptorPool: DescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const DescriptorSet) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkFreeDescriptorSets").expect("could not find symbol for vkFreeDescriptorSets"))
        };
        let UpdateDescriptorSets_ptr = if feature < VERSION_1_0 {
          UpdateDescriptorSets_panic as extern "system" fn (device: Device, descriptorWriteCount: u32, pDescriptorWrites: *const WriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const CopyDescriptorSet)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkUpdateDescriptorSets").expect("could not find symbol for vkUpdateDescriptorSets"))
        };
        let CreateFramebuffer_ptr = if feature < VERSION_1_0 {
          CreateFramebuffer_panic as extern "system" fn (device: Device, pCreateInfo: *const FramebufferCreateInfo, pAllocator: *const AllocationCallbacks, pFramebuffer: *mut Framebuffer) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateFramebuffer").expect("could not find symbol for vkCreateFramebuffer"))
        };
        let DestroyFramebuffer_ptr = if feature < VERSION_1_0 {
          DestroyFramebuffer_panic as extern "system" fn (device: Device, framebuffer: Framebuffer, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyFramebuffer").expect("could not find symbol for vkDestroyFramebuffer"))
        };
        let CreateRenderPass_ptr = if feature < VERSION_1_0 {
          CreateRenderPass_panic as extern "system" fn (device: Device, pCreateInfo: *const RenderPassCreateInfo, pAllocator: *const AllocationCallbacks, pRenderPass: *mut RenderPass) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateRenderPass").expect("could not find symbol for vkCreateRenderPass"))
        };
        let DestroyRenderPass_ptr = if feature < VERSION_1_0 {
          DestroyRenderPass_panic as extern "system" fn (device: Device, renderPass: RenderPass, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyRenderPass").expect("could not find symbol for vkDestroyRenderPass"))
        };
        let GetRenderAreaGranularity_ptr = if feature < VERSION_1_0 {
          GetRenderAreaGranularity_panic as extern "system" fn (device: Device, renderPass: RenderPass, pGranularity: *mut Extent2D)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetRenderAreaGranularity").expect("could not find symbol for vkGetRenderAreaGranularity"))
        };
        let CreateCommandPool_ptr = if feature < VERSION_1_0 {
          CreateCommandPool_panic as extern "system" fn (device: Device, pCreateInfo: *const CommandPoolCreateInfo, pAllocator: *const AllocationCallbacks, pCommandPool: *mut CommandPool) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateCommandPool").expect("could not find symbol for vkCreateCommandPool"))
        };
        let DestroyCommandPool_ptr = if feature < VERSION_1_0 {
          DestroyCommandPool_panic as extern "system" fn (device: Device, commandPool: CommandPool, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyCommandPool").expect("could not find symbol for vkDestroyCommandPool"))
        };
        let ResetCommandPool_ptr = if feature < VERSION_1_0 {
          ResetCommandPool_panic as extern "system" fn (device: Device, commandPool: CommandPool, flags: CommandPoolResetFlags) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkResetCommandPool").expect("could not find symbol for vkResetCommandPool"))
        };
        let AllocateCommandBuffers_ptr = if feature < VERSION_1_0 {
          AllocateCommandBuffers_panic as extern "system" fn (device: Device, pAllocateInfo: *const CommandBufferAllocateInfo, pCommandBuffers: *mut CommandBuffer) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkAllocateCommandBuffers").expect("could not find symbol for vkAllocateCommandBuffers"))
        };
        let FreeCommandBuffers_ptr = if feature < VERSION_1_0 {
          FreeCommandBuffers_panic as extern "system" fn (device: Device, commandPool: CommandPool, commandBufferCount: u32, pCommandBuffers: *const CommandBuffer)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkFreeCommandBuffers").expect("could not find symbol for vkFreeCommandBuffers"))
        };
        let BeginCommandBuffer_ptr = if feature < VERSION_1_0 {
          BeginCommandBuffer_panic as extern "system" fn (commandBuffer: CommandBuffer, pBeginInfo: *const CommandBufferBeginInfo) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkBeginCommandBuffer").expect("could not find symbol for vkBeginCommandBuffer"))
        };
        let EndCommandBuffer_ptr = if feature < VERSION_1_0 {
          EndCommandBuffer_panic as extern "system" fn (commandBuffer: CommandBuffer) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkEndCommandBuffer").expect("could not find symbol for vkEndCommandBuffer"))
        };
        let ResetCommandBuffer_ptr = if feature < VERSION_1_0 {
          ResetCommandBuffer_panic as extern "system" fn (commandBuffer: CommandBuffer, flags: CommandBufferResetFlags) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkResetCommandBuffer").expect("could not find symbol for vkResetCommandBuffer"))
        };
        let CmdBindPipeline_ptr = if feature < VERSION_1_0 {
          CmdBindPipeline_panic as extern "system" fn (commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, pipeline: Pipeline)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdBindPipeline").expect("could not find symbol for vkCmdBindPipeline"))
        };
        let CmdSetViewport_ptr = if feature < VERSION_1_0 {
          CmdSetViewport_panic as extern "system" fn (commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const Viewport)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetViewport").expect("could not find symbol for vkCmdSetViewport"))
        };
        let CmdSetScissor_ptr = if feature < VERSION_1_0 {
          CmdSetScissor_panic as extern "system" fn (commandBuffer: CommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const Rect2D)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetScissor").expect("could not find symbol for vkCmdSetScissor"))
        };
        let CmdSetLineWidth_ptr = if feature < VERSION_1_0 {
          CmdSetLineWidth_panic as extern "system" fn (commandBuffer: CommandBuffer, lineWidth: f32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetLineWidth").expect("could not find symbol for vkCmdSetLineWidth"))
        };
        let CmdSetDepthBias_ptr = if feature < VERSION_1_0 {
          CmdSetDepthBias_panic as extern "system" fn (commandBuffer: CommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetDepthBias").expect("could not find symbol for vkCmdSetDepthBias"))
        };
        let CmdSetBlendConstants_ptr = if feature < VERSION_1_0 {
          CmdSetBlendConstants_panic as extern "system" fn (commandBuffer: CommandBuffer, blendConstants: [f32; 4])
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetBlendConstants").expect("could not find symbol for vkCmdSetBlendConstants"))
        };
        let CmdSetDepthBounds_ptr = if feature < VERSION_1_0 {
          CmdSetDepthBounds_panic as extern "system" fn (commandBuffer: CommandBuffer, minDepthBounds: f32, maxDepthBounds: f32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetDepthBounds").expect("could not find symbol for vkCmdSetDepthBounds"))
        };
        let CmdSetStencilCompareMask_ptr = if feature < VERSION_1_0 {
          CmdSetStencilCompareMask_panic as extern "system" fn (commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, compareMask: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetStencilCompareMask").expect("could not find symbol for vkCmdSetStencilCompareMask"))
        };
        let CmdSetStencilWriteMask_ptr = if feature < VERSION_1_0 {
          CmdSetStencilWriteMask_panic as extern "system" fn (commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, writeMask: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetStencilWriteMask").expect("could not find symbol for vkCmdSetStencilWriteMask"))
        };
        let CmdSetStencilReference_ptr = if feature < VERSION_1_0 {
          CmdSetStencilReference_panic as extern "system" fn (commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, reference: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetStencilReference").expect("could not find symbol for vkCmdSetStencilReference"))
        };
        let CmdBindDescriptorSets_ptr = if feature < VERSION_1_0 {
          CmdBindDescriptorSets_panic as extern "system" fn (commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const DescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdBindDescriptorSets").expect("could not find symbol for vkCmdBindDescriptorSets"))
        };
        let CmdBindIndexBuffer_ptr = if feature < VERSION_1_0 {
          CmdBindIndexBuffer_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, indexType: IndexType)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdBindIndexBuffer").expect("could not find symbol for vkCmdBindIndexBuffer"))
        };
        let CmdBindVertexBuffers_ptr = if feature < VERSION_1_0 {
          CmdBindVertexBuffers_panic as extern "system" fn (commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const Buffer, pOffsets: *const DeviceSize)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdBindVertexBuffers").expect("could not find symbol for vkCmdBindVertexBuffers"))
        };
        let CmdDraw_ptr = if feature < VERSION_1_0 {
          CmdDraw_panic as extern "system" fn (commandBuffer: CommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdDraw").expect("could not find symbol for vkCmdDraw"))
        };
        let CmdDrawIndexed_ptr = if feature < VERSION_1_0 {
          CmdDrawIndexed_panic as extern "system" fn (commandBuffer: CommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdDrawIndexed").expect("could not find symbol for vkCmdDrawIndexed"))
        };
        let CmdDrawIndirect_ptr = if feature < VERSION_1_0 {
          CmdDrawIndirect_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdDrawIndirect").expect("could not find symbol for vkCmdDrawIndirect"))
        };
        let CmdDrawIndexedIndirect_ptr = if feature < VERSION_1_0 {
          CmdDrawIndexedIndirect_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdDrawIndexedIndirect").expect("could not find symbol for vkCmdDrawIndexedIndirect"))
        };
        let CmdDispatch_ptr = if feature < VERSION_1_0 {
          CmdDispatch_panic as extern "system" fn (commandBuffer: CommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdDispatch").expect("could not find symbol for vkCmdDispatch"))
        };
        let CmdDispatchIndirect_ptr = if feature < VERSION_1_0 {
          CmdDispatchIndirect_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdDispatchIndirect").expect("could not find symbol for vkCmdDispatchIndirect"))
        };
        let CmdCopyBuffer_ptr = if feature < VERSION_1_0 {
          CmdCopyBuffer_panic as extern "system" fn (commandBuffer: CommandBuffer, srcBuffer: Buffer, dstBuffer: Buffer, regionCount: u32, pRegions: *const BufferCopy)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdCopyBuffer").expect("could not find symbol for vkCmdCopyBuffer"))
        };
        let CmdCopyImage_ptr = if feature < VERSION_1_0 {
          CmdCopyImage_panic as extern "system" fn (commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageCopy)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdCopyImage").expect("could not find symbol for vkCmdCopyImage"))
        };
        let CmdBlitImage_ptr = if feature < VERSION_1_0 {
          CmdBlitImage_panic as extern "system" fn (commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageBlit, filter: Filter)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdBlitImage").expect("could not find symbol for vkCmdBlitImage"))
        };
        let CmdCopyBufferToImage_ptr = if feature < VERSION_1_0 {
          CmdCopyBufferToImage_panic as extern "system" fn (commandBuffer: CommandBuffer, srcBuffer: Buffer, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const BufferImageCopy)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdCopyBufferToImage").expect("could not find symbol for vkCmdCopyBufferToImage"))
        };
        let CmdCopyImageToBuffer_ptr = if feature < VERSION_1_0 {
          CmdCopyImageToBuffer_panic as extern "system" fn (commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstBuffer: Buffer, regionCount: u32, pRegions: *const BufferImageCopy)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdCopyImageToBuffer").expect("could not find symbol for vkCmdCopyImageToBuffer"))
        };
        let CmdUpdateBuffer_ptr = if feature < VERSION_1_0 {
          CmdUpdateBuffer_panic as extern "system" fn (commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, dataSize: DeviceSize, pData: *const c_void)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdUpdateBuffer").expect("could not find symbol for vkCmdUpdateBuffer"))
        };
        let CmdFillBuffer_ptr = if feature < VERSION_1_0 {
          CmdFillBuffer_panic as extern "system" fn (commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, size: DeviceSize, data: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdFillBuffer").expect("could not find symbol for vkCmdFillBuffer"))
        };
        let CmdClearColorImage_ptr = if feature < VERSION_1_0 {
          CmdClearColorImage_panic as extern "system" fn (commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pColor: *const ClearColorValue, rangeCount: u32, pRanges: *const ImageSubresourceRange)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdClearColorImage").expect("could not find symbol for vkCmdClearColorImage"))
        };
        let CmdClearDepthStencilImage_ptr = if feature < VERSION_1_0 {
          CmdClearDepthStencilImage_panic as extern "system" fn (commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pDepthStencil: *const ClearDepthStencilValue, rangeCount: u32, pRanges: *const ImageSubresourceRange)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdClearDepthStencilImage").expect("could not find symbol for vkCmdClearDepthStencilImage"))
        };
        let CmdClearAttachments_ptr = if feature < VERSION_1_0 {
          CmdClearAttachments_panic as extern "system" fn (commandBuffer: CommandBuffer, attachmentCount: u32, pAttachments: *const ClearAttachment, rectCount: u32, pRects: *const ClearRect)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdClearAttachments").expect("could not find symbol for vkCmdClearAttachments"))
        };
        let CmdResolveImage_ptr = if feature < VERSION_1_0 {
          CmdResolveImage_panic as extern "system" fn (commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageResolve)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdResolveImage").expect("could not find symbol for vkCmdResolveImage"))
        };
        let CmdSetEvent_ptr = if feature < VERSION_1_0 {
          CmdSetEvent_panic as extern "system" fn (commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetEvent").expect("could not find symbol for vkCmdSetEvent"))
        };
        let CmdResetEvent_ptr = if feature < VERSION_1_0 {
          CmdResetEvent_panic as extern "system" fn (commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdResetEvent").expect("could not find symbol for vkCmdResetEvent"))
        };
        let CmdWaitEvents_ptr = if feature < VERSION_1_0 {
          CmdWaitEvents_panic as extern "system" fn (commandBuffer: CommandBuffer, eventCount: u32, pEvents: *const Event, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const ImageMemoryBarrier)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdWaitEvents").expect("could not find symbol for vkCmdWaitEvents"))
        };
        let CmdPipelineBarrier_ptr = if feature < VERSION_1_0 {
          CmdPipelineBarrier_panic as extern "system" fn (commandBuffer: CommandBuffer, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, dependencyFlags: DependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const ImageMemoryBarrier)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdPipelineBarrier").expect("could not find symbol for vkCmdPipelineBarrier"))
        };
        let CmdBeginQuery_ptr = if feature < VERSION_1_0 {
          CmdBeginQuery_panic as extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdBeginQuery").expect("could not find symbol for vkCmdBeginQuery"))
        };
        let CmdEndQuery_ptr = if feature < VERSION_1_0 {
          CmdEndQuery_panic as extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdEndQuery").expect("could not find symbol for vkCmdEndQuery"))
        };
        let CmdResetQueryPool_ptr = if feature < VERSION_1_0 {
          CmdResetQueryPool_panic as extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdResetQueryPool").expect("could not find symbol for vkCmdResetQueryPool"))
        };
        let CmdWriteTimestamp_ptr = if feature < VERSION_1_0 {
          CmdWriteTimestamp_panic as extern "system" fn (commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlagBits, queryPool: QueryPool, query: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdWriteTimestamp").expect("could not find symbol for vkCmdWriteTimestamp"))
        };
        let CmdCopyQueryPoolResults_ptr = if feature < VERSION_1_0 {
          CmdCopyQueryPoolResults_panic as extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dstBuffer: Buffer, dstOffset: DeviceSize, stride: DeviceSize, flags: QueryResultFlags)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdCopyQueryPoolResults").expect("could not find symbol for vkCmdCopyQueryPoolResults"))
        };
        let CmdPushConstants_ptr = if feature < VERSION_1_0 {
          CmdPushConstants_panic as extern "system" fn (commandBuffer: CommandBuffer, layout: PipelineLayout, stageFlags: ShaderStageFlags, offset: u32, size: u32, pValues: *const c_void)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdPushConstants").expect("could not find symbol for vkCmdPushConstants"))
        };
        let CmdBeginRenderPass_ptr = if feature < VERSION_1_0 {
          CmdBeginRenderPass_panic as extern "system" fn (commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, contents: SubpassContents)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdBeginRenderPass").expect("could not find symbol for vkCmdBeginRenderPass"))
        };
        let CmdNextSubpass_ptr = if feature < VERSION_1_0 {
          CmdNextSubpass_panic as extern "system" fn (commandBuffer: CommandBuffer, contents: SubpassContents)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdNextSubpass").expect("could not find symbol for vkCmdNextSubpass"))
        };
        let CmdEndRenderPass_ptr = if feature < VERSION_1_0 {
          CmdEndRenderPass_panic as extern "system" fn (commandBuffer: CommandBuffer)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdEndRenderPass").expect("could not find symbol for vkCmdEndRenderPass"))
        };
        let CmdExecuteCommands_ptr = if feature < VERSION_1_0 {
          CmdExecuteCommands_panic as extern "system" fn (commandBuffer: CommandBuffer, commandBufferCount: u32, pCommandBuffers: *const CommandBuffer)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdExecuteCommands").expect("could not find symbol for vkCmdExecuteCommands"))
        };
        let EnumerateInstanceVersion_ptr = if feature < VERSION_1_1 {
          EnumerateInstanceVersion_panic as extern "system" fn (pApiVersion: *mut u32) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkEnumerateInstanceVersion").expect("could not find symbol for vkEnumerateInstanceVersion"))
        };
        let BindBufferMemory2_ptr = if feature < VERSION_1_1 {
          BindBufferMemory2_panic as extern "system" fn (device: Device, bindInfoCount: u32, pBindInfos: *const BindBufferMemoryInfo) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkBindBufferMemory2").expect("could not find symbol for vkBindBufferMemory2"))
        };
        let BindImageMemory2_ptr = if feature < VERSION_1_1 {
          BindImageMemory2_panic as extern "system" fn (device: Device, bindInfoCount: u32, pBindInfos: *const BindImageMemoryInfo) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkBindImageMemory2").expect("could not find symbol for vkBindImageMemory2"))
        };
        let GetDeviceGroupPeerMemoryFeatures_ptr = if feature < VERSION_1_1 {
          GetDeviceGroupPeerMemoryFeatures_panic as extern "system" fn (device: Device, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut PeerMemoryFeatureFlags)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetDeviceGroupPeerMemoryFeatures").expect("could not find symbol for vkGetDeviceGroupPeerMemoryFeatures"))
        };
        let CmdSetDeviceMask_ptr = if feature < VERSION_1_1 {
          CmdSetDeviceMask_panic as extern "system" fn (commandBuffer: CommandBuffer, deviceMask: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdSetDeviceMask").expect("could not find symbol for vkCmdSetDeviceMask"))
        };
        let CmdDispatchBase_ptr = if feature < VERSION_1_1 {
          CmdDispatchBase_panic as extern "system" fn (commandBuffer: CommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCmdDispatchBase").expect("could not find symbol for vkCmdDispatchBase"))
        };
        let EnumeratePhysicalDeviceGroups_ptr = if feature < VERSION_1_1 {
          EnumeratePhysicalDeviceGroups_panic as extern "system" fn (instance: Instance, pPhysicalDeviceGroupCount: *mut u32, pPhysicalDeviceGroupProperties: *mut PhysicalDeviceGroupProperties) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkEnumeratePhysicalDeviceGroups").expect("could not find symbol for vkEnumeratePhysicalDeviceGroups"))
        };
        let GetImageMemoryRequirements2_ptr = if feature < VERSION_1_1 {
          GetImageMemoryRequirements2_panic as extern "system" fn (device: Device, pInfo: *const ImageMemoryRequirementsInfo2, pMemoryRequirements: *mut MemoryRequirements2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetImageMemoryRequirements2").expect("could not find symbol for vkGetImageMemoryRequirements2"))
        };
        let GetBufferMemoryRequirements2_ptr = if feature < VERSION_1_1 {
          GetBufferMemoryRequirements2_panic as extern "system" fn (device: Device, pInfo: *const BufferMemoryRequirementsInfo2, pMemoryRequirements: *mut MemoryRequirements2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetBufferMemoryRequirements2").expect("could not find symbol for vkGetBufferMemoryRequirements2"))
        };
        let GetImageSparseMemoryRequirements2_ptr = if feature < VERSION_1_1 {
          GetImageSparseMemoryRequirements2_panic as extern "system" fn (device: Device, pInfo: *const ImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut SparseImageMemoryRequirements2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetImageSparseMemoryRequirements2").expect("could not find symbol for vkGetImageSparseMemoryRequirements2"))
        };
        let GetPhysicalDeviceFeatures2_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceFeatures2_panic as extern "system" fn (physicalDevice: PhysicalDevice, pFeatures: *mut PhysicalDeviceFeatures2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceFeatures2").expect("could not find symbol for vkGetPhysicalDeviceFeatures2"))
        };
        let GetPhysicalDeviceProperties2_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceProperties2_panic as extern "system" fn (physicalDevice: PhysicalDevice, pProperties: *mut PhysicalDeviceProperties2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceProperties2").expect("could not find symbol for vkGetPhysicalDeviceProperties2"))
        };
        let GetPhysicalDeviceFormatProperties2_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceFormatProperties2_panic as extern "system" fn (physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *mut FormatProperties2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceFormatProperties2").expect("could not find symbol for vkGetPhysicalDeviceFormatProperties2"))
        };
        let GetPhysicalDeviceImageFormatProperties2_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceImageFormatProperties2_panic as extern "system" fn (physicalDevice: PhysicalDevice, pImageFormatInfo: *const PhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut ImageFormatProperties2) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceImageFormatProperties2").expect("could not find symbol for vkGetPhysicalDeviceImageFormatProperties2"))
        };
        let GetPhysicalDeviceQueueFamilyProperties2_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceQueueFamilyProperties2_panic as extern "system" fn (physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut QueueFamilyProperties2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceQueueFamilyProperties2").expect("could not find symbol for vkGetPhysicalDeviceQueueFamilyProperties2"))
        };
        let GetPhysicalDeviceMemoryProperties2_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceMemoryProperties2_panic as extern "system" fn (physicalDevice: PhysicalDevice, pMemoryProperties: *mut PhysicalDeviceMemoryProperties2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceMemoryProperties2").expect("could not find symbol for vkGetPhysicalDeviceMemoryProperties2"))
        };
        let GetPhysicalDeviceSparseImageFormatProperties2_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceSparseImageFormatProperties2_panic as extern "system" fn (physicalDevice: PhysicalDevice, pFormatInfo: *const PhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut u32, pProperties: *mut SparseImageFormatProperties2)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceSparseImageFormatProperties2").expect("could not find symbol for vkGetPhysicalDeviceSparseImageFormatProperties2"))
        };
        let TrimCommandPool_ptr = if feature < VERSION_1_1 {
          TrimCommandPool_panic as extern "system" fn (device: Device, commandPool: CommandPool, flags: CommandPoolTrimFlags)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkTrimCommandPool").expect("could not find symbol for vkTrimCommandPool"))
        };
        let GetDeviceQueue2_ptr = if feature < VERSION_1_1 {
          GetDeviceQueue2_panic as extern "system" fn (device: Device, pQueueInfo: *const DeviceQueueInfo2, pQueue: *mut Queue)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetDeviceQueue2").expect("could not find symbol for vkGetDeviceQueue2"))
        };
        let CreateSamplerYcbcrConversion_ptr = if feature < VERSION_1_1 {
          CreateSamplerYcbcrConversion_panic as extern "system" fn (device: Device, pCreateInfo: *const SamplerYcbcrConversionCreateInfo, pAllocator: *const AllocationCallbacks, pYcbcrConversion: *mut SamplerYcbcrConversion) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateSamplerYcbcrConversion").expect("could not find symbol for vkCreateSamplerYcbcrConversion"))
        };
        let DestroySamplerYcbcrConversion_ptr = if feature < VERSION_1_1 {
          DestroySamplerYcbcrConversion_panic as extern "system" fn (device: Device, ycbcrConversion: SamplerYcbcrConversion, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroySamplerYcbcrConversion").expect("could not find symbol for vkDestroySamplerYcbcrConversion"))
        };
        let CreateDescriptorUpdateTemplate_ptr = if feature < VERSION_1_1 {
          CreateDescriptorUpdateTemplate_panic as extern "system" fn (device: Device, pCreateInfo: *const DescriptorUpdateTemplateCreateInfo, pAllocator: *const AllocationCallbacks, pDescriptorUpdateTemplate: *mut DescriptorUpdateTemplate) -> Result
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkCreateDescriptorUpdateTemplate").expect("could not find symbol for vkCreateDescriptorUpdateTemplate"))
        };
        let DestroyDescriptorUpdateTemplate_ptr = if feature < VERSION_1_1 {
          DestroyDescriptorUpdateTemplate_panic as extern "system" fn (device: Device, descriptorUpdateTemplate: DescriptorUpdateTemplate, pAllocator: *const AllocationCallbacks)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkDestroyDescriptorUpdateTemplate").expect("could not find symbol for vkDestroyDescriptorUpdateTemplate"))
        };
        let UpdateDescriptorSetWithTemplate_ptr = if feature < VERSION_1_1 {
          UpdateDescriptorSetWithTemplate_panic as extern "system" fn (device: Device, descriptorSet: DescriptorSet, descriptorUpdateTemplate: DescriptorUpdateTemplate, pData: *const c_void)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkUpdateDescriptorSetWithTemplate").expect("could not find symbol for vkUpdateDescriptorSetWithTemplate"))
        };
        let GetPhysicalDeviceExternalBufferProperties_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceExternalBufferProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, pExternalBufferInfo: *const PhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut ExternalBufferProperties)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceExternalBufferProperties").expect("could not find symbol for vkGetPhysicalDeviceExternalBufferProperties"))
        };
        let GetPhysicalDeviceExternalFenceProperties_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceExternalFenceProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, pExternalFenceInfo: *const PhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut ExternalFenceProperties)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceExternalFenceProperties").expect("could not find symbol for vkGetPhysicalDeviceExternalFenceProperties"))
        };
        let GetPhysicalDeviceExternalSemaphoreProperties_ptr = if feature < VERSION_1_1 {
          GetPhysicalDeviceExternalSemaphoreProperties_panic as extern "system" fn (physicalDevice: PhysicalDevice, pExternalSemaphoreInfo: *const PhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut ExternalSemaphoreProperties)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetPhysicalDeviceExternalSemaphoreProperties").expect("could not find symbol for vkGetPhysicalDeviceExternalSemaphoreProperties"))
        };
        let GetDescriptorSetLayoutSupport_ptr = if feature < VERSION_1_1 {
          GetDescriptorSetLayoutSupport_panic as extern "system" fn (device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pSupport: *mut DescriptorSetLayoutSupport)
        } else {
          mem::transmute(vk_dl.symbol::<c_void>("vkGetDescriptorSetLayoutSupport").expect("could not find symbol for vkGetDescriptorSetLayoutSupport"))
        };

      let c = Core {
        lib: vk_dl,
        feature,
        CreateInstance_ptr,
        DestroyInstance_ptr,
        EnumeratePhysicalDevices_ptr,
        GetPhysicalDeviceFeatures_ptr,
        GetPhysicalDeviceFormatProperties_ptr,
        GetPhysicalDeviceImageFormatProperties_ptr,
        GetPhysicalDeviceProperties_ptr,
        GetPhysicalDeviceQueueFamilyProperties_ptr,
        GetPhysicalDeviceMemoryProperties_ptr,
        GetInstanceProcAddr_ptr,
        GetDeviceProcAddr_ptr,
        CreateDevice_ptr,
        DestroyDevice_ptr,
        EnumerateInstanceExtensionProperties_ptr,
        EnumerateDeviceExtensionProperties_ptr,
        EnumerateInstanceLayerProperties_ptr,
        EnumerateDeviceLayerProperties_ptr,
        GetDeviceQueue_ptr,
        QueueSubmit_ptr,
        QueueWaitIdle_ptr,
        DeviceWaitIdle_ptr,
        AllocateMemory_ptr,
        FreeMemory_ptr,
        MapMemory_ptr,
        UnmapMemory_ptr,
        FlushMappedMemoryRanges_ptr,
        InvalidateMappedMemoryRanges_ptr,
        GetDeviceMemoryCommitment_ptr,
        BindBufferMemory_ptr,
        BindImageMemory_ptr,
        GetBufferMemoryRequirements_ptr,
        GetImageMemoryRequirements_ptr,
        GetImageSparseMemoryRequirements_ptr,
        GetPhysicalDeviceSparseImageFormatProperties_ptr,
        QueueBindSparse_ptr,
        CreateFence_ptr,
        DestroyFence_ptr,
        ResetFences_ptr,
        GetFenceStatus_ptr,
        WaitForFences_ptr,
        CreateSemaphore_ptr,
        DestroySemaphore_ptr,
        CreateEvent_ptr,
        DestroyEvent_ptr,
        GetEventStatus_ptr,
        SetEvent_ptr,
        ResetEvent_ptr,
        CreateQueryPool_ptr,
        DestroyQueryPool_ptr,
        GetQueryPoolResults_ptr,
        CreateBuffer_ptr,
        DestroyBuffer_ptr,
        CreateBufferView_ptr,
        DestroyBufferView_ptr,
        CreateImage_ptr,
        DestroyImage_ptr,
        GetImageSubresourceLayout_ptr,
        CreateImageView_ptr,
        DestroyImageView_ptr,
        CreateShaderModule_ptr,
        DestroyShaderModule_ptr,
        CreatePipelineCache_ptr,
        DestroyPipelineCache_ptr,
        GetPipelineCacheData_ptr,
        MergePipelineCaches_ptr,
        CreateGraphicsPipelines_ptr,
        CreateComputePipelines_ptr,
        DestroyPipeline_ptr,
        CreatePipelineLayout_ptr,
        DestroyPipelineLayout_ptr,
        CreateSampler_ptr,
        DestroySampler_ptr,
        CreateDescriptorSetLayout_ptr,
        DestroyDescriptorSetLayout_ptr,
        CreateDescriptorPool_ptr,
        DestroyDescriptorPool_ptr,
        ResetDescriptorPool_ptr,
        AllocateDescriptorSets_ptr,
        FreeDescriptorSets_ptr,
        UpdateDescriptorSets_ptr,
        CreateFramebuffer_ptr,
        DestroyFramebuffer_ptr,
        CreateRenderPass_ptr,
        DestroyRenderPass_ptr,
        GetRenderAreaGranularity_ptr,
        CreateCommandPool_ptr,
        DestroyCommandPool_ptr,
        ResetCommandPool_ptr,
        AllocateCommandBuffers_ptr,
        FreeCommandBuffers_ptr,
        BeginCommandBuffer_ptr,
        EndCommandBuffer_ptr,
        ResetCommandBuffer_ptr,
        CmdBindPipeline_ptr,
        CmdSetViewport_ptr,
        CmdSetScissor_ptr,
        CmdSetLineWidth_ptr,
        CmdSetDepthBias_ptr,
        CmdSetBlendConstants_ptr,
        CmdSetDepthBounds_ptr,
        CmdSetStencilCompareMask_ptr,
        CmdSetStencilWriteMask_ptr,
        CmdSetStencilReference_ptr,
        CmdBindDescriptorSets_ptr,
        CmdBindIndexBuffer_ptr,
        CmdBindVertexBuffers_ptr,
        CmdDraw_ptr,
        CmdDrawIndexed_ptr,
        CmdDrawIndirect_ptr,
        CmdDrawIndexedIndirect_ptr,
        CmdDispatch_ptr,
        CmdDispatchIndirect_ptr,
        CmdCopyBuffer_ptr,
        CmdCopyImage_ptr,
        CmdBlitImage_ptr,
        CmdCopyBufferToImage_ptr,
        CmdCopyImageToBuffer_ptr,
        CmdUpdateBuffer_ptr,
        CmdFillBuffer_ptr,
        CmdClearColorImage_ptr,
        CmdClearDepthStencilImage_ptr,
        CmdClearAttachments_ptr,
        CmdResolveImage_ptr,
        CmdSetEvent_ptr,
        CmdResetEvent_ptr,
        CmdWaitEvents_ptr,
        CmdPipelineBarrier_ptr,
        CmdBeginQuery_ptr,
        CmdEndQuery_ptr,
        CmdResetQueryPool_ptr,
        CmdWriteTimestamp_ptr,
        CmdCopyQueryPoolResults_ptr,
        CmdPushConstants_ptr,
        CmdBeginRenderPass_ptr,
        CmdNextSubpass_ptr,
        CmdEndRenderPass_ptr,
        CmdExecuteCommands_ptr,
        EnumerateInstanceVersion_ptr,
        BindBufferMemory2_ptr,
        BindImageMemory2_ptr,
        GetDeviceGroupPeerMemoryFeatures_ptr,
        CmdSetDeviceMask_ptr,
        CmdDispatchBase_ptr,
        EnumeratePhysicalDeviceGroups_ptr,
        GetImageMemoryRequirements2_ptr,
        GetBufferMemoryRequirements2_ptr,
        GetImageSparseMemoryRequirements2_ptr,
        GetPhysicalDeviceFeatures2_ptr,
        GetPhysicalDeviceProperties2_ptr,
        GetPhysicalDeviceFormatProperties2_ptr,
        GetPhysicalDeviceImageFormatProperties2_ptr,
        GetPhysicalDeviceQueueFamilyProperties2_ptr,
        GetPhysicalDeviceMemoryProperties2_ptr,
        GetPhysicalDeviceSparseImageFormatProperties2_ptr,
        TrimCommandPool_ptr,
        GetDeviceQueue2_ptr,
        CreateSamplerYcbcrConversion_ptr,
        DestroySamplerYcbcrConversion_ptr,
        CreateDescriptorUpdateTemplate_ptr,
        DestroyDescriptorUpdateTemplate_ptr,
        UpdateDescriptorSetWithTemplate_ptr,
        GetPhysicalDeviceExternalBufferProperties_ptr,
        GetPhysicalDeviceExternalFenceProperties_ptr,
        GetPhysicalDeviceExternalSemaphoreProperties_ptr,
        GetDescriptorSetLayoutSupport_ptr,
      };

      core = Some(std::boxed::Box::into_raw(std::boxed::Box::new(c)));
      std::boxed::Box::from_raw(core.unwrap())    }
  }


  /// Gets the feature level with which vulkan was initialized
  ///
  /// The fature is formatted as described in [make_version](macro.make_version.html).
  pub fn get_feature(&self) -> u32 {
    self.feature
  }

  #[doc(hidden)] pub fn CreateInstance(&self, pCreateInfo: *const InstanceCreateInfo, pAllocator: *const AllocationCallbacks, pInstance: *mut Instance) -> Result{
    (self.CreateInstance_ptr)(pCreateInfo, pAllocator, pInstance)
  }
  #[doc(hidden)] pub fn DestroyInstance(&self, instance: Instance, pAllocator: *const AllocationCallbacks){
    (self.DestroyInstance_ptr)(instance, pAllocator)
  }
  #[doc(hidden)] pub fn EnumeratePhysicalDevices(&self, instance: Instance, pPhysicalDeviceCount: *mut u32, pPhysicalDevices: *mut PhysicalDevice) -> Result{
    (self.EnumeratePhysicalDevices_ptr)(instance, pPhysicalDeviceCount, pPhysicalDevices)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceFeatures(&self, physicalDevice: PhysicalDevice, pFeatures: *mut PhysicalDeviceFeatures){
    (self.GetPhysicalDeviceFeatures_ptr)(physicalDevice, pFeatures)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceFormatProperties(&self, physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *mut FormatProperties){
    (self.GetPhysicalDeviceFormatProperties_ptr)(physicalDevice, format, pFormatProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceImageFormatProperties(&self, physicalDevice: PhysicalDevice, format: Format, typ: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, pImageFormatProperties: *mut ImageFormatProperties) -> Result{
    (self.GetPhysicalDeviceImageFormatProperties_ptr)(physicalDevice, format, typ, tiling, usage, flags, pImageFormatProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceProperties(&self, physicalDevice: PhysicalDevice, pProperties: *mut PhysicalDeviceProperties){
    (self.GetPhysicalDeviceProperties_ptr)(physicalDevice, pProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceQueueFamilyProperties(&self, physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut QueueFamilyProperties){
    (self.GetPhysicalDeviceQueueFamilyProperties_ptr)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceMemoryProperties(&self, physicalDevice: PhysicalDevice, pMemoryProperties: *mut PhysicalDeviceMemoryProperties){
    (self.GetPhysicalDeviceMemoryProperties_ptr)(physicalDevice, pMemoryProperties)
  }
  #[doc(hidden)] pub fn GetInstanceProcAddr(&self, instance: Instance, pName: *const c_char) -> PFN_vkVoidFunction{
    (self.GetInstanceProcAddr_ptr)(instance, pName)
  }
  #[doc(hidden)] pub fn GetDeviceProcAddr(&self, device: Device, pName: *const c_char) -> PFN_vkVoidFunction{
    (self.GetDeviceProcAddr_ptr)(device, pName)
  }
  #[doc(hidden)] pub fn CreateDevice(&self, physicalDevice: PhysicalDevice, pCreateInfo: *const DeviceCreateInfo, pAllocator: *const AllocationCallbacks, pDevice: *mut Device) -> Result{
    (self.CreateDevice_ptr)(physicalDevice, pCreateInfo, pAllocator, pDevice)
  }
  #[doc(hidden)] pub fn DestroyDevice(&self, device: Device, pAllocator: *const AllocationCallbacks){
    (self.DestroyDevice_ptr)(device, pAllocator)
  }
  #[doc(hidden)] pub fn EnumerateInstanceExtensionProperties(&self, pLayerName: *const c_char, pPropertyCount: *mut u32, pProperties: *mut ExtensionProperties) -> Result{
    (self.EnumerateInstanceExtensionProperties_ptr)(pLayerName, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn EnumerateDeviceExtensionProperties(&self, physicalDevice: PhysicalDevice, pLayerName: *const c_char, pPropertyCount: *mut u32, pProperties: *mut ExtensionProperties) -> Result{
    (self.EnumerateDeviceExtensionProperties_ptr)(physicalDevice, pLayerName, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn EnumerateInstanceLayerProperties(&self, pPropertyCount: *mut u32, pProperties: *mut LayerProperties) -> Result{
    (self.EnumerateInstanceLayerProperties_ptr)(pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn EnumerateDeviceLayerProperties(&self, physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut LayerProperties) -> Result{
    (self.EnumerateDeviceLayerProperties_ptr)(physicalDevice, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn GetDeviceQueue(&self, device: Device, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut Queue){
    (self.GetDeviceQueue_ptr)(device, queueFamilyIndex, queueIndex, pQueue)
  }
  #[doc(hidden)] pub fn QueueSubmit(&self, queue: Queue, submitCount: u32, pSubmits: *const SubmitInfo, fence: Fence) -> Result{
    (self.QueueSubmit_ptr)(queue, submitCount, pSubmits, fence)
  }
  #[doc(hidden)] pub fn QueueWaitIdle(&self, queue: Queue) -> Result{
    (self.QueueWaitIdle_ptr)(queue)
  }
  #[doc(hidden)] pub fn DeviceWaitIdle(&self, device: Device) -> Result{
    (self.DeviceWaitIdle_ptr)(device)
  }
  #[doc(hidden)] pub fn AllocateMemory(&self, device: Device, pAllocateInfo: *const MemoryAllocateInfo, pAllocator: *const AllocationCallbacks, pMemory: *mut DeviceMemory) -> Result{
    (self.AllocateMemory_ptr)(device, pAllocateInfo, pAllocator, pMemory)
  }
  #[doc(hidden)] pub fn FreeMemory(&self, device: Device, memory: DeviceMemory, pAllocator: *const AllocationCallbacks){
    (self.FreeMemory_ptr)(device, memory, pAllocator)
  }
  #[doc(hidden)] pub fn MapMemory(&self, device: Device, memory: DeviceMemory, offset: DeviceSize, size: DeviceSize, flags: MemoryMapFlags, ppData: *mut *mut c_void) -> Result{
    (self.MapMemory_ptr)(device, memory, offset, size, flags, ppData)
  }
  #[doc(hidden)] pub fn UnmapMemory(&self, device: Device, memory: DeviceMemory){
    (self.UnmapMemory_ptr)(device, memory)
  }
  #[doc(hidden)] pub fn FlushMappedMemoryRanges(&self, device: Device, memoryRangeCount: u32, pMemoryRanges: *const MappedMemoryRange) -> Result{
    (self.FlushMappedMemoryRanges_ptr)(device, memoryRangeCount, pMemoryRanges)
  }
  #[doc(hidden)] pub fn InvalidateMappedMemoryRanges(&self, device: Device, memoryRangeCount: u32, pMemoryRanges: *const MappedMemoryRange) -> Result{
    (self.InvalidateMappedMemoryRanges_ptr)(device, memoryRangeCount, pMemoryRanges)
  }
  #[doc(hidden)] pub fn GetDeviceMemoryCommitment(&self, device: Device, memory: DeviceMemory, pCommittedMemoryInBytes: *mut DeviceSize){
    (self.GetDeviceMemoryCommitment_ptr)(device, memory, pCommittedMemoryInBytes)
  }
  #[doc(hidden)] pub fn BindBufferMemory(&self, device: Device, buffer: Buffer, memory: DeviceMemory, memoryOffset: DeviceSize) -> Result{
    (self.BindBufferMemory_ptr)(device, buffer, memory, memoryOffset)
  }
  #[doc(hidden)] pub fn BindImageMemory(&self, device: Device, image: Image, memory: DeviceMemory, memoryOffset: DeviceSize) -> Result{
    (self.BindImageMemory_ptr)(device, image, memory, memoryOffset)
  }
  #[doc(hidden)] pub fn GetBufferMemoryRequirements(&self, device: Device, buffer: Buffer, pMemoryRequirements: *mut MemoryRequirements){
    (self.GetBufferMemoryRequirements_ptr)(device, buffer, pMemoryRequirements)
  }
  #[doc(hidden)] pub fn GetImageMemoryRequirements(&self, device: Device, image: Image, pMemoryRequirements: *mut MemoryRequirements){
    (self.GetImageMemoryRequirements_ptr)(device, image, pMemoryRequirements)
  }
  #[doc(hidden)] pub fn GetImageSparseMemoryRequirements(&self, device: Device, image: Image, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut SparseImageMemoryRequirements){
    (self.GetImageSparseMemoryRequirements_ptr)(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSparseImageFormatProperties(&self, physicalDevice: PhysicalDevice, format: Format, typ: ImageType, samples: SampleCountFlagBits, usage: ImageUsageFlags, tiling: ImageTiling, pPropertyCount: *mut u32, pProperties: *mut SparseImageFormatProperties){
    (self.GetPhysicalDeviceSparseImageFormatProperties_ptr)(physicalDevice, format, typ, samples, usage, tiling, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn QueueBindSparse(&self, queue: Queue, bindInfoCount: u32, pBindInfo: *const BindSparseInfo, fence: Fence) -> Result{
    (self.QueueBindSparse_ptr)(queue, bindInfoCount, pBindInfo, fence)
  }
  #[doc(hidden)] pub fn CreateFence(&self, device: Device, pCreateInfo: *const FenceCreateInfo, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result{
    (self.CreateFence_ptr)(device, pCreateInfo, pAllocator, pFence)
  }
  #[doc(hidden)] pub fn DestroyFence(&self, device: Device, fence: Fence, pAllocator: *const AllocationCallbacks){
    (self.DestroyFence_ptr)(device, fence, pAllocator)
  }
  #[doc(hidden)] pub fn ResetFences(&self, device: Device, fenceCount: u32, pFences: *const Fence) -> Result{
    (self.ResetFences_ptr)(device, fenceCount, pFences)
  }
  #[doc(hidden)] pub fn GetFenceStatus(&self, device: Device, fence: Fence) -> Result{
    (self.GetFenceStatus_ptr)(device, fence)
  }
  #[doc(hidden)] pub fn WaitForFences(&self, device: Device, fenceCount: u32, pFences: *const Fence, waitAll: Bool32, timeout: u64) -> Result{
    (self.WaitForFences_ptr)(device, fenceCount, pFences, waitAll, timeout)
  }
  #[doc(hidden)] pub fn CreateSemaphore(&self, device: Device, pCreateInfo: *const SemaphoreCreateInfo, pAllocator: *const AllocationCallbacks, pSemaphore: *mut Semaphore) -> Result{
    (self.CreateSemaphore_ptr)(device, pCreateInfo, pAllocator, pSemaphore)
  }
  #[doc(hidden)] pub fn DestroySemaphore(&self, device: Device, semaphore: Semaphore, pAllocator: *const AllocationCallbacks){
    (self.DestroySemaphore_ptr)(device, semaphore, pAllocator)
  }
  #[doc(hidden)] pub fn CreateEvent(&self, device: Device, pCreateInfo: *const EventCreateInfo, pAllocator: *const AllocationCallbacks, pEvent: *mut Event) -> Result{
    (self.CreateEvent_ptr)(device, pCreateInfo, pAllocator, pEvent)
  }
  #[doc(hidden)] pub fn DestroyEvent(&self, device: Device, event: Event, pAllocator: *const AllocationCallbacks){
    (self.DestroyEvent_ptr)(device, event, pAllocator)
  }
  #[doc(hidden)] pub fn GetEventStatus(&self, device: Device, event: Event) -> Result{
    (self.GetEventStatus_ptr)(device, event)
  }
  #[doc(hidden)] pub fn SetEvent(&self, device: Device, event: Event) -> Result{
    (self.SetEvent_ptr)(device, event)
  }
  #[doc(hidden)] pub fn ResetEvent(&self, device: Device, event: Event) -> Result{
    (self.ResetEvent_ptr)(device, event)
  }
  #[doc(hidden)] pub fn CreateQueryPool(&self, device: Device, pCreateInfo: *const QueryPoolCreateInfo, pAllocator: *const AllocationCallbacks, pQueryPool: *mut QueryPool) -> Result{
    (self.CreateQueryPool_ptr)(device, pCreateInfo, pAllocator, pQueryPool)
  }
  #[doc(hidden)] pub fn DestroyQueryPool(&self, device: Device, queryPool: QueryPool, pAllocator: *const AllocationCallbacks){
    (self.DestroyQueryPool_ptr)(device, queryPool, pAllocator)
  }
  #[doc(hidden)] pub fn GetQueryPoolResults(&self, device: Device, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: DeviceSize, flags: QueryResultFlags) -> Result{
    (self.GetQueryPoolResults_ptr)(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
  }
  #[doc(hidden)] pub fn CreateBuffer(&self, device: Device, pCreateInfo: *const BufferCreateInfo, pAllocator: *const AllocationCallbacks, pBuffer: *mut Buffer) -> Result{
    (self.CreateBuffer_ptr)(device, pCreateInfo, pAllocator, pBuffer)
  }
  #[doc(hidden)] pub fn DestroyBuffer(&self, device: Device, buffer: Buffer, pAllocator: *const AllocationCallbacks){
    (self.DestroyBuffer_ptr)(device, buffer, pAllocator)
  }
  #[doc(hidden)] pub fn CreateBufferView(&self, device: Device, pCreateInfo: *const BufferViewCreateInfo, pAllocator: *const AllocationCallbacks, pView: *mut BufferView) -> Result{
    (self.CreateBufferView_ptr)(device, pCreateInfo, pAllocator, pView)
  }
  #[doc(hidden)] pub fn DestroyBufferView(&self, device: Device, bufferView: BufferView, pAllocator: *const AllocationCallbacks){
    (self.DestroyBufferView_ptr)(device, bufferView, pAllocator)
  }
  #[doc(hidden)] pub fn CreateImage(&self, device: Device, pCreateInfo: *const ImageCreateInfo, pAllocator: *const AllocationCallbacks, pImage: *mut Image) -> Result{
    (self.CreateImage_ptr)(device, pCreateInfo, pAllocator, pImage)
  }
  #[doc(hidden)] pub fn DestroyImage(&self, device: Device, image: Image, pAllocator: *const AllocationCallbacks){
    (self.DestroyImage_ptr)(device, image, pAllocator)
  }
  #[doc(hidden)] pub fn GetImageSubresourceLayout(&self, device: Device, image: Image, pSubresource: *const ImageSubresource, pLayout: *mut SubresourceLayout){
    (self.GetImageSubresourceLayout_ptr)(device, image, pSubresource, pLayout)
  }
  #[doc(hidden)] pub fn CreateImageView(&self, device: Device, pCreateInfo: *const ImageViewCreateInfo, pAllocator: *const AllocationCallbacks, pView: *mut ImageView) -> Result{
    (self.CreateImageView_ptr)(device, pCreateInfo, pAllocator, pView)
  }
  #[doc(hidden)] pub fn DestroyImageView(&self, device: Device, imageView: ImageView, pAllocator: *const AllocationCallbacks){
    (self.DestroyImageView_ptr)(device, imageView, pAllocator)
  }
  #[doc(hidden)] pub fn CreateShaderModule(&self, device: Device, pCreateInfo: *const ShaderModuleCreateInfo, pAllocator: *const AllocationCallbacks, pShaderModule: *mut ShaderModule) -> Result{
    (self.CreateShaderModule_ptr)(device, pCreateInfo, pAllocator, pShaderModule)
  }
  #[doc(hidden)] pub fn DestroyShaderModule(&self, device: Device, shaderModule: ShaderModule, pAllocator: *const AllocationCallbacks){
    (self.DestroyShaderModule_ptr)(device, shaderModule, pAllocator)
  }
  #[doc(hidden)] pub fn CreatePipelineCache(&self, device: Device, pCreateInfo: *const PipelineCacheCreateInfo, pAllocator: *const AllocationCallbacks, pPipelineCache: *mut PipelineCache) -> Result{
    (self.CreatePipelineCache_ptr)(device, pCreateInfo, pAllocator, pPipelineCache)
  }
  #[doc(hidden)] pub fn DestroyPipelineCache(&self, device: Device, pipelineCache: PipelineCache, pAllocator: *const AllocationCallbacks){
    (self.DestroyPipelineCache_ptr)(device, pipelineCache, pAllocator)
  }
  #[doc(hidden)] pub fn GetPipelineCacheData(&self, device: Device, pipelineCache: PipelineCache, pDataSize: *mut usize, pData: *mut c_void) -> Result{
    (self.GetPipelineCacheData_ptr)(device, pipelineCache, pDataSize, pData)
  }
  #[doc(hidden)] pub fn MergePipelineCaches(&self, device: Device, dstCache: PipelineCache, srcCacheCount: u32, pSrcCaches: *const PipelineCache) -> Result{
    (self.MergePipelineCaches_ptr)(device, dstCache, srcCacheCount, pSrcCaches)
  }
  #[doc(hidden)] pub fn CreateGraphicsPipelines(&self, device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const GraphicsPipelineCreateInfo, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result{
    (self.CreateGraphicsPipelines_ptr)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
  }
  #[doc(hidden)] pub fn CreateComputePipelines(&self, device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const ComputePipelineCreateInfo, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result{
    (self.CreateComputePipelines_ptr)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
  }
  #[doc(hidden)] pub fn DestroyPipeline(&self, device: Device, pipeline: Pipeline, pAllocator: *const AllocationCallbacks){
    (self.DestroyPipeline_ptr)(device, pipeline, pAllocator)
  }
  #[doc(hidden)] pub fn CreatePipelineLayout(&self, device: Device, pCreateInfo: *const PipelineLayoutCreateInfo, pAllocator: *const AllocationCallbacks, pPipelineLayout: *mut PipelineLayout) -> Result{
    (self.CreatePipelineLayout_ptr)(device, pCreateInfo, pAllocator, pPipelineLayout)
  }
  #[doc(hidden)] pub fn DestroyPipelineLayout(&self, device: Device, pipelineLayout: PipelineLayout, pAllocator: *const AllocationCallbacks){
    (self.DestroyPipelineLayout_ptr)(device, pipelineLayout, pAllocator)
  }
  #[doc(hidden)] pub fn CreateSampler(&self, device: Device, pCreateInfo: *const SamplerCreateInfo, pAllocator: *const AllocationCallbacks, pSampler: *mut Sampler) -> Result{
    (self.CreateSampler_ptr)(device, pCreateInfo, pAllocator, pSampler)
  }
  #[doc(hidden)] pub fn DestroySampler(&self, device: Device, sampler: Sampler, pAllocator: *const AllocationCallbacks){
    (self.DestroySampler_ptr)(device, sampler, pAllocator)
  }
  #[doc(hidden)] pub fn CreateDescriptorSetLayout(&self, device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pAllocator: *const AllocationCallbacks, pSetLayout: *mut DescriptorSetLayout) -> Result{
    (self.CreateDescriptorSetLayout_ptr)(device, pCreateInfo, pAllocator, pSetLayout)
  }
  #[doc(hidden)] pub fn DestroyDescriptorSetLayout(&self, device: Device, descriptorSetLayout: DescriptorSetLayout, pAllocator: *const AllocationCallbacks){
    (self.DestroyDescriptorSetLayout_ptr)(device, descriptorSetLayout, pAllocator)
  }
  #[doc(hidden)] pub fn CreateDescriptorPool(&self, device: Device, pCreateInfo: *const DescriptorPoolCreateInfo, pAllocator: *const AllocationCallbacks, pDescriptorPool: *mut DescriptorPool) -> Result{
    (self.CreateDescriptorPool_ptr)(device, pCreateInfo, pAllocator, pDescriptorPool)
  }
  #[doc(hidden)] pub fn DestroyDescriptorPool(&self, device: Device, descriptorPool: DescriptorPool, pAllocator: *const AllocationCallbacks){
    (self.DestroyDescriptorPool_ptr)(device, descriptorPool, pAllocator)
  }
  #[doc(hidden)] pub fn ResetDescriptorPool(&self, device: Device, descriptorPool: DescriptorPool, flags: DescriptorPoolResetFlags) -> Result{
    (self.ResetDescriptorPool_ptr)(device, descriptorPool, flags)
  }
  #[doc(hidden)] pub fn AllocateDescriptorSets(&self, device: Device, pAllocateInfo: *const DescriptorSetAllocateInfo, pDescriptorSets: *mut DescriptorSet) -> Result{
    (self.AllocateDescriptorSets_ptr)(device, pAllocateInfo, pDescriptorSets)
  }
  #[doc(hidden)] pub fn FreeDescriptorSets(&self, device: Device, descriptorPool: DescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const DescriptorSet) -> Result{
    (self.FreeDescriptorSets_ptr)(device, descriptorPool, descriptorSetCount, pDescriptorSets)
  }
  #[doc(hidden)] pub fn UpdateDescriptorSets(&self, device: Device, descriptorWriteCount: u32, pDescriptorWrites: *const WriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const CopyDescriptorSet){
    (self.UpdateDescriptorSets_ptr)(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)
  }
  #[doc(hidden)] pub fn CreateFramebuffer(&self, device: Device, pCreateInfo: *const FramebufferCreateInfo, pAllocator: *const AllocationCallbacks, pFramebuffer: *mut Framebuffer) -> Result{
    (self.CreateFramebuffer_ptr)(device, pCreateInfo, pAllocator, pFramebuffer)
  }
  #[doc(hidden)] pub fn DestroyFramebuffer(&self, device: Device, framebuffer: Framebuffer, pAllocator: *const AllocationCallbacks){
    (self.DestroyFramebuffer_ptr)(device, framebuffer, pAllocator)
  }
  #[doc(hidden)] pub fn CreateRenderPass(&self, device: Device, pCreateInfo: *const RenderPassCreateInfo, pAllocator: *const AllocationCallbacks, pRenderPass: *mut RenderPass) -> Result{
    (self.CreateRenderPass_ptr)(device, pCreateInfo, pAllocator, pRenderPass)
  }
  #[doc(hidden)] pub fn DestroyRenderPass(&self, device: Device, renderPass: RenderPass, pAllocator: *const AllocationCallbacks){
    (self.DestroyRenderPass_ptr)(device, renderPass, pAllocator)
  }
  #[doc(hidden)] pub fn GetRenderAreaGranularity(&self, device: Device, renderPass: RenderPass, pGranularity: *mut Extent2D){
    (self.GetRenderAreaGranularity_ptr)(device, renderPass, pGranularity)
  }
  #[doc(hidden)] pub fn CreateCommandPool(&self, device: Device, pCreateInfo: *const CommandPoolCreateInfo, pAllocator: *const AllocationCallbacks, pCommandPool: *mut CommandPool) -> Result{
    (self.CreateCommandPool_ptr)(device, pCreateInfo, pAllocator, pCommandPool)
  }
  #[doc(hidden)] pub fn DestroyCommandPool(&self, device: Device, commandPool: CommandPool, pAllocator: *const AllocationCallbacks){
    (self.DestroyCommandPool_ptr)(device, commandPool, pAllocator)
  }
  #[doc(hidden)] pub fn ResetCommandPool(&self, device: Device, commandPool: CommandPool, flags: CommandPoolResetFlags) -> Result{
    (self.ResetCommandPool_ptr)(device, commandPool, flags)
  }
  #[doc(hidden)] pub fn AllocateCommandBuffers(&self, device: Device, pAllocateInfo: *const CommandBufferAllocateInfo, pCommandBuffers: *mut CommandBuffer) -> Result{
    (self.AllocateCommandBuffers_ptr)(device, pAllocateInfo, pCommandBuffers)
  }
  #[doc(hidden)] pub fn FreeCommandBuffers(&self, device: Device, commandPool: CommandPool, commandBufferCount: u32, pCommandBuffers: *const CommandBuffer){
    (self.FreeCommandBuffers_ptr)(device, commandPool, commandBufferCount, pCommandBuffers)
  }
  #[doc(hidden)] pub fn BeginCommandBuffer(&self, commandBuffer: CommandBuffer, pBeginInfo: *const CommandBufferBeginInfo) -> Result{
    (self.BeginCommandBuffer_ptr)(commandBuffer, pBeginInfo)
  }
  #[doc(hidden)] pub fn EndCommandBuffer(&self, commandBuffer: CommandBuffer) -> Result{
    (self.EndCommandBuffer_ptr)(commandBuffer)
  }
  #[doc(hidden)] pub fn ResetCommandBuffer(&self, commandBuffer: CommandBuffer, flags: CommandBufferResetFlags) -> Result{
    (self.ResetCommandBuffer_ptr)(commandBuffer, flags)
  }
  #[doc(hidden)] pub fn CmdBindPipeline(&self, commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, pipeline: Pipeline){
    (self.CmdBindPipeline_ptr)(commandBuffer, pipelineBindPoint, pipeline)
  }
  #[doc(hidden)] pub fn CmdSetViewport(&self, commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const Viewport){
    (self.CmdSetViewport_ptr)(commandBuffer, firstViewport, viewportCount, pViewports)
  }
  #[doc(hidden)] pub fn CmdSetScissor(&self, commandBuffer: CommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const Rect2D){
    (self.CmdSetScissor_ptr)(commandBuffer, firstScissor, scissorCount, pScissors)
  }
  #[doc(hidden)] pub fn CmdSetLineWidth(&self, commandBuffer: CommandBuffer, lineWidth: f32){
    (self.CmdSetLineWidth_ptr)(commandBuffer, lineWidth)
  }
  #[doc(hidden)] pub fn CmdSetDepthBias(&self, commandBuffer: CommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32){
    (self.CmdSetDepthBias_ptr)(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
  }
  #[doc(hidden)] pub fn CmdSetBlendConstants(&self, commandBuffer: CommandBuffer, blendConstants: [f32; 4]){
    (self.CmdSetBlendConstants_ptr)(commandBuffer, blendConstants)
  }
  #[doc(hidden)] pub fn CmdSetDepthBounds(&self, commandBuffer: CommandBuffer, minDepthBounds: f32, maxDepthBounds: f32){
    (self.CmdSetDepthBounds_ptr)(commandBuffer, minDepthBounds, maxDepthBounds)
  }
  #[doc(hidden)] pub fn CmdSetStencilCompareMask(&self, commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, compareMask: u32){
    (self.CmdSetStencilCompareMask_ptr)(commandBuffer, faceMask, compareMask)
  }
  #[doc(hidden)] pub fn CmdSetStencilWriteMask(&self, commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, writeMask: u32){
    (self.CmdSetStencilWriteMask_ptr)(commandBuffer, faceMask, writeMask)
  }
  #[doc(hidden)] pub fn CmdSetStencilReference(&self, commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, reference: u32){
    (self.CmdSetStencilReference_ptr)(commandBuffer, faceMask, reference)
  }
  #[doc(hidden)] pub fn CmdBindDescriptorSets(&self, commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const DescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const u32){
    (self.CmdBindDescriptorSets_ptr)(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)
  }
  #[doc(hidden)] pub fn CmdBindIndexBuffer(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, indexType: IndexType){
    (self.CmdBindIndexBuffer_ptr)(commandBuffer, buffer, offset, indexType)
  }
  #[doc(hidden)] pub fn CmdBindVertexBuffers(&self, commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const Buffer, pOffsets: *const DeviceSize){
    (self.CmdBindVertexBuffers_ptr)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
  }
  #[doc(hidden)] pub fn CmdDraw(&self, commandBuffer: CommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32){
    (self.CmdDraw_ptr)(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
  }
  #[doc(hidden)] pub fn CmdDrawIndexed(&self, commandBuffer: CommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32){
    (self.CmdDrawIndexed_ptr)(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
  }
  #[doc(hidden)] pub fn CmdDrawIndirect(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32){
    (self.CmdDrawIndirect_ptr)(commandBuffer, buffer, offset, drawCount, stride)
  }
  #[doc(hidden)] pub fn CmdDrawIndexedIndirect(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32){
    (self.CmdDrawIndexedIndirect_ptr)(commandBuffer, buffer, offset, drawCount, stride)
  }
  #[doc(hidden)] pub fn CmdDispatch(&self, commandBuffer: CommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32){
    (self.CmdDispatch_ptr)(commandBuffer, groupCountX, groupCountY, groupCountZ)
  }
  #[doc(hidden)] pub fn CmdDispatchIndirect(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize){
    (self.CmdDispatchIndirect_ptr)(commandBuffer, buffer, offset)
  }
  #[doc(hidden)] pub fn CmdCopyBuffer(&self, commandBuffer: CommandBuffer, srcBuffer: Buffer, dstBuffer: Buffer, regionCount: u32, pRegions: *const BufferCopy){
    (self.CmdCopyBuffer_ptr)(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
  }
  #[doc(hidden)] pub fn CmdCopyImage(&self, commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageCopy){
    (self.CmdCopyImage_ptr)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
  }
  #[doc(hidden)] pub fn CmdBlitImage(&self, commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageBlit, filter: Filter){
    (self.CmdBlitImage_ptr)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)
  }
  #[doc(hidden)] pub fn CmdCopyBufferToImage(&self, commandBuffer: CommandBuffer, srcBuffer: Buffer, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const BufferImageCopy){
    (self.CmdCopyBufferToImage_ptr)(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
  }
  #[doc(hidden)] pub fn CmdCopyImageToBuffer(&self, commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstBuffer: Buffer, regionCount: u32, pRegions: *const BufferImageCopy){
    (self.CmdCopyImageToBuffer_ptr)(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
  }
  #[doc(hidden)] pub fn CmdUpdateBuffer(&self, commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, dataSize: DeviceSize, pData: *const c_void){
    (self.CmdUpdateBuffer_ptr)(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
  }
  #[doc(hidden)] pub fn CmdFillBuffer(&self, commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, size: DeviceSize, data: u32){
    (self.CmdFillBuffer_ptr)(commandBuffer, dstBuffer, dstOffset, size, data)
  }
  #[doc(hidden)] pub fn CmdClearColorImage(&self, commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pColor: *const ClearColorValue, rangeCount: u32, pRanges: *const ImageSubresourceRange){
    (self.CmdClearColorImage_ptr)(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
  }
  #[doc(hidden)] pub fn CmdClearDepthStencilImage(&self, commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pDepthStencil: *const ClearDepthStencilValue, rangeCount: u32, pRanges: *const ImageSubresourceRange){
    (self.CmdClearDepthStencilImage_ptr)(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
  }
  #[doc(hidden)] pub fn CmdClearAttachments(&self, commandBuffer: CommandBuffer, attachmentCount: u32, pAttachments: *const ClearAttachment, rectCount: u32, pRects: *const ClearRect){
    (self.CmdClearAttachments_ptr)(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
  }
  #[doc(hidden)] pub fn CmdResolveImage(&self, commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageResolve){
    (self.CmdResolveImage_ptr)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
  }
  #[doc(hidden)] pub fn CmdSetEvent(&self, commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags){
    (self.CmdSetEvent_ptr)(commandBuffer, event, stageMask)
  }
  #[doc(hidden)] pub fn CmdResetEvent(&self, commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags){
    (self.CmdResetEvent_ptr)(commandBuffer, event, stageMask)
  }
  #[doc(hidden)] pub fn CmdWaitEvents(&self, commandBuffer: CommandBuffer, eventCount: u32, pEvents: *const Event, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const ImageMemoryBarrier){
    (self.CmdWaitEvents_ptr)(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
  }
  #[doc(hidden)] pub fn CmdPipelineBarrier(&self, commandBuffer: CommandBuffer, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, dependencyFlags: DependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const ImageMemoryBarrier){
    (self.CmdPipelineBarrier_ptr)(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
  }
  #[doc(hidden)] pub fn CmdBeginQuery(&self, commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags){
    (self.CmdBeginQuery_ptr)(commandBuffer, queryPool, query, flags)
  }
  #[doc(hidden)] pub fn CmdEndQuery(&self, commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32){
    (self.CmdEndQuery_ptr)(commandBuffer, queryPool, query)
  }
  #[doc(hidden)] pub fn CmdResetQueryPool(&self, commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32){
    (self.CmdResetQueryPool_ptr)(commandBuffer, queryPool, firstQuery, queryCount)
  }
  #[doc(hidden)] pub fn CmdWriteTimestamp(&self, commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlagBits, queryPool: QueryPool, query: u32){
    (self.CmdWriteTimestamp_ptr)(commandBuffer, pipelineStage, queryPool, query)
  }
  #[doc(hidden)] pub fn CmdCopyQueryPoolResults(&self, commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dstBuffer: Buffer, dstOffset: DeviceSize, stride: DeviceSize, flags: QueryResultFlags){
    (self.CmdCopyQueryPoolResults_ptr)(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
  }
  #[doc(hidden)] pub fn CmdPushConstants(&self, commandBuffer: CommandBuffer, layout: PipelineLayout, stageFlags: ShaderStageFlags, offset: u32, size: u32, pValues: *const c_void){
    (self.CmdPushConstants_ptr)(commandBuffer, layout, stageFlags, offset, size, pValues)
  }
  #[doc(hidden)] pub fn CmdBeginRenderPass(&self, commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, contents: SubpassContents){
    (self.CmdBeginRenderPass_ptr)(commandBuffer, pRenderPassBegin, contents)
  }
  #[doc(hidden)] pub fn CmdNextSubpass(&self, commandBuffer: CommandBuffer, contents: SubpassContents){
    (self.CmdNextSubpass_ptr)(commandBuffer, contents)
  }
  #[doc(hidden)] pub fn CmdEndRenderPass(&self, commandBuffer: CommandBuffer){
    (self.CmdEndRenderPass_ptr)(commandBuffer)
  }
  #[doc(hidden)] pub fn CmdExecuteCommands(&self, commandBuffer: CommandBuffer, commandBufferCount: u32, pCommandBuffers: *const CommandBuffer){
    (self.CmdExecuteCommands_ptr)(commandBuffer, commandBufferCount, pCommandBuffers)
  }
  #[doc(hidden)] pub fn EnumerateInstanceVersion(&self, pApiVersion: *mut u32) -> Result{
    (self.EnumerateInstanceVersion_ptr)(pApiVersion)
  }
  #[doc(hidden)] pub fn BindBufferMemory2(&self, device: Device, bindInfoCount: u32, pBindInfos: *const BindBufferMemoryInfo) -> Result{
    (self.BindBufferMemory2_ptr)(device, bindInfoCount, pBindInfos)
  }
  #[doc(hidden)] pub fn BindImageMemory2(&self, device: Device, bindInfoCount: u32, pBindInfos: *const BindImageMemoryInfo) -> Result{
    (self.BindImageMemory2_ptr)(device, bindInfoCount, pBindInfos)
  }
  #[doc(hidden)] pub fn GetDeviceGroupPeerMemoryFeatures(&self, device: Device, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut PeerMemoryFeatureFlags){
    (self.GetDeviceGroupPeerMemoryFeatures_ptr)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)
  }
  #[doc(hidden)] pub fn CmdSetDeviceMask(&self, commandBuffer: CommandBuffer, deviceMask: u32){
    (self.CmdSetDeviceMask_ptr)(commandBuffer, deviceMask)
  }
  #[doc(hidden)] pub fn CmdDispatchBase(&self, commandBuffer: CommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32){
    (self.CmdDispatchBase_ptr)(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)
  }
  #[doc(hidden)] pub fn EnumeratePhysicalDeviceGroups(&self, instance: Instance, pPhysicalDeviceGroupCount: *mut u32, pPhysicalDeviceGroupProperties: *mut PhysicalDeviceGroupProperties) -> Result{
    (self.EnumeratePhysicalDeviceGroups_ptr)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)
  }
  #[doc(hidden)] pub fn GetImageMemoryRequirements2(&self, device: Device, pInfo: *const ImageMemoryRequirementsInfo2, pMemoryRequirements: *mut MemoryRequirements2){
    (self.GetImageMemoryRequirements2_ptr)(device, pInfo, pMemoryRequirements)
  }
  #[doc(hidden)] pub fn GetBufferMemoryRequirements2(&self, device: Device, pInfo: *const BufferMemoryRequirementsInfo2, pMemoryRequirements: *mut MemoryRequirements2){
    (self.GetBufferMemoryRequirements2_ptr)(device, pInfo, pMemoryRequirements)
  }
  #[doc(hidden)] pub fn GetImageSparseMemoryRequirements2(&self, device: Device, pInfo: *const ImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut SparseImageMemoryRequirements2){
    (self.GetImageSparseMemoryRequirements2_ptr)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceFeatures2(&self, physicalDevice: PhysicalDevice, pFeatures: *mut PhysicalDeviceFeatures2){
    (self.GetPhysicalDeviceFeatures2_ptr)(physicalDevice, pFeatures)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceProperties2(&self, physicalDevice: PhysicalDevice, pProperties: *mut PhysicalDeviceProperties2){
    (self.GetPhysicalDeviceProperties2_ptr)(physicalDevice, pProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceFormatProperties2(&self, physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *mut FormatProperties2){
    (self.GetPhysicalDeviceFormatProperties2_ptr)(physicalDevice, format, pFormatProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceImageFormatProperties2(&self, physicalDevice: PhysicalDevice, pImageFormatInfo: *const PhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut ImageFormatProperties2) -> Result{
    (self.GetPhysicalDeviceImageFormatProperties2_ptr)(physicalDevice, pImageFormatInfo, pImageFormatProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceQueueFamilyProperties2(&self, physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut QueueFamilyProperties2){
    (self.GetPhysicalDeviceQueueFamilyProperties2_ptr)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceMemoryProperties2(&self, physicalDevice: PhysicalDevice, pMemoryProperties: *mut PhysicalDeviceMemoryProperties2){
    (self.GetPhysicalDeviceMemoryProperties2_ptr)(physicalDevice, pMemoryProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSparseImageFormatProperties2(&self, physicalDevice: PhysicalDevice, pFormatInfo: *const PhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut u32, pProperties: *mut SparseImageFormatProperties2){
    (self.GetPhysicalDeviceSparseImageFormatProperties2_ptr)(physicalDevice, pFormatInfo, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn TrimCommandPool(&self, device: Device, commandPool: CommandPool, flags: CommandPoolTrimFlags){
    (self.TrimCommandPool_ptr)(device, commandPool, flags)
  }
  #[doc(hidden)] pub fn GetDeviceQueue2(&self, device: Device, pQueueInfo: *const DeviceQueueInfo2, pQueue: *mut Queue){
    (self.GetDeviceQueue2_ptr)(device, pQueueInfo, pQueue)
  }
  #[doc(hidden)] pub fn CreateSamplerYcbcrConversion(&self, device: Device, pCreateInfo: *const SamplerYcbcrConversionCreateInfo, pAllocator: *const AllocationCallbacks, pYcbcrConversion: *mut SamplerYcbcrConversion) -> Result{
    (self.CreateSamplerYcbcrConversion_ptr)(device, pCreateInfo, pAllocator, pYcbcrConversion)
  }
  #[doc(hidden)] pub fn DestroySamplerYcbcrConversion(&self, device: Device, ycbcrConversion: SamplerYcbcrConversion, pAllocator: *const AllocationCallbacks){
    (self.DestroySamplerYcbcrConversion_ptr)(device, ycbcrConversion, pAllocator)
  }
  #[doc(hidden)] pub fn CreateDescriptorUpdateTemplate(&self, device: Device, pCreateInfo: *const DescriptorUpdateTemplateCreateInfo, pAllocator: *const AllocationCallbacks, pDescriptorUpdateTemplate: *mut DescriptorUpdateTemplate) -> Result{
    (self.CreateDescriptorUpdateTemplate_ptr)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)
  }
  #[doc(hidden)] pub fn DestroyDescriptorUpdateTemplate(&self, device: Device, descriptorUpdateTemplate: DescriptorUpdateTemplate, pAllocator: *const AllocationCallbacks){
    (self.DestroyDescriptorUpdateTemplate_ptr)(device, descriptorUpdateTemplate, pAllocator)
  }
  #[doc(hidden)] pub fn UpdateDescriptorSetWithTemplate(&self, device: Device, descriptorSet: DescriptorSet, descriptorUpdateTemplate: DescriptorUpdateTemplate, pData: *const c_void){
    (self.UpdateDescriptorSetWithTemplate_ptr)(device, descriptorSet, descriptorUpdateTemplate, pData)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceExternalBufferProperties(&self, physicalDevice: PhysicalDevice, pExternalBufferInfo: *const PhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut ExternalBufferProperties){
    (self.GetPhysicalDeviceExternalBufferProperties_ptr)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceExternalFenceProperties(&self, physicalDevice: PhysicalDevice, pExternalFenceInfo: *const PhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut ExternalFenceProperties){
    (self.GetPhysicalDeviceExternalFenceProperties_ptr)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceExternalSemaphoreProperties(&self, physicalDevice: PhysicalDevice, pExternalSemaphoreInfo: *const PhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut ExternalSemaphoreProperties){
    (self.GetPhysicalDeviceExternalSemaphoreProperties_ptr)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)
  }
  #[doc(hidden)] pub fn GetDescriptorSetLayoutSupport(&self, device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pSupport: *mut DescriptorSetLayoutSupport){
    (self.GetDescriptorSetLayoutSupport_ptr)(device, pCreateInfo, pSupport)
  }
}
impl Drop for Core {
  fn drop(&mut self) {
    unsafe {
      core = None;
    }
  }
}


static mut core: Option<*mut Core> = None;

#[doc(hidden)] pub fn CreateInstance(pCreateInfo: *const InstanceCreateInfo, pAllocator: *const AllocationCallbacks, pInstance: *mut Instance) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateInstance_ptr)(pCreateInfo, pAllocator, pInstance)
  }
}
#[doc(hidden)] pub fn DestroyInstance(instance: Instance, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyInstance_ptr)(instance, pAllocator)
  }
}
#[doc(hidden)] pub fn EnumeratePhysicalDevices(instance: Instance, pPhysicalDeviceCount: *mut u32, pPhysicalDevices: *mut PhysicalDevice) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).EnumeratePhysicalDevices_ptr)(instance, pPhysicalDeviceCount, pPhysicalDevices)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceFeatures(physicalDevice: PhysicalDevice, pFeatures: *mut PhysicalDeviceFeatures){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceFeatures_ptr)(physicalDevice, pFeatures)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceFormatProperties(physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *mut FormatProperties){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceFormatProperties_ptr)(physicalDevice, format, pFormatProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceImageFormatProperties(physicalDevice: PhysicalDevice, format: Format, typ: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, pImageFormatProperties: *mut ImageFormatProperties) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceImageFormatProperties_ptr)(physicalDevice, format, typ, tiling, usage, flags, pImageFormatProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceProperties(physicalDevice: PhysicalDevice, pProperties: *mut PhysicalDeviceProperties){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceProperties_ptr)(physicalDevice, pProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceQueueFamilyProperties(physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut QueueFamilyProperties){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceQueueFamilyProperties_ptr)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceMemoryProperties(physicalDevice: PhysicalDevice, pMemoryProperties: *mut PhysicalDeviceMemoryProperties){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceMemoryProperties_ptr)(physicalDevice, pMemoryProperties)
  }
}
#[doc(hidden)] pub fn GetInstanceProcAddr(instance: Instance, pName: *const c_char) -> PFN_vkVoidFunction{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetInstanceProcAddr_ptr)(instance, pName)
  }
}
#[doc(hidden)] pub fn GetDeviceProcAddr(device: Device, pName: *const c_char) -> PFN_vkVoidFunction{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetDeviceProcAddr_ptr)(device, pName)
  }
}
#[doc(hidden)] pub fn CreateDevice(physicalDevice: PhysicalDevice, pCreateInfo: *const DeviceCreateInfo, pAllocator: *const AllocationCallbacks, pDevice: *mut Device) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateDevice_ptr)(physicalDevice, pCreateInfo, pAllocator, pDevice)
  }
}
#[doc(hidden)] pub fn DestroyDevice(device: Device, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyDevice_ptr)(device, pAllocator)
  }
}
#[doc(hidden)] pub fn EnumerateInstanceExtensionProperties(pLayerName: *const c_char, pPropertyCount: *mut u32, pProperties: *mut ExtensionProperties) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).EnumerateInstanceExtensionProperties_ptr)(pLayerName, pPropertyCount, pProperties)
  }
}
#[doc(hidden)] pub fn EnumerateDeviceExtensionProperties(physicalDevice: PhysicalDevice, pLayerName: *const c_char, pPropertyCount: *mut u32, pProperties: *mut ExtensionProperties) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).EnumerateDeviceExtensionProperties_ptr)(physicalDevice, pLayerName, pPropertyCount, pProperties)
  }
}
#[doc(hidden)] pub fn EnumerateInstanceLayerProperties(pPropertyCount: *mut u32, pProperties: *mut LayerProperties) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).EnumerateInstanceLayerProperties_ptr)(pPropertyCount, pProperties)
  }
}
#[doc(hidden)] pub fn EnumerateDeviceLayerProperties(physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut LayerProperties) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).EnumerateDeviceLayerProperties_ptr)(physicalDevice, pPropertyCount, pProperties)
  }
}
#[doc(hidden)] pub fn GetDeviceQueue(device: Device, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut Queue){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetDeviceQueue_ptr)(device, queueFamilyIndex, queueIndex, pQueue)
  }
}
#[doc(hidden)] pub fn QueueSubmit(queue: Queue, submitCount: u32, pSubmits: *const SubmitInfo, fence: Fence) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).QueueSubmit_ptr)(queue, submitCount, pSubmits, fence)
  }
}
#[doc(hidden)] pub fn QueueWaitIdle(queue: Queue) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).QueueWaitIdle_ptr)(queue)
  }
}
#[doc(hidden)] pub fn DeviceWaitIdle(device: Device) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DeviceWaitIdle_ptr)(device)
  }
}
#[doc(hidden)] pub fn AllocateMemory(device: Device, pAllocateInfo: *const MemoryAllocateInfo, pAllocator: *const AllocationCallbacks, pMemory: *mut DeviceMemory) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).AllocateMemory_ptr)(device, pAllocateInfo, pAllocator, pMemory)
  }
}
#[doc(hidden)] pub fn FreeMemory(device: Device, memory: DeviceMemory, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).FreeMemory_ptr)(device, memory, pAllocator)
  }
}
#[doc(hidden)] pub fn MapMemory(device: Device, memory: DeviceMemory, offset: DeviceSize, size: DeviceSize, flags: MemoryMapFlags, ppData: *mut *mut c_void) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).MapMemory_ptr)(device, memory, offset, size, flags, ppData)
  }
}
#[doc(hidden)] pub fn UnmapMemory(device: Device, memory: DeviceMemory){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).UnmapMemory_ptr)(device, memory)
  }
}
#[doc(hidden)] pub fn FlushMappedMemoryRanges(device: Device, memoryRangeCount: u32, pMemoryRanges: *const MappedMemoryRange) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).FlushMappedMemoryRanges_ptr)(device, memoryRangeCount, pMemoryRanges)
  }
}
#[doc(hidden)] pub fn InvalidateMappedMemoryRanges(device: Device, memoryRangeCount: u32, pMemoryRanges: *const MappedMemoryRange) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).InvalidateMappedMemoryRanges_ptr)(device, memoryRangeCount, pMemoryRanges)
  }
}
#[doc(hidden)] pub fn GetDeviceMemoryCommitment(device: Device, memory: DeviceMemory, pCommittedMemoryInBytes: *mut DeviceSize){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetDeviceMemoryCommitment_ptr)(device, memory, pCommittedMemoryInBytes)
  }
}
#[doc(hidden)] pub fn BindBufferMemory(device: Device, buffer: Buffer, memory: DeviceMemory, memoryOffset: DeviceSize) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).BindBufferMemory_ptr)(device, buffer, memory, memoryOffset)
  }
}
#[doc(hidden)] pub fn BindImageMemory(device: Device, image: Image, memory: DeviceMemory, memoryOffset: DeviceSize) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).BindImageMemory_ptr)(device, image, memory, memoryOffset)
  }
}
#[doc(hidden)] pub fn GetBufferMemoryRequirements(device: Device, buffer: Buffer, pMemoryRequirements: *mut MemoryRequirements){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetBufferMemoryRequirements_ptr)(device, buffer, pMemoryRequirements)
  }
}
#[doc(hidden)] pub fn GetImageMemoryRequirements(device: Device, image: Image, pMemoryRequirements: *mut MemoryRequirements){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetImageMemoryRequirements_ptr)(device, image, pMemoryRequirements)
  }
}
#[doc(hidden)] pub fn GetImageSparseMemoryRequirements(device: Device, image: Image, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut SparseImageMemoryRequirements){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetImageSparseMemoryRequirements_ptr)(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceSparseImageFormatProperties(physicalDevice: PhysicalDevice, format: Format, typ: ImageType, samples: SampleCountFlagBits, usage: ImageUsageFlags, tiling: ImageTiling, pPropertyCount: *mut u32, pProperties: *mut SparseImageFormatProperties){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceSparseImageFormatProperties_ptr)(physicalDevice, format, typ, samples, usage, tiling, pPropertyCount, pProperties)
  }
}
#[doc(hidden)] pub fn QueueBindSparse(queue: Queue, bindInfoCount: u32, pBindInfo: *const BindSparseInfo, fence: Fence) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).QueueBindSparse_ptr)(queue, bindInfoCount, pBindInfo, fence)
  }
}
#[doc(hidden)] pub fn CreateFence(device: Device, pCreateInfo: *const FenceCreateInfo, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateFence_ptr)(device, pCreateInfo, pAllocator, pFence)
  }
}
#[doc(hidden)] pub fn DestroyFence(device: Device, fence: Fence, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyFence_ptr)(device, fence, pAllocator)
  }
}
#[doc(hidden)] pub fn ResetFences(device: Device, fenceCount: u32, pFences: *const Fence) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).ResetFences_ptr)(device, fenceCount, pFences)
  }
}
#[doc(hidden)] pub fn GetFenceStatus(device: Device, fence: Fence) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetFenceStatus_ptr)(device, fence)
  }
}
#[doc(hidden)] pub fn WaitForFences(device: Device, fenceCount: u32, pFences: *const Fence, waitAll: Bool32, timeout: u64) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).WaitForFences_ptr)(device, fenceCount, pFences, waitAll, timeout)
  }
}
#[doc(hidden)] pub fn CreateSemaphore(device: Device, pCreateInfo: *const SemaphoreCreateInfo, pAllocator: *const AllocationCallbacks, pSemaphore: *mut Semaphore) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateSemaphore_ptr)(device, pCreateInfo, pAllocator, pSemaphore)
  }
}
#[doc(hidden)] pub fn DestroySemaphore(device: Device, semaphore: Semaphore, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroySemaphore_ptr)(device, semaphore, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateEvent(device: Device, pCreateInfo: *const EventCreateInfo, pAllocator: *const AllocationCallbacks, pEvent: *mut Event) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateEvent_ptr)(device, pCreateInfo, pAllocator, pEvent)
  }
}
#[doc(hidden)] pub fn DestroyEvent(device: Device, event: Event, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyEvent_ptr)(device, event, pAllocator)
  }
}
#[doc(hidden)] pub fn GetEventStatus(device: Device, event: Event) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetEventStatus_ptr)(device, event)
  }
}
#[doc(hidden)] pub fn SetEvent(device: Device, event: Event) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).SetEvent_ptr)(device, event)
  }
}
#[doc(hidden)] pub fn ResetEvent(device: Device, event: Event) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).ResetEvent_ptr)(device, event)
  }
}
#[doc(hidden)] pub fn CreateQueryPool(device: Device, pCreateInfo: *const QueryPoolCreateInfo, pAllocator: *const AllocationCallbacks, pQueryPool: *mut QueryPool) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateQueryPool_ptr)(device, pCreateInfo, pAllocator, pQueryPool)
  }
}
#[doc(hidden)] pub fn DestroyQueryPool(device: Device, queryPool: QueryPool, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyQueryPool_ptr)(device, queryPool, pAllocator)
  }
}
#[doc(hidden)] pub fn GetQueryPoolResults(device: Device, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: DeviceSize, flags: QueryResultFlags) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetQueryPoolResults_ptr)(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
  }
}
#[doc(hidden)] pub fn CreateBuffer(device: Device, pCreateInfo: *const BufferCreateInfo, pAllocator: *const AllocationCallbacks, pBuffer: *mut Buffer) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateBuffer_ptr)(device, pCreateInfo, pAllocator, pBuffer)
  }
}
#[doc(hidden)] pub fn DestroyBuffer(device: Device, buffer: Buffer, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyBuffer_ptr)(device, buffer, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateBufferView(device: Device, pCreateInfo: *const BufferViewCreateInfo, pAllocator: *const AllocationCallbacks, pView: *mut BufferView) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateBufferView_ptr)(device, pCreateInfo, pAllocator, pView)
  }
}
#[doc(hidden)] pub fn DestroyBufferView(device: Device, bufferView: BufferView, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyBufferView_ptr)(device, bufferView, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateImage(device: Device, pCreateInfo: *const ImageCreateInfo, pAllocator: *const AllocationCallbacks, pImage: *mut Image) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateImage_ptr)(device, pCreateInfo, pAllocator, pImage)
  }
}
#[doc(hidden)] pub fn DestroyImage(device: Device, image: Image, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyImage_ptr)(device, image, pAllocator)
  }
}
#[doc(hidden)] pub fn GetImageSubresourceLayout(device: Device, image: Image, pSubresource: *const ImageSubresource, pLayout: *mut SubresourceLayout){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetImageSubresourceLayout_ptr)(device, image, pSubresource, pLayout)
  }
}
#[doc(hidden)] pub fn CreateImageView(device: Device, pCreateInfo: *const ImageViewCreateInfo, pAllocator: *const AllocationCallbacks, pView: *mut ImageView) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateImageView_ptr)(device, pCreateInfo, pAllocator, pView)
  }
}
#[doc(hidden)] pub fn DestroyImageView(device: Device, imageView: ImageView, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyImageView_ptr)(device, imageView, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateShaderModule(device: Device, pCreateInfo: *const ShaderModuleCreateInfo, pAllocator: *const AllocationCallbacks, pShaderModule: *mut ShaderModule) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateShaderModule_ptr)(device, pCreateInfo, pAllocator, pShaderModule)
  }
}
#[doc(hidden)] pub fn DestroyShaderModule(device: Device, shaderModule: ShaderModule, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyShaderModule_ptr)(device, shaderModule, pAllocator)
  }
}
#[doc(hidden)] pub fn CreatePipelineCache(device: Device, pCreateInfo: *const PipelineCacheCreateInfo, pAllocator: *const AllocationCallbacks, pPipelineCache: *mut PipelineCache) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreatePipelineCache_ptr)(device, pCreateInfo, pAllocator, pPipelineCache)
  }
}
#[doc(hidden)] pub fn DestroyPipelineCache(device: Device, pipelineCache: PipelineCache, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyPipelineCache_ptr)(device, pipelineCache, pAllocator)
  }
}
#[doc(hidden)] pub fn GetPipelineCacheData(device: Device, pipelineCache: PipelineCache, pDataSize: *mut usize, pData: *mut c_void) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPipelineCacheData_ptr)(device, pipelineCache, pDataSize, pData)
  }
}
#[doc(hidden)] pub fn MergePipelineCaches(device: Device, dstCache: PipelineCache, srcCacheCount: u32, pSrcCaches: *const PipelineCache) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).MergePipelineCaches_ptr)(device, dstCache, srcCacheCount, pSrcCaches)
  }
}
#[doc(hidden)] pub fn CreateGraphicsPipelines(device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const GraphicsPipelineCreateInfo, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateGraphicsPipelines_ptr)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
  }
}
#[doc(hidden)] pub fn CreateComputePipelines(device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const ComputePipelineCreateInfo, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateComputePipelines_ptr)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
  }
}
#[doc(hidden)] pub fn DestroyPipeline(device: Device, pipeline: Pipeline, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyPipeline_ptr)(device, pipeline, pAllocator)
  }
}
#[doc(hidden)] pub fn CreatePipelineLayout(device: Device, pCreateInfo: *const PipelineLayoutCreateInfo, pAllocator: *const AllocationCallbacks, pPipelineLayout: *mut PipelineLayout) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreatePipelineLayout_ptr)(device, pCreateInfo, pAllocator, pPipelineLayout)
  }
}
#[doc(hidden)] pub fn DestroyPipelineLayout(device: Device, pipelineLayout: PipelineLayout, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyPipelineLayout_ptr)(device, pipelineLayout, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateSampler(device: Device, pCreateInfo: *const SamplerCreateInfo, pAllocator: *const AllocationCallbacks, pSampler: *mut Sampler) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateSampler_ptr)(device, pCreateInfo, pAllocator, pSampler)
  }
}
#[doc(hidden)] pub fn DestroySampler(device: Device, sampler: Sampler, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroySampler_ptr)(device, sampler, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateDescriptorSetLayout(device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pAllocator: *const AllocationCallbacks, pSetLayout: *mut DescriptorSetLayout) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateDescriptorSetLayout_ptr)(device, pCreateInfo, pAllocator, pSetLayout)
  }
}
#[doc(hidden)] pub fn DestroyDescriptorSetLayout(device: Device, descriptorSetLayout: DescriptorSetLayout, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyDescriptorSetLayout_ptr)(device, descriptorSetLayout, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateDescriptorPool(device: Device, pCreateInfo: *const DescriptorPoolCreateInfo, pAllocator: *const AllocationCallbacks, pDescriptorPool: *mut DescriptorPool) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateDescriptorPool_ptr)(device, pCreateInfo, pAllocator, pDescriptorPool)
  }
}
#[doc(hidden)] pub fn DestroyDescriptorPool(device: Device, descriptorPool: DescriptorPool, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyDescriptorPool_ptr)(device, descriptorPool, pAllocator)
  }
}
#[doc(hidden)] pub fn ResetDescriptorPool(device: Device, descriptorPool: DescriptorPool, flags: DescriptorPoolResetFlags) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).ResetDescriptorPool_ptr)(device, descriptorPool, flags)
  }
}
#[doc(hidden)] pub fn AllocateDescriptorSets(device: Device, pAllocateInfo: *const DescriptorSetAllocateInfo, pDescriptorSets: *mut DescriptorSet) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).AllocateDescriptorSets_ptr)(device, pAllocateInfo, pDescriptorSets)
  }
}
#[doc(hidden)] pub fn FreeDescriptorSets(device: Device, descriptorPool: DescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const DescriptorSet) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).FreeDescriptorSets_ptr)(device, descriptorPool, descriptorSetCount, pDescriptorSets)
  }
}
#[doc(hidden)] pub fn UpdateDescriptorSets(device: Device, descriptorWriteCount: u32, pDescriptorWrites: *const WriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const CopyDescriptorSet){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).UpdateDescriptorSets_ptr)(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)
  }
}
#[doc(hidden)] pub fn CreateFramebuffer(device: Device, pCreateInfo: *const FramebufferCreateInfo, pAllocator: *const AllocationCallbacks, pFramebuffer: *mut Framebuffer) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateFramebuffer_ptr)(device, pCreateInfo, pAllocator, pFramebuffer)
  }
}
#[doc(hidden)] pub fn DestroyFramebuffer(device: Device, framebuffer: Framebuffer, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyFramebuffer_ptr)(device, framebuffer, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateRenderPass(device: Device, pCreateInfo: *const RenderPassCreateInfo, pAllocator: *const AllocationCallbacks, pRenderPass: *mut RenderPass) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateRenderPass_ptr)(device, pCreateInfo, pAllocator, pRenderPass)
  }
}
#[doc(hidden)] pub fn DestroyRenderPass(device: Device, renderPass: RenderPass, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyRenderPass_ptr)(device, renderPass, pAllocator)
  }
}
#[doc(hidden)] pub fn GetRenderAreaGranularity(device: Device, renderPass: RenderPass, pGranularity: *mut Extent2D){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetRenderAreaGranularity_ptr)(device, renderPass, pGranularity)
  }
}
#[doc(hidden)] pub fn CreateCommandPool(device: Device, pCreateInfo: *const CommandPoolCreateInfo, pAllocator: *const AllocationCallbacks, pCommandPool: *mut CommandPool) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateCommandPool_ptr)(device, pCreateInfo, pAllocator, pCommandPool)
  }
}
#[doc(hidden)] pub fn DestroyCommandPool(device: Device, commandPool: CommandPool, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyCommandPool_ptr)(device, commandPool, pAllocator)
  }
}
#[doc(hidden)] pub fn ResetCommandPool(device: Device, commandPool: CommandPool, flags: CommandPoolResetFlags) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).ResetCommandPool_ptr)(device, commandPool, flags)
  }
}
#[doc(hidden)] pub fn AllocateCommandBuffers(device: Device, pAllocateInfo: *const CommandBufferAllocateInfo, pCommandBuffers: *mut CommandBuffer) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).AllocateCommandBuffers_ptr)(device, pAllocateInfo, pCommandBuffers)
  }
}
#[doc(hidden)] pub fn FreeCommandBuffers(device: Device, commandPool: CommandPool, commandBufferCount: u32, pCommandBuffers: *const CommandBuffer){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).FreeCommandBuffers_ptr)(device, commandPool, commandBufferCount, pCommandBuffers)
  }
}
#[doc(hidden)] pub fn BeginCommandBuffer(commandBuffer: CommandBuffer, pBeginInfo: *const CommandBufferBeginInfo) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).BeginCommandBuffer_ptr)(commandBuffer, pBeginInfo)
  }
}
#[doc(hidden)] pub fn EndCommandBuffer(commandBuffer: CommandBuffer) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).EndCommandBuffer_ptr)(commandBuffer)
  }
}
#[doc(hidden)] pub fn ResetCommandBuffer(commandBuffer: CommandBuffer, flags: CommandBufferResetFlags) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).ResetCommandBuffer_ptr)(commandBuffer, flags)
  }
}
#[doc(hidden)] pub fn CmdBindPipeline(commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, pipeline: Pipeline){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdBindPipeline_ptr)(commandBuffer, pipelineBindPoint, pipeline)
  }
}
#[doc(hidden)] pub fn CmdSetViewport(commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const Viewport){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetViewport_ptr)(commandBuffer, firstViewport, viewportCount, pViewports)
  }
}
#[doc(hidden)] pub fn CmdSetScissor(commandBuffer: CommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const Rect2D){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetScissor_ptr)(commandBuffer, firstScissor, scissorCount, pScissors)
  }
}
#[doc(hidden)] pub fn CmdSetLineWidth(commandBuffer: CommandBuffer, lineWidth: f32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetLineWidth_ptr)(commandBuffer, lineWidth)
  }
}
#[doc(hidden)] pub fn CmdSetDepthBias(commandBuffer: CommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetDepthBias_ptr)(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
  }
}
#[doc(hidden)] pub fn CmdSetBlendConstants(commandBuffer: CommandBuffer, blendConstants: [f32; 4]){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetBlendConstants_ptr)(commandBuffer, blendConstants)
  }
}
#[doc(hidden)] pub fn CmdSetDepthBounds(commandBuffer: CommandBuffer, minDepthBounds: f32, maxDepthBounds: f32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetDepthBounds_ptr)(commandBuffer, minDepthBounds, maxDepthBounds)
  }
}
#[doc(hidden)] pub fn CmdSetStencilCompareMask(commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, compareMask: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetStencilCompareMask_ptr)(commandBuffer, faceMask, compareMask)
  }
}
#[doc(hidden)] pub fn CmdSetStencilWriteMask(commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, writeMask: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetStencilWriteMask_ptr)(commandBuffer, faceMask, writeMask)
  }
}
#[doc(hidden)] pub fn CmdSetStencilReference(commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, reference: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetStencilReference_ptr)(commandBuffer, faceMask, reference)
  }
}
#[doc(hidden)] pub fn CmdBindDescriptorSets(commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const DescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdBindDescriptorSets_ptr)(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)
  }
}
#[doc(hidden)] pub fn CmdBindIndexBuffer(commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, indexType: IndexType){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdBindIndexBuffer_ptr)(commandBuffer, buffer, offset, indexType)
  }
}
#[doc(hidden)] pub fn CmdBindVertexBuffers(commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const Buffer, pOffsets: *const DeviceSize){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdBindVertexBuffers_ptr)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
  }
}
#[doc(hidden)] pub fn CmdDraw(commandBuffer: CommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdDraw_ptr)(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
  }
}
#[doc(hidden)] pub fn CmdDrawIndexed(commandBuffer: CommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdDrawIndexed_ptr)(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
  }
}
#[doc(hidden)] pub fn CmdDrawIndirect(commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdDrawIndirect_ptr)(commandBuffer, buffer, offset, drawCount, stride)
  }
}
#[doc(hidden)] pub fn CmdDrawIndexedIndirect(commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdDrawIndexedIndirect_ptr)(commandBuffer, buffer, offset, drawCount, stride)
  }
}
#[doc(hidden)] pub fn CmdDispatch(commandBuffer: CommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdDispatch_ptr)(commandBuffer, groupCountX, groupCountY, groupCountZ)
  }
}
#[doc(hidden)] pub fn CmdDispatchIndirect(commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdDispatchIndirect_ptr)(commandBuffer, buffer, offset)
  }
}
#[doc(hidden)] pub fn CmdCopyBuffer(commandBuffer: CommandBuffer, srcBuffer: Buffer, dstBuffer: Buffer, regionCount: u32, pRegions: *const BufferCopy){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdCopyBuffer_ptr)(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
  }
}
#[doc(hidden)] pub fn CmdCopyImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageCopy){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdCopyImage_ptr)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
  }
}
#[doc(hidden)] pub fn CmdBlitImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageBlit, filter: Filter){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdBlitImage_ptr)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)
  }
}
#[doc(hidden)] pub fn CmdCopyBufferToImage(commandBuffer: CommandBuffer, srcBuffer: Buffer, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const BufferImageCopy){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdCopyBufferToImage_ptr)(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
  }
}
#[doc(hidden)] pub fn CmdCopyImageToBuffer(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstBuffer: Buffer, regionCount: u32, pRegions: *const BufferImageCopy){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdCopyImageToBuffer_ptr)(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
  }
}
#[doc(hidden)] pub fn CmdUpdateBuffer(commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, dataSize: DeviceSize, pData: *const c_void){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdUpdateBuffer_ptr)(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
  }
}
#[doc(hidden)] pub fn CmdFillBuffer(commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, size: DeviceSize, data: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdFillBuffer_ptr)(commandBuffer, dstBuffer, dstOffset, size, data)
  }
}
#[doc(hidden)] pub fn CmdClearColorImage(commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pColor: *const ClearColorValue, rangeCount: u32, pRanges: *const ImageSubresourceRange){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdClearColorImage_ptr)(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
  }
}
#[doc(hidden)] pub fn CmdClearDepthStencilImage(commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pDepthStencil: *const ClearDepthStencilValue, rangeCount: u32, pRanges: *const ImageSubresourceRange){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdClearDepthStencilImage_ptr)(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
  }
}
#[doc(hidden)] pub fn CmdClearAttachments(commandBuffer: CommandBuffer, attachmentCount: u32, pAttachments: *const ClearAttachment, rectCount: u32, pRects: *const ClearRect){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdClearAttachments_ptr)(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
  }
}
#[doc(hidden)] pub fn CmdResolveImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: *const ImageResolve){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdResolveImage_ptr)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
  }
}
#[doc(hidden)] pub fn CmdSetEvent(commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetEvent_ptr)(commandBuffer, event, stageMask)
  }
}
#[doc(hidden)] pub fn CmdResetEvent(commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdResetEvent_ptr)(commandBuffer, event, stageMask)
  }
}
#[doc(hidden)] pub fn CmdWaitEvents(commandBuffer: CommandBuffer, eventCount: u32, pEvents: *const Event, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const ImageMemoryBarrier){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdWaitEvents_ptr)(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
  }
}
#[doc(hidden)] pub fn CmdPipelineBarrier(commandBuffer: CommandBuffer, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, dependencyFlags: DependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const ImageMemoryBarrier){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdPipelineBarrier_ptr)(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
  }
}
#[doc(hidden)] pub fn CmdBeginQuery(commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdBeginQuery_ptr)(commandBuffer, queryPool, query, flags)
  }
}
#[doc(hidden)] pub fn CmdEndQuery(commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdEndQuery_ptr)(commandBuffer, queryPool, query)
  }
}
#[doc(hidden)] pub fn CmdResetQueryPool(commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdResetQueryPool_ptr)(commandBuffer, queryPool, firstQuery, queryCount)
  }
}
#[doc(hidden)] pub fn CmdWriteTimestamp(commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlagBits, queryPool: QueryPool, query: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdWriteTimestamp_ptr)(commandBuffer, pipelineStage, queryPool, query)
  }
}
#[doc(hidden)] pub fn CmdCopyQueryPoolResults(commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dstBuffer: Buffer, dstOffset: DeviceSize, stride: DeviceSize, flags: QueryResultFlags){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdCopyQueryPoolResults_ptr)(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
  }
}
#[doc(hidden)] pub fn CmdPushConstants(commandBuffer: CommandBuffer, layout: PipelineLayout, stageFlags: ShaderStageFlags, offset: u32, size: u32, pValues: *const c_void){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdPushConstants_ptr)(commandBuffer, layout, stageFlags, offset, size, pValues)
  }
}
#[doc(hidden)] pub fn CmdBeginRenderPass(commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, contents: SubpassContents){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdBeginRenderPass_ptr)(commandBuffer, pRenderPassBegin, contents)
  }
}
#[doc(hidden)] pub fn CmdNextSubpass(commandBuffer: CommandBuffer, contents: SubpassContents){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdNextSubpass_ptr)(commandBuffer, contents)
  }
}
#[doc(hidden)] pub fn CmdEndRenderPass(commandBuffer: CommandBuffer){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdEndRenderPass_ptr)(commandBuffer)
  }
}
#[doc(hidden)] pub fn CmdExecuteCommands(commandBuffer: CommandBuffer, commandBufferCount: u32, pCommandBuffers: *const CommandBuffer){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdExecuteCommands_ptr)(commandBuffer, commandBufferCount, pCommandBuffers)
  }
}
#[doc(hidden)] pub fn EnumerateInstanceVersion(pApiVersion: *mut u32) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).EnumerateInstanceVersion_ptr)(pApiVersion)
  }
}
#[doc(hidden)] pub fn BindBufferMemory2(device: Device, bindInfoCount: u32, pBindInfos: *const BindBufferMemoryInfo) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).BindBufferMemory2_ptr)(device, bindInfoCount, pBindInfos)
  }
}
#[doc(hidden)] pub fn BindImageMemory2(device: Device, bindInfoCount: u32, pBindInfos: *const BindImageMemoryInfo) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).BindImageMemory2_ptr)(device, bindInfoCount, pBindInfos)
  }
}
#[doc(hidden)] pub fn GetDeviceGroupPeerMemoryFeatures(device: Device, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut PeerMemoryFeatureFlags){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetDeviceGroupPeerMemoryFeatures_ptr)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)
  }
}
#[doc(hidden)] pub fn CmdSetDeviceMask(commandBuffer: CommandBuffer, deviceMask: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdSetDeviceMask_ptr)(commandBuffer, deviceMask)
  }
}
#[doc(hidden)] pub fn CmdDispatchBase(commandBuffer: CommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CmdDispatchBase_ptr)(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)
  }
}
#[doc(hidden)] pub fn EnumeratePhysicalDeviceGroups(instance: Instance, pPhysicalDeviceGroupCount: *mut u32, pPhysicalDeviceGroupProperties: *mut PhysicalDeviceGroupProperties) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).EnumeratePhysicalDeviceGroups_ptr)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)
  }
}
#[doc(hidden)] pub fn GetImageMemoryRequirements2(device: Device, pInfo: *const ImageMemoryRequirementsInfo2, pMemoryRequirements: *mut MemoryRequirements2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetImageMemoryRequirements2_ptr)(device, pInfo, pMemoryRequirements)
  }
}
#[doc(hidden)] pub fn GetBufferMemoryRequirements2(device: Device, pInfo: *const BufferMemoryRequirementsInfo2, pMemoryRequirements: *mut MemoryRequirements2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetBufferMemoryRequirements2_ptr)(device, pInfo, pMemoryRequirements)
  }
}
#[doc(hidden)] pub fn GetImageSparseMemoryRequirements2(device: Device, pInfo: *const ImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut SparseImageMemoryRequirements2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetImageSparseMemoryRequirements2_ptr)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceFeatures2(physicalDevice: PhysicalDevice, pFeatures: *mut PhysicalDeviceFeatures2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceFeatures2_ptr)(physicalDevice, pFeatures)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceProperties2(physicalDevice: PhysicalDevice, pProperties: *mut PhysicalDeviceProperties2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceProperties2_ptr)(physicalDevice, pProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceFormatProperties2(physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *mut FormatProperties2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceFormatProperties2_ptr)(physicalDevice, format, pFormatProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceImageFormatProperties2(physicalDevice: PhysicalDevice, pImageFormatInfo: *const PhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut ImageFormatProperties2) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceImageFormatProperties2_ptr)(physicalDevice, pImageFormatInfo, pImageFormatProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceQueueFamilyProperties2(physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut QueueFamilyProperties2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceQueueFamilyProperties2_ptr)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceMemoryProperties2(physicalDevice: PhysicalDevice, pMemoryProperties: *mut PhysicalDeviceMemoryProperties2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceMemoryProperties2_ptr)(physicalDevice, pMemoryProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice: PhysicalDevice, pFormatInfo: *const PhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut u32, pProperties: *mut SparseImageFormatProperties2){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceSparseImageFormatProperties2_ptr)(physicalDevice, pFormatInfo, pPropertyCount, pProperties)
  }
}
#[doc(hidden)] pub fn TrimCommandPool(device: Device, commandPool: CommandPool, flags: CommandPoolTrimFlags){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).TrimCommandPool_ptr)(device, commandPool, flags)
  }
}
#[doc(hidden)] pub fn GetDeviceQueue2(device: Device, pQueueInfo: *const DeviceQueueInfo2, pQueue: *mut Queue){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetDeviceQueue2_ptr)(device, pQueueInfo, pQueue)
  }
}
#[doc(hidden)] pub fn CreateSamplerYcbcrConversion(device: Device, pCreateInfo: *const SamplerYcbcrConversionCreateInfo, pAllocator: *const AllocationCallbacks, pYcbcrConversion: *mut SamplerYcbcrConversion) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateSamplerYcbcrConversion_ptr)(device, pCreateInfo, pAllocator, pYcbcrConversion)
  }
}
#[doc(hidden)] pub fn DestroySamplerYcbcrConversion(device: Device, ycbcrConversion: SamplerYcbcrConversion, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroySamplerYcbcrConversion_ptr)(device, ycbcrConversion, pAllocator)
  }
}
#[doc(hidden)] pub fn CreateDescriptorUpdateTemplate(device: Device, pCreateInfo: *const DescriptorUpdateTemplateCreateInfo, pAllocator: *const AllocationCallbacks, pDescriptorUpdateTemplate: *mut DescriptorUpdateTemplate) -> Result{
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).CreateDescriptorUpdateTemplate_ptr)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)
  }
}
#[doc(hidden)] pub fn DestroyDescriptorUpdateTemplate(device: Device, descriptorUpdateTemplate: DescriptorUpdateTemplate, pAllocator: *const AllocationCallbacks){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).DestroyDescriptorUpdateTemplate_ptr)(device, descriptorUpdateTemplate, pAllocator)
  }
}
#[doc(hidden)] pub fn UpdateDescriptorSetWithTemplate(device: Device, descriptorSet: DescriptorSet, descriptorUpdateTemplate: DescriptorUpdateTemplate, pData: *const c_void){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).UpdateDescriptorSetWithTemplate_ptr)(device, descriptorSet, descriptorUpdateTemplate, pData)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceExternalBufferProperties(physicalDevice: PhysicalDevice, pExternalBufferInfo: *const PhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut ExternalBufferProperties){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceExternalBufferProperties_ptr)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceExternalFenceProperties(physicalDevice: PhysicalDevice, pExternalFenceInfo: *const PhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut ExternalFenceProperties){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceExternalFenceProperties_ptr)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)
  }
}
#[doc(hidden)] pub fn GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice: PhysicalDevice, pExternalSemaphoreInfo: *const PhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut ExternalSemaphoreProperties){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetPhysicalDeviceExternalSemaphoreProperties_ptr)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)
  }
}
#[doc(hidden)] pub fn GetDescriptorSetLayoutSupport(device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pSupport: *mut DescriptorSetLayoutSupport){
  unsafe {
    let ptr = core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core");
    ((*ptr).GetDescriptorSetLayoutSupport_ptr)(device, pCreateInfo, pSupport)
  }
}


/// Vulkan instance extensions
///
/// This struct is used to initialize vulkan instance extensions and holds function pointers to them.
/// Function pointers are initialized during construction.
#[derive(Clone,Copy)]pub struct InstanceExtensions {
  #[allow(dead_code)]
  hinstance: Instance,
  DestroySurfaceKHR_ptr: extern "system" fn (instance: Instance, surface: SurfaceKHR, pAllocator: *const AllocationCallbacks),
  GetPhysicalDeviceSurfaceSupportKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, surface: SurfaceKHR, pSupported: *mut Bool32) -> Result,
  GetPhysicalDeviceSurfaceCapabilitiesKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceCapabilities: *mut SurfaceCapabilitiesKHR) -> Result,
  GetPhysicalDeviceSurfaceFormatsKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut SurfaceFormatKHR) -> Result,
  GetPhysicalDeviceSurfacePresentModesKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pPresentModeCount: *mut u32, pPresentModes: *mut PresentModeKHR) -> Result,
  GetPhysicalDeviceDisplayPropertiesKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPropertiesKHR) -> Result,
  GetPhysicalDeviceDisplayPlanePropertiesKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPlanePropertiesKHR) -> Result,
  GetDisplayPlaneSupportedDisplaysKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, planeIndex: u32, pDisplayCount: *mut u32, pDisplays: *mut DisplayKHR) -> Result,
  GetDisplayModePropertiesKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pPropertyCount: *mut u32, pProperties: *mut DisplayModePropertiesKHR) -> Result,
  CreateDisplayModeKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pCreateInfo: *const DisplayModeCreateInfoKHR, pAllocator: *const AllocationCallbacks, pMode: *mut DisplayModeKHR) -> Result,
  GetDisplayPlaneCapabilitiesKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, mode: DisplayModeKHR, planeIndex: u32, pCapabilities: *mut DisplayPlaneCapabilitiesKHR) -> Result,
  CreateDisplayPlaneSurfaceKHR_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const DisplaySurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  CreateXlibSurfaceKHR_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const XlibSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  GetPhysicalDeviceXlibPresentationSupportKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, dpy: *mut Display, visualID: VisualID) -> Bool32,
  CreateXcbSurfaceKHR_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const XcbSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  GetPhysicalDeviceXcbPresentationSupportKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, connection: *mut xcb_connection_t, visual_id: xcb_visualid_t) -> Bool32,
  CreateWaylandSurfaceKHR_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const WaylandSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  GetPhysicalDeviceWaylandPresentationSupportKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, display: *mut wl_display) -> Bool32,
  CreateAndroidSurfaceKHR_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const AndroidSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  CreateWin32SurfaceKHR_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const Win32SurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  GetPhysicalDeviceWin32PresentationSupportKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32) -> Bool32,
  CreateDebugReportCallbackEXT_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const DebugReportCallbackCreateInfoEXT, pAllocator: *const AllocationCallbacks, pCallback: *mut DebugReportCallbackEXT) -> Result,
  DestroyDebugReportCallbackEXT_ptr: extern "system" fn (instance: Instance, callback: DebugReportCallbackEXT, pAllocator: *const AllocationCallbacks),
  DebugReportMessageEXT_ptr: extern "system" fn (instance: Instance, flags: DebugReportFlagsEXT, objectType: DebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *const c_char, pMessage: *const c_char),
  GetPhysicalDeviceExternalImageFormatPropertiesNV_ptr: extern "system" fn (physicalDevice: PhysicalDevice, format: Format, typ: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, externalHandleType: ExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut ExternalImageFormatPropertiesNV) -> Result,
  CreateViSurfaceNN_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const ViSurfaceCreateInfoNN, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  ReleaseDisplayEXT_ptr: extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR) -> Result,
  AcquireXlibDisplayEXT_ptr: extern "system" fn (physicalDevice: PhysicalDevice, dpy: *mut Display, display: DisplayKHR) -> Result,
  GetRandROutputDisplayEXT_ptr: extern "system" fn (physicalDevice: PhysicalDevice, dpy: *mut Display, rrOutput: RROutput, pDisplay: *mut DisplayKHR) -> Result,
  GetPhysicalDeviceSurfaceCapabilities2EXT_ptr: extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceCapabilities: *mut SurfaceCapabilities2EXT) -> Result,
  GetPhysicalDeviceSurfaceCapabilities2KHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut SurfaceCapabilities2KHR) -> Result,
  GetPhysicalDeviceSurfaceFormats2KHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut SurfaceFormat2KHR) -> Result,
  GetPhysicalDeviceDisplayProperties2KHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayProperties2KHR) -> Result,
  GetPhysicalDeviceDisplayPlaneProperties2KHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPlaneProperties2KHR) -> Result,
  GetDisplayModeProperties2KHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pPropertyCount: *mut u32, pProperties: *mut DisplayModeProperties2KHR) -> Result,
  GetDisplayPlaneCapabilities2KHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pDisplayPlaneInfo: *const DisplayPlaneInfo2KHR, pCapabilities: *mut DisplayPlaneCapabilities2KHR) -> Result,
  CreateIOSSurfaceMVK_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const IOSSurfaceCreateInfoMVK, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  CreateMacOSSurfaceMVK_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const MacOSSurfaceCreateInfoMVK, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
  SetDebugUtilsObjectNameEXT_ptr: extern "system" fn (device: Device, pNameInfo: *const DebugUtilsObjectNameInfoEXT) -> Result,
  SetDebugUtilsObjectTagEXT_ptr: extern "system" fn (device: Device, pTagInfo: *const DebugUtilsObjectTagInfoEXT) -> Result,
  QueueBeginDebugUtilsLabelEXT_ptr: extern "system" fn (queue: Queue, pLabelInfo: *const DebugUtilsLabelEXT),
  QueueEndDebugUtilsLabelEXT_ptr: extern "system" fn (queue: Queue),
  QueueInsertDebugUtilsLabelEXT_ptr: extern "system" fn (queue: Queue, pLabelInfo: *const DebugUtilsLabelEXT),
  CmdBeginDebugUtilsLabelEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, pLabelInfo: *const DebugUtilsLabelEXT),
  CmdEndDebugUtilsLabelEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer),
  CmdInsertDebugUtilsLabelEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, pLabelInfo: *const DebugUtilsLabelEXT),
  CreateDebugUtilsMessengerEXT_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const DebugUtilsMessengerCreateInfoEXT, pAllocator: *const AllocationCallbacks, pMessenger: *mut DebugUtilsMessengerEXT) -> Result,
  DestroyDebugUtilsMessengerEXT_ptr: extern "system" fn (instance: Instance, messenger: DebugUtilsMessengerEXT, pAllocator: *const AllocationCallbacks),
  SubmitDebugUtilsMessageEXT_ptr: extern "system" fn (instance: Instance, messageSeverity: DebugUtilsMessageSeverityFlagBitsEXT, messageTypes: DebugUtilsMessageTypeFlagsEXT, pCallbackData: *const DebugUtilsMessengerCallbackDataEXT),
  CreateImagePipeSurfaceFUCHSIA_ptr: extern "system" fn (instance: Instance, pCreateInfo: *const ImagePipeSurfaceCreateInfoFUCHSIA, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result,
}


extern "system" fn DestroySurfaceKHR_panic(_instance: Instance, _surface: SurfaceKHR, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroySurfaceKHR not loaded")
}
extern "system" fn GetPhysicalDeviceSurfaceSupportKHR_panic(_physicalDevice: PhysicalDevice, _queueFamilyIndex: u32, _surface: SurfaceKHR, _pSupported: *mut Bool32) -> Result{
    panic!("extension vkGetPhysicalDeviceSurfaceSupportKHR not loaded")
}
extern "system" fn GetPhysicalDeviceSurfaceCapabilitiesKHR_panic(_physicalDevice: PhysicalDevice, _surface: SurfaceKHR, _pSurfaceCapabilities: *mut SurfaceCapabilitiesKHR) -> Result{
    panic!("extension vkGetPhysicalDeviceSurfaceCapabilitiesKHR not loaded")
}
extern "system" fn GetPhysicalDeviceSurfaceFormatsKHR_panic(_physicalDevice: PhysicalDevice, _surface: SurfaceKHR, _pSurfaceFormatCount: *mut u32, _pSurfaceFormats: *mut SurfaceFormatKHR) -> Result{
    panic!("extension vkGetPhysicalDeviceSurfaceFormatsKHR not loaded")
}
extern "system" fn GetPhysicalDeviceSurfacePresentModesKHR_panic(_physicalDevice: PhysicalDevice, _surface: SurfaceKHR, _pPresentModeCount: *mut u32, _pPresentModes: *mut PresentModeKHR) -> Result{
    panic!("extension vkGetPhysicalDeviceSurfacePresentModesKHR not loaded")
}
extern "system" fn GetPhysicalDeviceDisplayPropertiesKHR_panic(_physicalDevice: PhysicalDevice, _pPropertyCount: *mut u32, _pProperties: *mut DisplayPropertiesKHR) -> Result{
    panic!("extension vkGetPhysicalDeviceDisplayPropertiesKHR not loaded")
}
extern "system" fn GetPhysicalDeviceDisplayPlanePropertiesKHR_panic(_physicalDevice: PhysicalDevice, _pPropertyCount: *mut u32, _pProperties: *mut DisplayPlanePropertiesKHR) -> Result{
    panic!("extension vkGetPhysicalDeviceDisplayPlanePropertiesKHR not loaded")
}
extern "system" fn GetDisplayPlaneSupportedDisplaysKHR_panic(_physicalDevice: PhysicalDevice, _planeIndex: u32, _pDisplayCount: *mut u32, _pDisplays: *mut DisplayKHR) -> Result{
    panic!("extension vkGetDisplayPlaneSupportedDisplaysKHR not loaded")
}
extern "system" fn GetDisplayModePropertiesKHR_panic(_physicalDevice: PhysicalDevice, _display: DisplayKHR, _pPropertyCount: *mut u32, _pProperties: *mut DisplayModePropertiesKHR) -> Result{
    panic!("extension vkGetDisplayModePropertiesKHR not loaded")
}
extern "system" fn CreateDisplayModeKHR_panic(_physicalDevice: PhysicalDevice, _display: DisplayKHR, _pCreateInfo: *const DisplayModeCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pMode: *mut DisplayModeKHR) -> Result{
    panic!("extension vkCreateDisplayModeKHR not loaded")
}
extern "system" fn GetDisplayPlaneCapabilitiesKHR_panic(_physicalDevice: PhysicalDevice, _mode: DisplayModeKHR, _planeIndex: u32, _pCapabilities: *mut DisplayPlaneCapabilitiesKHR) -> Result{
    panic!("extension vkGetDisplayPlaneCapabilitiesKHR not loaded")
}
extern "system" fn CreateDisplayPlaneSurfaceKHR_panic(_instance: Instance, _pCreateInfo: *const DisplaySurfaceCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateDisplayPlaneSurfaceKHR not loaded")
}
extern "system" fn CreateXlibSurfaceKHR_panic(_instance: Instance, _pCreateInfo: *const XlibSurfaceCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateXlibSurfaceKHR not loaded")
}
extern "system" fn GetPhysicalDeviceXlibPresentationSupportKHR_panic(_physicalDevice: PhysicalDevice, _queueFamilyIndex: u32, _dpy: *mut Display, _visualID: VisualID) -> Bool32{
    panic!("extension vkGetPhysicalDeviceXlibPresentationSupportKHR not loaded")
}
extern "system" fn CreateXcbSurfaceKHR_panic(_instance: Instance, _pCreateInfo: *const XcbSurfaceCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateXcbSurfaceKHR not loaded")
}
extern "system" fn GetPhysicalDeviceXcbPresentationSupportKHR_panic(_physicalDevice: PhysicalDevice, _queueFamilyIndex: u32, _connection: *mut xcb_connection_t, _visual_id: xcb_visualid_t) -> Bool32{
    panic!("extension vkGetPhysicalDeviceXcbPresentationSupportKHR not loaded")
}
extern "system" fn CreateWaylandSurfaceKHR_panic(_instance: Instance, _pCreateInfo: *const WaylandSurfaceCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateWaylandSurfaceKHR not loaded")
}
extern "system" fn GetPhysicalDeviceWaylandPresentationSupportKHR_panic(_physicalDevice: PhysicalDevice, _queueFamilyIndex: u32, _display: *mut wl_display) -> Bool32{
    panic!("extension vkGetPhysicalDeviceWaylandPresentationSupportKHR not loaded")
}
extern "system" fn CreateAndroidSurfaceKHR_panic(_instance: Instance, _pCreateInfo: *const AndroidSurfaceCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateAndroidSurfaceKHR not loaded")
}
extern "system" fn CreateWin32SurfaceKHR_panic(_instance: Instance, _pCreateInfo: *const Win32SurfaceCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateWin32SurfaceKHR not loaded")
}
extern "system" fn GetPhysicalDeviceWin32PresentationSupportKHR_panic(_physicalDevice: PhysicalDevice, _queueFamilyIndex: u32) -> Bool32{
    panic!("extension vkGetPhysicalDeviceWin32PresentationSupportKHR not loaded")
}
extern "system" fn CreateDebugReportCallbackEXT_panic(_instance: Instance, _pCreateInfo: *const DebugReportCallbackCreateInfoEXT, _pAllocator: *const AllocationCallbacks, _pCallback: *mut DebugReportCallbackEXT) -> Result{
    panic!("extension vkCreateDebugReportCallbackEXT not loaded")
}
extern "system" fn DestroyDebugReportCallbackEXT_panic(_instance: Instance, _callback: DebugReportCallbackEXT, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyDebugReportCallbackEXT not loaded")
}
extern "system" fn DebugReportMessageEXT_panic(_instance: Instance, _flags: DebugReportFlagsEXT, _objectType: DebugReportObjectTypeEXT, _object: u64, _location: usize, _messageCode: i32, _pLayerPrefix: *const c_char, _pMessage: *const c_char){
    panic!("extension vkDebugReportMessageEXT not loaded")
}
extern "system" fn GetPhysicalDeviceExternalImageFormatPropertiesNV_panic(_physicalDevice: PhysicalDevice, _format: Format, _typ: ImageType, _tiling: ImageTiling, _usage: ImageUsageFlags, _flags: ImageCreateFlags, _externalHandleType: ExternalMemoryHandleTypeFlagsNV, _pExternalImageFormatProperties: *mut ExternalImageFormatPropertiesNV) -> Result{
    panic!("extension vkGetPhysicalDeviceExternalImageFormatPropertiesNV not loaded")
}
extern "system" fn CreateViSurfaceNN_panic(_instance: Instance, _pCreateInfo: *const ViSurfaceCreateInfoNN, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateViSurfaceNN not loaded")
}
extern "system" fn ReleaseDisplayEXT_panic(_physicalDevice: PhysicalDevice, _display: DisplayKHR) -> Result{
    panic!("extension vkReleaseDisplayEXT not loaded")
}
extern "system" fn AcquireXlibDisplayEXT_panic(_physicalDevice: PhysicalDevice, _dpy: *mut Display, _display: DisplayKHR) -> Result{
    panic!("extension vkAcquireXlibDisplayEXT not loaded")
}
extern "system" fn GetRandROutputDisplayEXT_panic(_physicalDevice: PhysicalDevice, _dpy: *mut Display, _rrOutput: RROutput, _pDisplay: *mut DisplayKHR) -> Result{
    panic!("extension vkGetRandROutputDisplayEXT not loaded")
}
extern "system" fn GetPhysicalDeviceSurfaceCapabilities2EXT_panic(_physicalDevice: PhysicalDevice, _surface: SurfaceKHR, _pSurfaceCapabilities: *mut SurfaceCapabilities2EXT) -> Result{
    panic!("extension vkGetPhysicalDeviceSurfaceCapabilities2EXT not loaded")
}
extern "system" fn GetPhysicalDeviceSurfaceCapabilities2KHR_panic(_physicalDevice: PhysicalDevice, _pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, _pSurfaceCapabilities: *mut SurfaceCapabilities2KHR) -> Result{
    panic!("extension vkGetPhysicalDeviceSurfaceCapabilities2KHR not loaded")
}
extern "system" fn GetPhysicalDeviceSurfaceFormats2KHR_panic(_physicalDevice: PhysicalDevice, _pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, _pSurfaceFormatCount: *mut u32, _pSurfaceFormats: *mut SurfaceFormat2KHR) -> Result{
    panic!("extension vkGetPhysicalDeviceSurfaceFormats2KHR not loaded")
}
extern "system" fn GetPhysicalDeviceDisplayProperties2KHR_panic(_physicalDevice: PhysicalDevice, _pPropertyCount: *mut u32, _pProperties: *mut DisplayProperties2KHR) -> Result{
    panic!("extension vkGetPhysicalDeviceDisplayProperties2KHR not loaded")
}
extern "system" fn GetPhysicalDeviceDisplayPlaneProperties2KHR_panic(_physicalDevice: PhysicalDevice, _pPropertyCount: *mut u32, _pProperties: *mut DisplayPlaneProperties2KHR) -> Result{
    panic!("extension vkGetPhysicalDeviceDisplayPlaneProperties2KHR not loaded")
}
extern "system" fn GetDisplayModeProperties2KHR_panic(_physicalDevice: PhysicalDevice, _display: DisplayKHR, _pPropertyCount: *mut u32, _pProperties: *mut DisplayModeProperties2KHR) -> Result{
    panic!("extension vkGetDisplayModeProperties2KHR not loaded")
}
extern "system" fn GetDisplayPlaneCapabilities2KHR_panic(_physicalDevice: PhysicalDevice, _pDisplayPlaneInfo: *const DisplayPlaneInfo2KHR, _pCapabilities: *mut DisplayPlaneCapabilities2KHR) -> Result{
    panic!("extension vkGetDisplayPlaneCapabilities2KHR not loaded")
}
extern "system" fn CreateIOSSurfaceMVK_panic(_instance: Instance, _pCreateInfo: *const IOSSurfaceCreateInfoMVK, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateIOSSurfaceMVK not loaded")
}
extern "system" fn CreateMacOSSurfaceMVK_panic(_instance: Instance, _pCreateInfo: *const MacOSSurfaceCreateInfoMVK, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateMacOSSurfaceMVK not loaded")
}
extern "system" fn SetDebugUtilsObjectNameEXT_panic(_device: Device, _pNameInfo: *const DebugUtilsObjectNameInfoEXT) -> Result{
    panic!("extension vkSetDebugUtilsObjectNameEXT not loaded")
}
extern "system" fn SetDebugUtilsObjectTagEXT_panic(_device: Device, _pTagInfo: *const DebugUtilsObjectTagInfoEXT) -> Result{
    panic!("extension vkSetDebugUtilsObjectTagEXT not loaded")
}
extern "system" fn QueueBeginDebugUtilsLabelEXT_panic(_queue: Queue, _pLabelInfo: *const DebugUtilsLabelEXT){
    panic!("extension vkQueueBeginDebugUtilsLabelEXT not loaded")
}
extern "system" fn QueueEndDebugUtilsLabelEXT_panic(_queue: Queue){
    panic!("extension vkQueueEndDebugUtilsLabelEXT not loaded")
}
extern "system" fn QueueInsertDebugUtilsLabelEXT_panic(_queue: Queue, _pLabelInfo: *const DebugUtilsLabelEXT){
    panic!("extension vkQueueInsertDebugUtilsLabelEXT not loaded")
}
extern "system" fn CmdBeginDebugUtilsLabelEXT_panic(_commandBuffer: CommandBuffer, _pLabelInfo: *const DebugUtilsLabelEXT){
    panic!("extension vkCmdBeginDebugUtilsLabelEXT not loaded")
}
extern "system" fn CmdEndDebugUtilsLabelEXT_panic(_commandBuffer: CommandBuffer){
    panic!("extension vkCmdEndDebugUtilsLabelEXT not loaded")
}
extern "system" fn CmdInsertDebugUtilsLabelEXT_panic(_commandBuffer: CommandBuffer, _pLabelInfo: *const DebugUtilsLabelEXT){
    panic!("extension vkCmdInsertDebugUtilsLabelEXT not loaded")
}
extern "system" fn CreateDebugUtilsMessengerEXT_panic(_instance: Instance, _pCreateInfo: *const DebugUtilsMessengerCreateInfoEXT, _pAllocator: *const AllocationCallbacks, _pMessenger: *mut DebugUtilsMessengerEXT) -> Result{
    panic!("extension vkCreateDebugUtilsMessengerEXT not loaded")
}
extern "system" fn DestroyDebugUtilsMessengerEXT_panic(_instance: Instance, _messenger: DebugUtilsMessengerEXT, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyDebugUtilsMessengerEXT not loaded")
}
extern "system" fn SubmitDebugUtilsMessageEXT_panic(_instance: Instance, _messageSeverity: DebugUtilsMessageSeverityFlagBitsEXT, _messageTypes: DebugUtilsMessageTypeFlagsEXT, _pCallbackData: *const DebugUtilsMessengerCallbackDataEXT){
    panic!("extension vkSubmitDebugUtilsMessageEXT not loaded")
}
extern "system" fn CreateImagePipeSurfaceFUCHSIA_panic(_instance: Instance, _pCreateInfo: *const ImagePipeSurfaceCreateInfoFUCHSIA, _pAllocator: *const AllocationCallbacks, _pSurface: *mut SurfaceKHR) -> Result{
    panic!("extension vkCreateImagePipeSurfaceFUCHSIA not loaded")
}


impl Default for InstanceExtensions {
  /// Initializes all function pointers to functions that immediately panic.
  fn default() -> InstanceExtensions {
    InstanceExtensions {
      hinstance: NULL_HANDLE,
      DestroySurfaceKHR_ptr: DestroySurfaceKHR_panic,
      GetPhysicalDeviceSurfaceSupportKHR_ptr: GetPhysicalDeviceSurfaceSupportKHR_panic,
      GetPhysicalDeviceSurfaceCapabilitiesKHR_ptr: GetPhysicalDeviceSurfaceCapabilitiesKHR_panic,
      GetPhysicalDeviceSurfaceFormatsKHR_ptr: GetPhysicalDeviceSurfaceFormatsKHR_panic,
      GetPhysicalDeviceSurfacePresentModesKHR_ptr: GetPhysicalDeviceSurfacePresentModesKHR_panic,
      GetPhysicalDeviceDisplayPropertiesKHR_ptr: GetPhysicalDeviceDisplayPropertiesKHR_panic,
      GetPhysicalDeviceDisplayPlanePropertiesKHR_ptr: GetPhysicalDeviceDisplayPlanePropertiesKHR_panic,
      GetDisplayPlaneSupportedDisplaysKHR_ptr: GetDisplayPlaneSupportedDisplaysKHR_panic,
      GetDisplayModePropertiesKHR_ptr: GetDisplayModePropertiesKHR_panic,
      CreateDisplayModeKHR_ptr: CreateDisplayModeKHR_panic,
      GetDisplayPlaneCapabilitiesKHR_ptr: GetDisplayPlaneCapabilitiesKHR_panic,
      CreateDisplayPlaneSurfaceKHR_ptr: CreateDisplayPlaneSurfaceKHR_panic,
      CreateXlibSurfaceKHR_ptr: CreateXlibSurfaceKHR_panic,
      GetPhysicalDeviceXlibPresentationSupportKHR_ptr: GetPhysicalDeviceXlibPresentationSupportKHR_panic,
      CreateXcbSurfaceKHR_ptr: CreateXcbSurfaceKHR_panic,
      GetPhysicalDeviceXcbPresentationSupportKHR_ptr: GetPhysicalDeviceXcbPresentationSupportKHR_panic,
      CreateWaylandSurfaceKHR_ptr: CreateWaylandSurfaceKHR_panic,
      GetPhysicalDeviceWaylandPresentationSupportKHR_ptr: GetPhysicalDeviceWaylandPresentationSupportKHR_panic,
      CreateAndroidSurfaceKHR_ptr: CreateAndroidSurfaceKHR_panic,
      CreateWin32SurfaceKHR_ptr: CreateWin32SurfaceKHR_panic,
      GetPhysicalDeviceWin32PresentationSupportKHR_ptr: GetPhysicalDeviceWin32PresentationSupportKHR_panic,
      CreateDebugReportCallbackEXT_ptr: CreateDebugReportCallbackEXT_panic,
      DestroyDebugReportCallbackEXT_ptr: DestroyDebugReportCallbackEXT_panic,
      DebugReportMessageEXT_ptr: DebugReportMessageEXT_panic,
      GetPhysicalDeviceExternalImageFormatPropertiesNV_ptr: GetPhysicalDeviceExternalImageFormatPropertiesNV_panic,
      CreateViSurfaceNN_ptr: CreateViSurfaceNN_panic,
      ReleaseDisplayEXT_ptr: ReleaseDisplayEXT_panic,
      AcquireXlibDisplayEXT_ptr: AcquireXlibDisplayEXT_panic,
      GetRandROutputDisplayEXT_ptr: GetRandROutputDisplayEXT_panic,
      GetPhysicalDeviceSurfaceCapabilities2EXT_ptr: GetPhysicalDeviceSurfaceCapabilities2EXT_panic,
      GetPhysicalDeviceSurfaceCapabilities2KHR_ptr: GetPhysicalDeviceSurfaceCapabilities2KHR_panic,
      GetPhysicalDeviceSurfaceFormats2KHR_ptr: GetPhysicalDeviceSurfaceFormats2KHR_panic,
      GetPhysicalDeviceDisplayProperties2KHR_ptr: GetPhysicalDeviceDisplayProperties2KHR_panic,
      GetPhysicalDeviceDisplayPlaneProperties2KHR_ptr: GetPhysicalDeviceDisplayPlaneProperties2KHR_panic,
      GetDisplayModeProperties2KHR_ptr: GetDisplayModeProperties2KHR_panic,
      GetDisplayPlaneCapabilities2KHR_ptr: GetDisplayPlaneCapabilities2KHR_panic,
      CreateIOSSurfaceMVK_ptr: CreateIOSSurfaceMVK_panic,
      CreateMacOSSurfaceMVK_ptr: CreateMacOSSurfaceMVK_panic,
      SetDebugUtilsObjectNameEXT_ptr: SetDebugUtilsObjectNameEXT_panic,
      SetDebugUtilsObjectTagEXT_ptr: SetDebugUtilsObjectTagEXT_panic,
      QueueBeginDebugUtilsLabelEXT_ptr: QueueBeginDebugUtilsLabelEXT_panic,
      QueueEndDebugUtilsLabelEXT_ptr: QueueEndDebugUtilsLabelEXT_panic,
      QueueInsertDebugUtilsLabelEXT_ptr: QueueInsertDebugUtilsLabelEXT_panic,
      CmdBeginDebugUtilsLabelEXT_ptr: CmdBeginDebugUtilsLabelEXT_panic,
      CmdEndDebugUtilsLabelEXT_ptr: CmdEndDebugUtilsLabelEXT_panic,
      CmdInsertDebugUtilsLabelEXT_ptr: CmdInsertDebugUtilsLabelEXT_panic,
      CreateDebugUtilsMessengerEXT_ptr: CreateDebugUtilsMessengerEXT_panic,
      DestroyDebugUtilsMessengerEXT_ptr: DestroyDebugUtilsMessengerEXT_panic,
      SubmitDebugUtilsMessageEXT_ptr: SubmitDebugUtilsMessageEXT_panic,
      CreateImagePipeSurfaceFUCHSIA_ptr: CreateImagePipeSurfaceFUCHSIA_panic,
    }
  }
}


impl InstanceExtensions {
  /// Initialized instance extensions
  /// 
  /// A valid instance of [Core](struct.Core.html) is needen to successfully initialize extensions.
  /// The vulkan feature level is picked up through the current Core instance.
  pub fn new(hinstance: Instance) -> InstanceExtensions {
    let mut name;
    let mut ptr;

    unsafe { 
      let feature = (*core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core")).feature;
        name = std::ffi::CString::new("vkDestroySurfaceKHR").unwrap();
        let DestroySurfaceKHR_ptr = if feature < VERSION_1_0 {
          DestroySurfaceKHR_panic as extern "system" fn (instance: Instance, surface: SurfaceKHR, pAllocator: *const AllocationCallbacks)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DestroySurfaceKHR_panic as extern "system" fn (instance: Instance, surface: SurfaceKHR, pAllocator: *const AllocationCallbacks)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceSurfaceSupportKHR").unwrap();
        let GetPhysicalDeviceSurfaceSupportKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceSurfaceSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, surface: SurfaceKHR, pSupported: *mut Bool32) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceSurfaceSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, surface: SurfaceKHR, pSupported: *mut Bool32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceSurfaceCapabilitiesKHR").unwrap();
        let GetPhysicalDeviceSurfaceCapabilitiesKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceSurfaceCapabilitiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceCapabilities: *mut SurfaceCapabilitiesKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceSurfaceCapabilitiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceCapabilities: *mut SurfaceCapabilitiesKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceSurfaceFormatsKHR").unwrap();
        let GetPhysicalDeviceSurfaceFormatsKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceSurfaceFormatsKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut SurfaceFormatKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceSurfaceFormatsKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut SurfaceFormatKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceSurfacePresentModesKHR").unwrap();
        let GetPhysicalDeviceSurfacePresentModesKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceSurfacePresentModesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pPresentModeCount: *mut u32, pPresentModes: *mut PresentModeKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceSurfacePresentModesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pPresentModeCount: *mut u32, pPresentModes: *mut PresentModeKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceDisplayPropertiesKHR").unwrap();
        let GetPhysicalDeviceDisplayPropertiesKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceDisplayPropertiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPropertiesKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceDisplayPropertiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPropertiesKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceDisplayPlanePropertiesKHR").unwrap();
        let GetPhysicalDeviceDisplayPlanePropertiesKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceDisplayPlanePropertiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPlanePropertiesKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceDisplayPlanePropertiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPlanePropertiesKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetDisplayPlaneSupportedDisplaysKHR").unwrap();
        let GetDisplayPlaneSupportedDisplaysKHR_ptr = if feature < VERSION_1_0 {
          GetDisplayPlaneSupportedDisplaysKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, planeIndex: u32, pDisplayCount: *mut u32, pDisplays: *mut DisplayKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetDisplayPlaneSupportedDisplaysKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, planeIndex: u32, pDisplayCount: *mut u32, pDisplays: *mut DisplayKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetDisplayModePropertiesKHR").unwrap();
        let GetDisplayModePropertiesKHR_ptr = if feature < VERSION_1_0 {
          GetDisplayModePropertiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pPropertyCount: *mut u32, pProperties: *mut DisplayModePropertiesKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetDisplayModePropertiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pPropertyCount: *mut u32, pProperties: *mut DisplayModePropertiesKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateDisplayModeKHR").unwrap();
        let CreateDisplayModeKHR_ptr = if feature < VERSION_1_0 {
          CreateDisplayModeKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pCreateInfo: *const DisplayModeCreateInfoKHR, pAllocator: *const AllocationCallbacks, pMode: *mut DisplayModeKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateDisplayModeKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pCreateInfo: *const DisplayModeCreateInfoKHR, pAllocator: *const AllocationCallbacks, pMode: *mut DisplayModeKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetDisplayPlaneCapabilitiesKHR").unwrap();
        let GetDisplayPlaneCapabilitiesKHR_ptr = if feature < VERSION_1_0 {
          GetDisplayPlaneCapabilitiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, mode: DisplayModeKHR, planeIndex: u32, pCapabilities: *mut DisplayPlaneCapabilitiesKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetDisplayPlaneCapabilitiesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, mode: DisplayModeKHR, planeIndex: u32, pCapabilities: *mut DisplayPlaneCapabilitiesKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateDisplayPlaneSurfaceKHR").unwrap();
        let CreateDisplayPlaneSurfaceKHR_ptr = if feature < VERSION_1_0 {
          CreateDisplayPlaneSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const DisplaySurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateDisplayPlaneSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const DisplaySurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateXlibSurfaceKHR").unwrap();
        let CreateXlibSurfaceKHR_ptr = if feature < VERSION_1_0 {
          CreateXlibSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const XlibSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateXlibSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const XlibSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceXlibPresentationSupportKHR").unwrap();
        let GetPhysicalDeviceXlibPresentationSupportKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceXlibPresentationSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, dpy: *mut Display, visualID: VisualID) -> Bool32
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceXlibPresentationSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, dpy: *mut Display, visualID: VisualID) -> Bool32
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateXcbSurfaceKHR").unwrap();
        let CreateXcbSurfaceKHR_ptr = if feature < VERSION_1_0 {
          CreateXcbSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const XcbSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateXcbSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const XcbSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceXcbPresentationSupportKHR").unwrap();
        let GetPhysicalDeviceXcbPresentationSupportKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceXcbPresentationSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, connection: *mut xcb_connection_t, visual_id: xcb_visualid_t) -> Bool32
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceXcbPresentationSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, connection: *mut xcb_connection_t, visual_id: xcb_visualid_t) -> Bool32
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateWaylandSurfaceKHR").unwrap();
        let CreateWaylandSurfaceKHR_ptr = if feature < VERSION_1_0 {
          CreateWaylandSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const WaylandSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateWaylandSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const WaylandSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceWaylandPresentationSupportKHR").unwrap();
        let GetPhysicalDeviceWaylandPresentationSupportKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceWaylandPresentationSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, display: *mut wl_display) -> Bool32
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceWaylandPresentationSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32, display: *mut wl_display) -> Bool32
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateAndroidSurfaceKHR").unwrap();
        let CreateAndroidSurfaceKHR_ptr = if feature < VERSION_1_0 {
          CreateAndroidSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const AndroidSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateAndroidSurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const AndroidSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateWin32SurfaceKHR").unwrap();
        let CreateWin32SurfaceKHR_ptr = if feature < VERSION_1_0 {
          CreateWin32SurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const Win32SurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateWin32SurfaceKHR_panic as extern "system" fn (instance: Instance, pCreateInfo: *const Win32SurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceWin32PresentationSupportKHR").unwrap();
        let GetPhysicalDeviceWin32PresentationSupportKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceWin32PresentationSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32) -> Bool32
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceWin32PresentationSupportKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, queueFamilyIndex: u32) -> Bool32
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateDebugReportCallbackEXT").unwrap();
        let CreateDebugReportCallbackEXT_ptr = if feature < VERSION_1_0 {
          CreateDebugReportCallbackEXT_panic as extern "system" fn (instance: Instance, pCreateInfo: *const DebugReportCallbackCreateInfoEXT, pAllocator: *const AllocationCallbacks, pCallback: *mut DebugReportCallbackEXT) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateDebugReportCallbackEXT_panic as extern "system" fn (instance: Instance, pCreateInfo: *const DebugReportCallbackCreateInfoEXT, pAllocator: *const AllocationCallbacks, pCallback: *mut DebugReportCallbackEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDestroyDebugReportCallbackEXT").unwrap();
        let DestroyDebugReportCallbackEXT_ptr = if feature < VERSION_1_0 {
          DestroyDebugReportCallbackEXT_panic as extern "system" fn (instance: Instance, callback: DebugReportCallbackEXT, pAllocator: *const AllocationCallbacks)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DestroyDebugReportCallbackEXT_panic as extern "system" fn (instance: Instance, callback: DebugReportCallbackEXT, pAllocator: *const AllocationCallbacks)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDebugReportMessageEXT").unwrap();
        let DebugReportMessageEXT_ptr = if feature < VERSION_1_0 {
          DebugReportMessageEXT_panic as extern "system" fn (instance: Instance, flags: DebugReportFlagsEXT, objectType: DebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *const c_char, pMessage: *const c_char)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DebugReportMessageEXT_panic as extern "system" fn (instance: Instance, flags: DebugReportFlagsEXT, objectType: DebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *const c_char, pMessage: *const c_char)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceExternalImageFormatPropertiesNV").unwrap();
        let GetPhysicalDeviceExternalImageFormatPropertiesNV_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceExternalImageFormatPropertiesNV_panic as extern "system" fn (physicalDevice: PhysicalDevice, format: Format, typ: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, externalHandleType: ExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut ExternalImageFormatPropertiesNV) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceExternalImageFormatPropertiesNV_panic as extern "system" fn (physicalDevice: PhysicalDevice, format: Format, typ: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, externalHandleType: ExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut ExternalImageFormatPropertiesNV) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateViSurfaceNN").unwrap();
        let CreateViSurfaceNN_ptr = if feature < VERSION_1_0 {
          CreateViSurfaceNN_panic as extern "system" fn (instance: Instance, pCreateInfo: *const ViSurfaceCreateInfoNN, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateViSurfaceNN_panic as extern "system" fn (instance: Instance, pCreateInfo: *const ViSurfaceCreateInfoNN, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkReleaseDisplayEXT").unwrap();
        let ReleaseDisplayEXT_ptr = if feature < VERSION_1_0 {
          ReleaseDisplayEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            ReleaseDisplayEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkAcquireXlibDisplayEXT").unwrap();
        let AcquireXlibDisplayEXT_ptr = if feature < VERSION_1_0 {
          AcquireXlibDisplayEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, dpy: *mut Display, display: DisplayKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            AcquireXlibDisplayEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, dpy: *mut Display, display: DisplayKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetRandROutputDisplayEXT").unwrap();
        let GetRandROutputDisplayEXT_ptr = if feature < VERSION_1_0 {
          GetRandROutputDisplayEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, dpy: *mut Display, rrOutput: RROutput, pDisplay: *mut DisplayKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetRandROutputDisplayEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, dpy: *mut Display, rrOutput: RROutput, pDisplay: *mut DisplayKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceSurfaceCapabilities2EXT").unwrap();
        let GetPhysicalDeviceSurfaceCapabilities2EXT_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceSurfaceCapabilities2EXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceCapabilities: *mut SurfaceCapabilities2EXT) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceSurfaceCapabilities2EXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceCapabilities: *mut SurfaceCapabilities2EXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceSurfaceCapabilities2KHR").unwrap();
        let GetPhysicalDeviceSurfaceCapabilities2KHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceSurfaceCapabilities2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut SurfaceCapabilities2KHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceSurfaceCapabilities2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut SurfaceCapabilities2KHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceSurfaceFormats2KHR").unwrap();
        let GetPhysicalDeviceSurfaceFormats2KHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceSurfaceFormats2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut SurfaceFormat2KHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceSurfaceFormats2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut SurfaceFormat2KHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceDisplayProperties2KHR").unwrap();
        let GetPhysicalDeviceDisplayProperties2KHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceDisplayProperties2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayProperties2KHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceDisplayProperties2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayProperties2KHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceDisplayPlaneProperties2KHR").unwrap();
        let GetPhysicalDeviceDisplayPlaneProperties2KHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceDisplayPlaneProperties2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPlaneProperties2KHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceDisplayPlaneProperties2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPlaneProperties2KHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetDisplayModeProperties2KHR").unwrap();
        let GetDisplayModeProperties2KHR_ptr = if feature < VERSION_1_0 {
          GetDisplayModeProperties2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pPropertyCount: *mut u32, pProperties: *mut DisplayModeProperties2KHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetDisplayModeProperties2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, display: DisplayKHR, pPropertyCount: *mut u32, pProperties: *mut DisplayModeProperties2KHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetDisplayPlaneCapabilities2KHR").unwrap();
        let GetDisplayPlaneCapabilities2KHR_ptr = if feature < VERSION_1_0 {
          GetDisplayPlaneCapabilities2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pDisplayPlaneInfo: *const DisplayPlaneInfo2KHR, pCapabilities: *mut DisplayPlaneCapabilities2KHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetDisplayPlaneCapabilities2KHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, pDisplayPlaneInfo: *const DisplayPlaneInfo2KHR, pCapabilities: *mut DisplayPlaneCapabilities2KHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateIOSSurfaceMVK").unwrap();
        let CreateIOSSurfaceMVK_ptr = if feature < VERSION_1_0 {
          CreateIOSSurfaceMVK_panic as extern "system" fn (instance: Instance, pCreateInfo: *const IOSSurfaceCreateInfoMVK, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateIOSSurfaceMVK_panic as extern "system" fn (instance: Instance, pCreateInfo: *const IOSSurfaceCreateInfoMVK, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateMacOSSurfaceMVK").unwrap();
        let CreateMacOSSurfaceMVK_ptr = if feature < VERSION_1_0 {
          CreateMacOSSurfaceMVK_panic as extern "system" fn (instance: Instance, pCreateInfo: *const MacOSSurfaceCreateInfoMVK, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateMacOSSurfaceMVK_panic as extern "system" fn (instance: Instance, pCreateInfo: *const MacOSSurfaceCreateInfoMVK, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkSetDebugUtilsObjectNameEXT").unwrap();
        let SetDebugUtilsObjectNameEXT_ptr = if feature < VERSION_1_0 {
          SetDebugUtilsObjectNameEXT_panic as extern "system" fn (device: Device, pNameInfo: *const DebugUtilsObjectNameInfoEXT) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            SetDebugUtilsObjectNameEXT_panic as extern "system" fn (device: Device, pNameInfo: *const DebugUtilsObjectNameInfoEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkSetDebugUtilsObjectTagEXT").unwrap();
        let SetDebugUtilsObjectTagEXT_ptr = if feature < VERSION_1_0 {
          SetDebugUtilsObjectTagEXT_panic as extern "system" fn (device: Device, pTagInfo: *const DebugUtilsObjectTagInfoEXT) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            SetDebugUtilsObjectTagEXT_panic as extern "system" fn (device: Device, pTagInfo: *const DebugUtilsObjectTagInfoEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkQueueBeginDebugUtilsLabelEXT").unwrap();
        let QueueBeginDebugUtilsLabelEXT_ptr = if feature < VERSION_1_0 {
          QueueBeginDebugUtilsLabelEXT_panic as extern "system" fn (queue: Queue, pLabelInfo: *const DebugUtilsLabelEXT)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            QueueBeginDebugUtilsLabelEXT_panic as extern "system" fn (queue: Queue, pLabelInfo: *const DebugUtilsLabelEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkQueueEndDebugUtilsLabelEXT").unwrap();
        let QueueEndDebugUtilsLabelEXT_ptr = if feature < VERSION_1_0 {
          QueueEndDebugUtilsLabelEXT_panic as extern "system" fn (queue: Queue)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            QueueEndDebugUtilsLabelEXT_panic as extern "system" fn (queue: Queue)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkQueueInsertDebugUtilsLabelEXT").unwrap();
        let QueueInsertDebugUtilsLabelEXT_ptr = if feature < VERSION_1_0 {
          QueueInsertDebugUtilsLabelEXT_panic as extern "system" fn (queue: Queue, pLabelInfo: *const DebugUtilsLabelEXT)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            QueueInsertDebugUtilsLabelEXT_panic as extern "system" fn (queue: Queue, pLabelInfo: *const DebugUtilsLabelEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdBeginDebugUtilsLabelEXT").unwrap();
        let CmdBeginDebugUtilsLabelEXT_ptr = if feature < VERSION_1_0 {
          CmdBeginDebugUtilsLabelEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pLabelInfo: *const DebugUtilsLabelEXT)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdBeginDebugUtilsLabelEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pLabelInfo: *const DebugUtilsLabelEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdEndDebugUtilsLabelEXT").unwrap();
        let CmdEndDebugUtilsLabelEXT_ptr = if feature < VERSION_1_0 {
          CmdEndDebugUtilsLabelEXT_panic as extern "system" fn (commandBuffer: CommandBuffer)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdEndDebugUtilsLabelEXT_panic as extern "system" fn (commandBuffer: CommandBuffer)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdInsertDebugUtilsLabelEXT").unwrap();
        let CmdInsertDebugUtilsLabelEXT_ptr = if feature < VERSION_1_0 {
          CmdInsertDebugUtilsLabelEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pLabelInfo: *const DebugUtilsLabelEXT)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdInsertDebugUtilsLabelEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pLabelInfo: *const DebugUtilsLabelEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateDebugUtilsMessengerEXT").unwrap();
        let CreateDebugUtilsMessengerEXT_ptr = if feature < VERSION_1_0 {
          CreateDebugUtilsMessengerEXT_panic as extern "system" fn (instance: Instance, pCreateInfo: *const DebugUtilsMessengerCreateInfoEXT, pAllocator: *const AllocationCallbacks, pMessenger: *mut DebugUtilsMessengerEXT) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateDebugUtilsMessengerEXT_panic as extern "system" fn (instance: Instance, pCreateInfo: *const DebugUtilsMessengerCreateInfoEXT, pAllocator: *const AllocationCallbacks, pMessenger: *mut DebugUtilsMessengerEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDestroyDebugUtilsMessengerEXT").unwrap();
        let DestroyDebugUtilsMessengerEXT_ptr = if feature < VERSION_1_0 {
          DestroyDebugUtilsMessengerEXT_panic as extern "system" fn (instance: Instance, messenger: DebugUtilsMessengerEXT, pAllocator: *const AllocationCallbacks)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DestroyDebugUtilsMessengerEXT_panic as extern "system" fn (instance: Instance, messenger: DebugUtilsMessengerEXT, pAllocator: *const AllocationCallbacks)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkSubmitDebugUtilsMessageEXT").unwrap();
        let SubmitDebugUtilsMessageEXT_ptr = if feature < VERSION_1_0 {
          SubmitDebugUtilsMessageEXT_panic as extern "system" fn (instance: Instance, messageSeverity: DebugUtilsMessageSeverityFlagBitsEXT, messageTypes: DebugUtilsMessageTypeFlagsEXT, pCallbackData: *const DebugUtilsMessengerCallbackDataEXT)
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            SubmitDebugUtilsMessageEXT_panic as extern "system" fn (instance: Instance, messageSeverity: DebugUtilsMessageSeverityFlagBitsEXT, messageTypes: DebugUtilsMessageTypeFlagsEXT, pCallbackData: *const DebugUtilsMessengerCallbackDataEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateImagePipeSurfaceFUCHSIA").unwrap();
        let CreateImagePipeSurfaceFUCHSIA_ptr = if feature < VERSION_1_0 {
          CreateImagePipeSurfaceFUCHSIA_panic as extern "system" fn (instance: Instance, pCreateInfo: *const ImagePipeSurfaceCreateInfoFUCHSIA, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
        } else {
          ptr = GetInstanceProcAddr(hinstance, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateImagePipeSurfaceFUCHSIA_panic as extern "system" fn (instance: Instance, pCreateInfo: *const ImagePipeSurfaceCreateInfoFUCHSIA, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        

      InstanceExtensions {
        hinstance,
        DestroySurfaceKHR_ptr,
        GetPhysicalDeviceSurfaceSupportKHR_ptr,
        GetPhysicalDeviceSurfaceCapabilitiesKHR_ptr,
        GetPhysicalDeviceSurfaceFormatsKHR_ptr,
        GetPhysicalDeviceSurfacePresentModesKHR_ptr,
        GetPhysicalDeviceDisplayPropertiesKHR_ptr,
        GetPhysicalDeviceDisplayPlanePropertiesKHR_ptr,
        GetDisplayPlaneSupportedDisplaysKHR_ptr,
        GetDisplayModePropertiesKHR_ptr,
        CreateDisplayModeKHR_ptr,
        GetDisplayPlaneCapabilitiesKHR_ptr,
        CreateDisplayPlaneSurfaceKHR_ptr,
        CreateXlibSurfaceKHR_ptr,
        GetPhysicalDeviceXlibPresentationSupportKHR_ptr,
        CreateXcbSurfaceKHR_ptr,
        GetPhysicalDeviceXcbPresentationSupportKHR_ptr,
        CreateWaylandSurfaceKHR_ptr,
        GetPhysicalDeviceWaylandPresentationSupportKHR_ptr,
        CreateAndroidSurfaceKHR_ptr,
        CreateWin32SurfaceKHR_ptr,
        GetPhysicalDeviceWin32PresentationSupportKHR_ptr,
        CreateDebugReportCallbackEXT_ptr,
        DestroyDebugReportCallbackEXT_ptr,
        DebugReportMessageEXT_ptr,
        GetPhysicalDeviceExternalImageFormatPropertiesNV_ptr,
        CreateViSurfaceNN_ptr,
        ReleaseDisplayEXT_ptr,
        AcquireXlibDisplayEXT_ptr,
        GetRandROutputDisplayEXT_ptr,
        GetPhysicalDeviceSurfaceCapabilities2EXT_ptr,
        GetPhysicalDeviceSurfaceCapabilities2KHR_ptr,
        GetPhysicalDeviceSurfaceFormats2KHR_ptr,
        GetPhysicalDeviceDisplayProperties2KHR_ptr,
        GetPhysicalDeviceDisplayPlaneProperties2KHR_ptr,
        GetDisplayModeProperties2KHR_ptr,
        GetDisplayPlaneCapabilities2KHR_ptr,
        CreateIOSSurfaceMVK_ptr,
        CreateMacOSSurfaceMVK_ptr,
        SetDebugUtilsObjectNameEXT_ptr,
        SetDebugUtilsObjectTagEXT_ptr,
        QueueBeginDebugUtilsLabelEXT_ptr,
        QueueEndDebugUtilsLabelEXT_ptr,
        QueueInsertDebugUtilsLabelEXT_ptr,
        CmdBeginDebugUtilsLabelEXT_ptr,
        CmdEndDebugUtilsLabelEXT_ptr,
        CmdInsertDebugUtilsLabelEXT_ptr,
        CreateDebugUtilsMessengerEXT_ptr,
        DestroyDebugUtilsMessengerEXT_ptr,
        SubmitDebugUtilsMessageEXT_ptr,
        CreateImagePipeSurfaceFUCHSIA_ptr,
      }
    }
  }


  /// Retrieve the vulkan handle of the InstanceExtensions
  pub fn get_handle(&self) -> Instance {
    self.hinstance
  }

  #[doc(hidden)] pub fn DestroySurfaceKHR(&self, instance: Instance, surface: SurfaceKHR, pAllocator: *const AllocationCallbacks){
    (self.DestroySurfaceKHR_ptr)(instance, surface, pAllocator)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSurfaceSupportKHR(&self, physicalDevice: PhysicalDevice, queueFamilyIndex: u32, surface: SurfaceKHR, pSupported: *mut Bool32) -> Result{
    (self.GetPhysicalDeviceSurfaceSupportKHR_ptr)(physicalDevice, queueFamilyIndex, surface, pSupported)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSurfaceCapabilitiesKHR(&self, physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceCapabilities: *mut SurfaceCapabilitiesKHR) -> Result{
    (self.GetPhysicalDeviceSurfaceCapabilitiesKHR_ptr)(physicalDevice, surface, pSurfaceCapabilities)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSurfaceFormatsKHR(&self, physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut SurfaceFormatKHR) -> Result{
    (self.GetPhysicalDeviceSurfaceFormatsKHR_ptr)(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSurfacePresentModesKHR(&self, physicalDevice: PhysicalDevice, surface: SurfaceKHR, pPresentModeCount: *mut u32, pPresentModes: *mut PresentModeKHR) -> Result{
    (self.GetPhysicalDeviceSurfacePresentModesKHR_ptr)(physicalDevice, surface, pPresentModeCount, pPresentModes)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceDisplayPropertiesKHR(&self, physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPropertiesKHR) -> Result{
    (self.GetPhysicalDeviceDisplayPropertiesKHR_ptr)(physicalDevice, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceDisplayPlanePropertiesKHR(&self, physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPlanePropertiesKHR) -> Result{
    (self.GetPhysicalDeviceDisplayPlanePropertiesKHR_ptr)(physicalDevice, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn GetDisplayPlaneSupportedDisplaysKHR(&self, physicalDevice: PhysicalDevice, planeIndex: u32, pDisplayCount: *mut u32, pDisplays: *mut DisplayKHR) -> Result{
    (self.GetDisplayPlaneSupportedDisplaysKHR_ptr)(physicalDevice, planeIndex, pDisplayCount, pDisplays)
  }
  #[doc(hidden)] pub fn GetDisplayModePropertiesKHR(&self, physicalDevice: PhysicalDevice, display: DisplayKHR, pPropertyCount: *mut u32, pProperties: *mut DisplayModePropertiesKHR) -> Result{
    (self.GetDisplayModePropertiesKHR_ptr)(physicalDevice, display, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn CreateDisplayModeKHR(&self, physicalDevice: PhysicalDevice, display: DisplayKHR, pCreateInfo: *const DisplayModeCreateInfoKHR, pAllocator: *const AllocationCallbacks, pMode: *mut DisplayModeKHR) -> Result{
    (self.CreateDisplayModeKHR_ptr)(physicalDevice, display, pCreateInfo, pAllocator, pMode)
  }
  #[doc(hidden)] pub fn GetDisplayPlaneCapabilitiesKHR(&self, physicalDevice: PhysicalDevice, mode: DisplayModeKHR, planeIndex: u32, pCapabilities: *mut DisplayPlaneCapabilitiesKHR) -> Result{
    (self.GetDisplayPlaneCapabilitiesKHR_ptr)(physicalDevice, mode, planeIndex, pCapabilities)
  }
  #[doc(hidden)] pub fn CreateDisplayPlaneSurfaceKHR(&self, instance: Instance, pCreateInfo: *const DisplaySurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateDisplayPlaneSurfaceKHR_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn CreateXlibSurfaceKHR(&self, instance: Instance, pCreateInfo: *const XlibSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateXlibSurfaceKHR_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceXlibPresentationSupportKHR(&self, physicalDevice: PhysicalDevice, queueFamilyIndex: u32, dpy: *mut Display, visualID: VisualID) -> Bool32{
    (self.GetPhysicalDeviceXlibPresentationSupportKHR_ptr)(physicalDevice, queueFamilyIndex, dpy, visualID)
  }
  #[doc(hidden)] pub fn CreateXcbSurfaceKHR(&self, instance: Instance, pCreateInfo: *const XcbSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateXcbSurfaceKHR_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceXcbPresentationSupportKHR(&self, physicalDevice: PhysicalDevice, queueFamilyIndex: u32, connection: *mut xcb_connection_t, visual_id: xcb_visualid_t) -> Bool32{
    (self.GetPhysicalDeviceXcbPresentationSupportKHR_ptr)(physicalDevice, queueFamilyIndex, connection, visual_id)
  }
  #[doc(hidden)] pub fn CreateWaylandSurfaceKHR(&self, instance: Instance, pCreateInfo: *const WaylandSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateWaylandSurfaceKHR_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceWaylandPresentationSupportKHR(&self, physicalDevice: PhysicalDevice, queueFamilyIndex: u32, display: *mut wl_display) -> Bool32{
    (self.GetPhysicalDeviceWaylandPresentationSupportKHR_ptr)(physicalDevice, queueFamilyIndex, display)
  }
  #[doc(hidden)] pub fn CreateAndroidSurfaceKHR(&self, instance: Instance, pCreateInfo: *const AndroidSurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateAndroidSurfaceKHR_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn CreateWin32SurfaceKHR(&self, instance: Instance, pCreateInfo: *const Win32SurfaceCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateWin32SurfaceKHR_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceWin32PresentationSupportKHR(&self, physicalDevice: PhysicalDevice, queueFamilyIndex: u32) -> Bool32{
    (self.GetPhysicalDeviceWin32PresentationSupportKHR_ptr)(physicalDevice, queueFamilyIndex)
  }
  #[doc(hidden)] pub fn CreateDebugReportCallbackEXT(&self, instance: Instance, pCreateInfo: *const DebugReportCallbackCreateInfoEXT, pAllocator: *const AllocationCallbacks, pCallback: *mut DebugReportCallbackEXT) -> Result{
    (self.CreateDebugReportCallbackEXT_ptr)(instance, pCreateInfo, pAllocator, pCallback)
  }
  #[doc(hidden)] pub fn DestroyDebugReportCallbackEXT(&self, instance: Instance, callback: DebugReportCallbackEXT, pAllocator: *const AllocationCallbacks){
    (self.DestroyDebugReportCallbackEXT_ptr)(instance, callback, pAllocator)
  }
  #[doc(hidden)] pub fn DebugReportMessageEXT(&self, instance: Instance, flags: DebugReportFlagsEXT, objectType: DebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *const c_char, pMessage: *const c_char){
    (self.DebugReportMessageEXT_ptr)(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceExternalImageFormatPropertiesNV(&self, physicalDevice: PhysicalDevice, format: Format, typ: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, externalHandleType: ExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut ExternalImageFormatPropertiesNV) -> Result{
    (self.GetPhysicalDeviceExternalImageFormatPropertiesNV_ptr)(physicalDevice, format, typ, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties)
  }
  #[doc(hidden)] pub fn CreateViSurfaceNN(&self, instance: Instance, pCreateInfo: *const ViSurfaceCreateInfoNN, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateViSurfaceNN_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn ReleaseDisplayEXT(&self, physicalDevice: PhysicalDevice, display: DisplayKHR) -> Result{
    (self.ReleaseDisplayEXT_ptr)(physicalDevice, display)
  }
  #[doc(hidden)] pub fn AcquireXlibDisplayEXT(&self, physicalDevice: PhysicalDevice, dpy: *mut Display, display: DisplayKHR) -> Result{
    (self.AcquireXlibDisplayEXT_ptr)(physicalDevice, dpy, display)
  }
  #[doc(hidden)] pub fn GetRandROutputDisplayEXT(&self, physicalDevice: PhysicalDevice, dpy: *mut Display, rrOutput: RROutput, pDisplay: *mut DisplayKHR) -> Result{
    (self.GetRandROutputDisplayEXT_ptr)(physicalDevice, dpy, rrOutput, pDisplay)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSurfaceCapabilities2EXT(&self, physicalDevice: PhysicalDevice, surface: SurfaceKHR, pSurfaceCapabilities: *mut SurfaceCapabilities2EXT) -> Result{
    (self.GetPhysicalDeviceSurfaceCapabilities2EXT_ptr)(physicalDevice, surface, pSurfaceCapabilities)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSurfaceCapabilities2KHR(&self, physicalDevice: PhysicalDevice, pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut SurfaceCapabilities2KHR) -> Result{
    (self.GetPhysicalDeviceSurfaceCapabilities2KHR_ptr)(physicalDevice, pSurfaceInfo, pSurfaceCapabilities)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceSurfaceFormats2KHR(&self, physicalDevice: PhysicalDevice, pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut SurfaceFormat2KHR) -> Result{
    (self.GetPhysicalDeviceSurfaceFormats2KHR_ptr)(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceDisplayProperties2KHR(&self, physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayProperties2KHR) -> Result{
    (self.GetPhysicalDeviceDisplayProperties2KHR_ptr)(physicalDevice, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceDisplayPlaneProperties2KHR(&self, physicalDevice: PhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut DisplayPlaneProperties2KHR) -> Result{
    (self.GetPhysicalDeviceDisplayPlaneProperties2KHR_ptr)(physicalDevice, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn GetDisplayModeProperties2KHR(&self, physicalDevice: PhysicalDevice, display: DisplayKHR, pPropertyCount: *mut u32, pProperties: *mut DisplayModeProperties2KHR) -> Result{
    (self.GetDisplayModeProperties2KHR_ptr)(physicalDevice, display, pPropertyCount, pProperties)
  }
  #[doc(hidden)] pub fn GetDisplayPlaneCapabilities2KHR(&self, physicalDevice: PhysicalDevice, pDisplayPlaneInfo: *const DisplayPlaneInfo2KHR, pCapabilities: *mut DisplayPlaneCapabilities2KHR) -> Result{
    (self.GetDisplayPlaneCapabilities2KHR_ptr)(physicalDevice, pDisplayPlaneInfo, pCapabilities)
  }
  #[doc(hidden)] pub fn CreateIOSSurfaceMVK(&self, instance: Instance, pCreateInfo: *const IOSSurfaceCreateInfoMVK, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateIOSSurfaceMVK_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn CreateMacOSSurfaceMVK(&self, instance: Instance, pCreateInfo: *const MacOSSurfaceCreateInfoMVK, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateMacOSSurfaceMVK_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
  #[doc(hidden)] pub fn SetDebugUtilsObjectNameEXT(&self, device: Device, pNameInfo: *const DebugUtilsObjectNameInfoEXT) -> Result{
    (self.SetDebugUtilsObjectNameEXT_ptr)(device, pNameInfo)
  }
  #[doc(hidden)] pub fn SetDebugUtilsObjectTagEXT(&self, device: Device, pTagInfo: *const DebugUtilsObjectTagInfoEXT) -> Result{
    (self.SetDebugUtilsObjectTagEXT_ptr)(device, pTagInfo)
  }
  #[doc(hidden)] pub fn QueueBeginDebugUtilsLabelEXT(&self, queue: Queue, pLabelInfo: *const DebugUtilsLabelEXT){
    (self.QueueBeginDebugUtilsLabelEXT_ptr)(queue, pLabelInfo)
  }
  #[doc(hidden)] pub fn QueueEndDebugUtilsLabelEXT(&self, queue: Queue){
    (self.QueueEndDebugUtilsLabelEXT_ptr)(queue)
  }
  #[doc(hidden)] pub fn QueueInsertDebugUtilsLabelEXT(&self, queue: Queue, pLabelInfo: *const DebugUtilsLabelEXT){
    (self.QueueInsertDebugUtilsLabelEXT_ptr)(queue, pLabelInfo)
  }
  #[doc(hidden)] pub fn CmdBeginDebugUtilsLabelEXT(&self, commandBuffer: CommandBuffer, pLabelInfo: *const DebugUtilsLabelEXT){
    (self.CmdBeginDebugUtilsLabelEXT_ptr)(commandBuffer, pLabelInfo)
  }
  #[doc(hidden)] pub fn CmdEndDebugUtilsLabelEXT(&self, commandBuffer: CommandBuffer){
    (self.CmdEndDebugUtilsLabelEXT_ptr)(commandBuffer)
  }
  #[doc(hidden)] pub fn CmdInsertDebugUtilsLabelEXT(&self, commandBuffer: CommandBuffer, pLabelInfo: *const DebugUtilsLabelEXT){
    (self.CmdInsertDebugUtilsLabelEXT_ptr)(commandBuffer, pLabelInfo)
  }
  #[doc(hidden)] pub fn CreateDebugUtilsMessengerEXT(&self, instance: Instance, pCreateInfo: *const DebugUtilsMessengerCreateInfoEXT, pAllocator: *const AllocationCallbacks, pMessenger: *mut DebugUtilsMessengerEXT) -> Result{
    (self.CreateDebugUtilsMessengerEXT_ptr)(instance, pCreateInfo, pAllocator, pMessenger)
  }
  #[doc(hidden)] pub fn DestroyDebugUtilsMessengerEXT(&self, instance: Instance, messenger: DebugUtilsMessengerEXT, pAllocator: *const AllocationCallbacks){
    (self.DestroyDebugUtilsMessengerEXT_ptr)(instance, messenger, pAllocator)
  }
  #[doc(hidden)] pub fn SubmitDebugUtilsMessageEXT(&self, instance: Instance, messageSeverity: DebugUtilsMessageSeverityFlagBitsEXT, messageTypes: DebugUtilsMessageTypeFlagsEXT, pCallbackData: *const DebugUtilsMessengerCallbackDataEXT){
    (self.SubmitDebugUtilsMessageEXT_ptr)(instance, messageSeverity, messageTypes, pCallbackData)
  }
  #[doc(hidden)] pub fn CreateImagePipeSurfaceFUCHSIA(&self, instance: Instance, pCreateInfo: *const ImagePipeSurfaceCreateInfoFUCHSIA, pAllocator: *const AllocationCallbacks, pSurface: *mut SurfaceKHR) -> Result{
    (self.CreateImagePipeSurfaceFUCHSIA_ptr)(instance, pCreateInfo, pAllocator, pSurface)
  }
}


/// Vulkan device extensions
///
/// This struct is used to initialize vulkan device extensions and holds function pointers to them.
/// Function pointers are initialized during construction.
#[derive(Clone,Copy)]pub struct DeviceExtensions {
  #[allow(dead_code)]
  hdevice: Device,
  CreateSwapchainKHR_ptr: extern "system" fn (device: Device, pCreateInfo: *const SwapchainCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSwapchain: *mut SwapchainKHR) -> Result,
  DestroySwapchainKHR_ptr: extern "system" fn (device: Device, swapchain: SwapchainKHR, pAllocator: *const AllocationCallbacks),
  GetSwapchainImagesKHR_ptr: extern "system" fn (device: Device, swapchain: SwapchainKHR, pSwapchainImageCount: *mut u32, pSwapchainImages: *mut Image) -> Result,
  AcquireNextImageKHR_ptr: extern "system" fn (device: Device, swapchain: SwapchainKHR, timeout: u64, semaphore: Semaphore, fence: Fence, pImageIndex: *mut u32) -> Result,
  QueuePresentKHR_ptr: extern "system" fn (queue: Queue, pPresentInfo: *const PresentInfoKHR) -> Result,
  GetDeviceGroupPresentCapabilitiesKHR_ptr: extern "system" fn (device: Device, pDeviceGroupPresentCapabilities: *mut DeviceGroupPresentCapabilitiesKHR) -> Result,
  GetDeviceGroupSurfacePresentModesKHR_ptr: extern "system" fn (device: Device, surface: SurfaceKHR, pModes: *mut DeviceGroupPresentModeFlagsKHR) -> Result,
  GetPhysicalDevicePresentRectanglesKHR_ptr: extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pRectCount: *mut u32, pRects: *mut Rect2D) -> Result,
  AcquireNextImage2KHR_ptr: extern "system" fn (device: Device, pAcquireInfo: *const AcquireNextImageInfoKHR, pImageIndex: *mut u32) -> Result,
  CreateSharedSwapchainsKHR_ptr: extern "system" fn (device: Device, swapchainCount: u32, pCreateInfos: *const SwapchainCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSwapchains: *mut SwapchainKHR) -> Result,
  DebugMarkerSetObjectTagEXT_ptr: extern "system" fn (device: Device, pTagInfo: *const DebugMarkerObjectTagInfoEXT) -> Result,
  DebugMarkerSetObjectNameEXT_ptr: extern "system" fn (device: Device, pNameInfo: *const DebugMarkerObjectNameInfoEXT) -> Result,
  CmdDebugMarkerBeginEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, pMarkerInfo: *const DebugMarkerMarkerInfoEXT),
  CmdDebugMarkerEndEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer),
  CmdDebugMarkerInsertEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, pMarkerInfo: *const DebugMarkerMarkerInfoEXT),
  CmdBindTransformFeedbackBuffersEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const Buffer, pOffsets: *const DeviceSize, pSizes: *const DeviceSize),
  CmdBeginTransformFeedbackEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const Buffer, pCounterBufferOffsets: *const DeviceSize),
  CmdEndTransformFeedbackEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const Buffer, pCounterBufferOffsets: *const DeviceSize),
  CmdBeginQueryIndexedEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags, index: u32),
  CmdEndQueryIndexedEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, index: u32),
  CmdDrawIndirectByteCountEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: Buffer, counterBufferOffset: DeviceSize, counterOffset: u32, vertexStride: u32),
  CmdDrawIndirectCountAMD_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32),
  CmdDrawIndexedIndirectCountAMD_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32),
  GetShaderInfoAMD_ptr: extern "system" fn (device: Device, pipeline: Pipeline, shaderStage: ShaderStageFlagBits, infoType: ShaderInfoTypeAMD, pInfoSize: *mut usize, pInfo: *mut c_void) -> Result,
  GetMemoryWin32HandleNV_ptr: extern "system" fn (device: Device, memory: DeviceMemory, handleType: ExternalMemoryHandleTypeFlagsNV, pHandle: *mut HANDLE) -> Result,
  GetMemoryWin32HandleKHR_ptr: extern "system" fn (device: Device, pGetWin32HandleInfo: *const MemoryGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result,
  GetMemoryWin32HandlePropertiesKHR_ptr: extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, handle: HANDLE, pMemoryWin32HandleProperties: *mut MemoryWin32HandlePropertiesKHR) -> Result,
  GetMemoryFdKHR_ptr: extern "system" fn (device: Device, pGetFdInfo: *const MemoryGetFdInfoKHR, pFd: *mut i32) -> Result,
  GetMemoryFdPropertiesKHR_ptr: extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, fd: i32, pMemoryFdProperties: *mut MemoryFdPropertiesKHR) -> Result,
  ImportSemaphoreWin32HandleKHR_ptr: extern "system" fn (device: Device, pImportSemaphoreWin32HandleInfo: *const ImportSemaphoreWin32HandleInfoKHR) -> Result,
  GetSemaphoreWin32HandleKHR_ptr: extern "system" fn (device: Device, pGetWin32HandleInfo: *const SemaphoreGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result,
  ImportSemaphoreFdKHR_ptr: extern "system" fn (device: Device, pImportSemaphoreFdInfo: *const ImportSemaphoreFdInfoKHR) -> Result,
  GetSemaphoreFdKHR_ptr: extern "system" fn (device: Device, pGetFdInfo: *const SemaphoreGetFdInfoKHR, pFd: *mut i32) -> Result,
  CmdPushDescriptorSetKHR_ptr: extern "system" fn (commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const WriteDescriptorSet),
  CmdPushDescriptorSetWithTemplateKHR_ptr: extern "system" fn (commandBuffer: CommandBuffer, descriptorUpdateTemplate: DescriptorUpdateTemplate, layout: PipelineLayout, set: u32, pData: *const c_void),
  CmdBeginConditionalRenderingEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, pConditionalRenderingBegin: *const ConditionalRenderingBeginInfoEXT),
  CmdEndConditionalRenderingEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer),
  CmdProcessCommandsNVX_ptr: extern "system" fn (commandBuffer: CommandBuffer, pProcessCommandsInfo: *const CmdProcessCommandsInfoNVX),
  CmdReserveSpaceForCommandsNVX_ptr: extern "system" fn (commandBuffer: CommandBuffer, pReserveSpaceInfo: *const CmdReserveSpaceForCommandsInfoNVX),
  CreateIndirectCommandsLayoutNVX_ptr: extern "system" fn (device: Device, pCreateInfo: *const IndirectCommandsLayoutCreateInfoNVX, pAllocator: *const AllocationCallbacks, pIndirectCommandsLayout: *mut IndirectCommandsLayoutNVX) -> Result,
  DestroyIndirectCommandsLayoutNVX_ptr: extern "system" fn (device: Device, indirectCommandsLayout: IndirectCommandsLayoutNVX, pAllocator: *const AllocationCallbacks),
  CreateObjectTableNVX_ptr: extern "system" fn (device: Device, pCreateInfo: *const ObjectTableCreateInfoNVX, pAllocator: *const AllocationCallbacks, pObjectTable: *mut ObjectTableNVX) -> Result,
  DestroyObjectTableNVX_ptr: extern "system" fn (device: Device, objectTable: ObjectTableNVX, pAllocator: *const AllocationCallbacks),
  RegisterObjectsNVX_ptr: extern "system" fn (device: Device, objectTable: ObjectTableNVX, objectCount: u32, ppObjectTableEntries: *const *const ObjectTableEntryNVX, pObjectIndices: *const u32) -> Result,
  UnregisterObjectsNVX_ptr: extern "system" fn (device: Device, objectTable: ObjectTableNVX, objectCount: u32, pObjectEntryTypes: *const ObjectEntryTypeNVX, pObjectIndices: *const u32) -> Result,
  GetPhysicalDeviceGeneratedCommandsPropertiesNVX_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pFeatures: *mut DeviceGeneratedCommandsFeaturesNVX, pLimits: *mut DeviceGeneratedCommandsLimitsNVX),
  CmdSetViewportWScalingNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const ViewportWScalingNV),
  DisplayPowerControlEXT_ptr: extern "system" fn (device: Device, display: DisplayKHR, pDisplayPowerInfo: *const DisplayPowerInfoEXT) -> Result,
  RegisterDeviceEventEXT_ptr: extern "system" fn (device: Device, pDeviceEventInfo: *const DeviceEventInfoEXT, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result,
  RegisterDisplayEventEXT_ptr: extern "system" fn (device: Device, display: DisplayKHR, pDisplayEventInfo: *const DisplayEventInfoEXT, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result,
  GetSwapchainCounterEXT_ptr: extern "system" fn (device: Device, swapchain: SwapchainKHR, counter: SurfaceCounterFlagBitsEXT, pCounterValue: *mut u64) -> Result,
  GetRefreshCycleDurationGOOGLE_ptr: extern "system" fn (device: Device, swapchain: SwapchainKHR, pDisplayTimingProperties: *mut RefreshCycleDurationGOOGLE) -> Result,
  GetPastPresentationTimingGOOGLE_ptr: extern "system" fn (device: Device, swapchain: SwapchainKHR, pPresentationTimingCount: *mut u32, pPresentationTimings: *mut PastPresentationTimingGOOGLE) -> Result,
  CmdSetDiscardRectangleEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const Rect2D),
  SetHdrMetadataEXT_ptr: extern "system" fn (device: Device, swapchainCount: u32, pSwapchains: *const SwapchainKHR, pMetadata: *const HdrMetadataEXT),
  CreateRenderPass2KHR_ptr: extern "system" fn (device: Device, pCreateInfo: *const RenderPassCreateInfo2KHR, pAllocator: *const AllocationCallbacks, pRenderPass: *mut RenderPass) -> Result,
  CmdBeginRenderPass2KHR_ptr: extern "system" fn (commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, pSubpassBeginInfo: *const SubpassBeginInfoKHR),
  CmdNextSubpass2KHR_ptr: extern "system" fn (commandBuffer: CommandBuffer, pSubpassBeginInfo: *const SubpassBeginInfoKHR, pSubpassEndInfo: *const SubpassEndInfoKHR),
  CmdEndRenderPass2KHR_ptr: extern "system" fn (commandBuffer: CommandBuffer, pSubpassEndInfo: *const SubpassEndInfoKHR),
  GetSwapchainStatusKHR_ptr: extern "system" fn (device: Device, swapchain: SwapchainKHR) -> Result,
  ImportFenceWin32HandleKHR_ptr: extern "system" fn (device: Device, pImportFenceWin32HandleInfo: *const ImportFenceWin32HandleInfoKHR) -> Result,
  GetFenceWin32HandleKHR_ptr: extern "system" fn (device: Device, pGetWin32HandleInfo: *const FenceGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result,
  ImportFenceFdKHR_ptr: extern "system" fn (device: Device, pImportFenceFdInfo: *const ImportFenceFdInfoKHR) -> Result,
  GetFenceFdKHR_ptr: extern "system" fn (device: Device, pGetFdInfo: *const FenceGetFdInfoKHR, pFd: *mut i32) -> Result,
  GetAndroidHardwareBufferPropertiesANDROID_ptr: extern "system" fn (device: Device, buffer: *const AHardwareBuffer, pProperties: *mut AndroidHardwareBufferPropertiesANDROID) -> Result,
  GetMemoryAndroidHardwareBufferANDROID_ptr: extern "system" fn (device: Device, pInfo: *const MemoryGetAndroidHardwareBufferInfoANDROID, pBuffer: *mut *mut AHardwareBuffer) -> Result,
  CmdSetSampleLocationsEXT_ptr: extern "system" fn (commandBuffer: CommandBuffer, pSampleLocationsInfo: *const SampleLocationsInfoEXT),
  GetPhysicalDeviceMultisamplePropertiesEXT_ptr: extern "system" fn (physicalDevice: PhysicalDevice, samples: SampleCountFlagBits, pMultisampleProperties: *mut MultisamplePropertiesEXT),
  GetImageDrmFormatModifierPropertiesEXT_ptr: extern "system" fn (device: Device, image: Image, pProperties: *mut ImageDrmFormatModifierPropertiesEXT) -> Result,
  CreateValidationCacheEXT_ptr: extern "system" fn (device: Device, pCreateInfo: *const ValidationCacheCreateInfoEXT, pAllocator: *const AllocationCallbacks, pValidationCache: *mut ValidationCacheEXT) -> Result,
  DestroyValidationCacheEXT_ptr: extern "system" fn (device: Device, validationCache: ValidationCacheEXT, pAllocator: *const AllocationCallbacks),
  MergeValidationCachesEXT_ptr: extern "system" fn (device: Device, dstCache: ValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *const ValidationCacheEXT) -> Result,
  GetValidationCacheDataEXT_ptr: extern "system" fn (device: Device, validationCache: ValidationCacheEXT, pDataSize: *mut usize, pData: *mut c_void) -> Result,
  CmdBindShadingRateImageNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, imageView: ImageView, imageLayout: ImageLayout),
  CmdSetViewportShadingRatePaletteNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *const ShadingRatePaletteNV),
  CmdSetCoarseSampleOrderNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, sampleOrderType: CoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *const CoarseSampleOrderCustomNV),
  CreateAccelerationStructureNV_ptr: extern "system" fn (device: Device, pCreateInfo: *const AccelerationStructureCreateInfoNV, pAllocator: *const AllocationCallbacks, pAccelerationStructure: *mut AccelerationStructureNV) -> Result,
  DestroyAccelerationStructureNV_ptr: extern "system" fn (device: Device, accelerationStructure: AccelerationStructureNV, pAllocator: *const AllocationCallbacks),
  GetAccelerationStructureMemoryRequirementsNV_ptr: extern "system" fn (device: Device, pInfo: *const AccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *mut MemoryRequirements2),
  BindAccelerationStructureMemoryNV_ptr: extern "system" fn (device: Device, bindInfoCount: u32, pBindInfos: *const BindAccelerationStructureMemoryInfoNV) -> Result,
  CmdBuildAccelerationStructureNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, pInfo: *const AccelerationStructureInfoNV, instanceData: Buffer, instanceOffset: DeviceSize, update: Bool32, dst: AccelerationStructureNV, src: AccelerationStructureNV, scratch: Buffer, scratchOffset: DeviceSize),
  CmdCopyAccelerationStructureNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, dst: AccelerationStructureNV, src: AccelerationStructureNV, mode: CopyAccelerationStructureModeNV),
  CmdTraceRaysNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, raygenShaderBindingTableBuffer: Buffer, raygenShaderBindingOffset: DeviceSize, missShaderBindingTableBuffer: Buffer, missShaderBindingOffset: DeviceSize, missShaderBindingStride: DeviceSize, hitShaderBindingTableBuffer: Buffer, hitShaderBindingOffset: DeviceSize, hitShaderBindingStride: DeviceSize, callableShaderBindingTableBuffer: Buffer, callableShaderBindingOffset: DeviceSize, callableShaderBindingStride: DeviceSize, width: u32, height: u32, depth: u32),
  CreateRayTracingPipelinesNV_ptr: extern "system" fn (device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const RayTracingPipelineCreateInfoNV, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result,
  GetRayTracingShaderGroupHandlesNV_ptr: extern "system" fn (device: Device, pipeline: Pipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> Result,
  GetAccelerationStructureHandleNV_ptr: extern "system" fn (device: Device, accelerationStructure: AccelerationStructureNV, dataSize: usize, pData: *mut c_void) -> Result,
  CmdWriteAccelerationStructuresPropertiesNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *const AccelerationStructureNV, queryType: QueryType, queryPool: QueryPool, firstQuery: u32),
  CompileDeferredNV_ptr: extern "system" fn (device: Device, pipeline: Pipeline, shader: u32) -> Result,
  CmdDrawIndirectCountKHR_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32),
  CmdDrawIndexedIndirectCountKHR_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32),
  GetMemoryHostPointerPropertiesEXT_ptr: extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut MemoryHostPointerPropertiesEXT) -> Result,
  CmdWriteBufferMarkerAMD_ptr: extern "system" fn (commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlagBits, dstBuffer: Buffer, dstOffset: DeviceSize, marker: u32),
  GetPhysicalDeviceCalibrateableTimeDomainsEXT_ptr: extern "system" fn (physicalDevice: PhysicalDevice, pTimeDomainCount: *mut u32, pTimeDomains: *mut TimeDomainEXT) -> Result,
  GetCalibratedTimestampsEXT_ptr: extern "system" fn (device: Device, timestampCount: u32, pTimestampInfos: *const CalibratedTimestampInfoEXT, pTimestamps: *mut u64, pMaxDeviation: *mut u64) -> Result,
  CmdDrawMeshTasksNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, taskCount: u32, firstTask: u32),
  CmdDrawMeshTasksIndirectNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32),
  CmdDrawMeshTasksIndirectCountNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32),
  CmdSetExclusiveScissorNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *const Rect2D),
  CmdSetCheckpointNV_ptr: extern "system" fn (commandBuffer: CommandBuffer, pCheckpointMarker: *const c_void),
  GetQueueCheckpointDataNV_ptr: extern "system" fn (queue: Queue, pCheckpointDataCount: *mut u32, pCheckpointData: *mut CheckpointDataNV),
}


extern "system" fn CreateSwapchainKHR_panic(_device: Device, _pCreateInfo: *const SwapchainCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pSwapchain: *mut SwapchainKHR) -> Result{
    panic!("extension vkCreateSwapchainKHR not loaded")
}
extern "system" fn DestroySwapchainKHR_panic(_device: Device, _swapchain: SwapchainKHR, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroySwapchainKHR not loaded")
}
extern "system" fn GetSwapchainImagesKHR_panic(_device: Device, _swapchain: SwapchainKHR, _pSwapchainImageCount: *mut u32, _pSwapchainImages: *mut Image) -> Result{
    panic!("extension vkGetSwapchainImagesKHR not loaded")
}
extern "system" fn AcquireNextImageKHR_panic(_device: Device, _swapchain: SwapchainKHR, _timeout: u64, _semaphore: Semaphore, _fence: Fence, _pImageIndex: *mut u32) -> Result{
    panic!("extension vkAcquireNextImageKHR not loaded")
}
extern "system" fn QueuePresentKHR_panic(_queue: Queue, _pPresentInfo: *const PresentInfoKHR) -> Result{
    panic!("extension vkQueuePresentKHR not loaded")
}
extern "system" fn GetDeviceGroupPresentCapabilitiesKHR_panic(_device: Device, _pDeviceGroupPresentCapabilities: *mut DeviceGroupPresentCapabilitiesKHR) -> Result{
    panic!("extension vkGetDeviceGroupPresentCapabilitiesKHR not loaded")
}
extern "system" fn GetDeviceGroupSurfacePresentModesKHR_panic(_device: Device, _surface: SurfaceKHR, _pModes: *mut DeviceGroupPresentModeFlagsKHR) -> Result{
    panic!("extension vkGetDeviceGroupSurfacePresentModesKHR not loaded")
}
extern "system" fn GetPhysicalDevicePresentRectanglesKHR_panic(_physicalDevice: PhysicalDevice, _surface: SurfaceKHR, _pRectCount: *mut u32, _pRects: *mut Rect2D) -> Result{
    panic!("extension vkGetPhysicalDevicePresentRectanglesKHR not loaded")
}
extern "system" fn AcquireNextImage2KHR_panic(_device: Device, _pAcquireInfo: *const AcquireNextImageInfoKHR, _pImageIndex: *mut u32) -> Result{
    panic!("extension vkAcquireNextImage2KHR not loaded")
}
extern "system" fn CreateSharedSwapchainsKHR_panic(_device: Device, _swapchainCount: u32, _pCreateInfos: *const SwapchainCreateInfoKHR, _pAllocator: *const AllocationCallbacks, _pSwapchains: *mut SwapchainKHR) -> Result{
    panic!("extension vkCreateSharedSwapchainsKHR not loaded")
}
extern "system" fn DebugMarkerSetObjectTagEXT_panic(_device: Device, _pTagInfo: *const DebugMarkerObjectTagInfoEXT) -> Result{
    panic!("extension vkDebugMarkerSetObjectTagEXT not loaded")
}
extern "system" fn DebugMarkerSetObjectNameEXT_panic(_device: Device, _pNameInfo: *const DebugMarkerObjectNameInfoEXT) -> Result{
    panic!("extension vkDebugMarkerSetObjectNameEXT not loaded")
}
extern "system" fn CmdDebugMarkerBeginEXT_panic(_commandBuffer: CommandBuffer, _pMarkerInfo: *const DebugMarkerMarkerInfoEXT){
    panic!("extension vkCmdDebugMarkerBeginEXT not loaded")
}
extern "system" fn CmdDebugMarkerEndEXT_panic(_commandBuffer: CommandBuffer){
    panic!("extension vkCmdDebugMarkerEndEXT not loaded")
}
extern "system" fn CmdDebugMarkerInsertEXT_panic(_commandBuffer: CommandBuffer, _pMarkerInfo: *const DebugMarkerMarkerInfoEXT){
    panic!("extension vkCmdDebugMarkerInsertEXT not loaded")
}
extern "system" fn CmdBindTransformFeedbackBuffersEXT_panic(_commandBuffer: CommandBuffer, _firstBinding: u32, _bindingCount: u32, _pBuffers: *const Buffer, _pOffsets: *const DeviceSize, _pSizes: *const DeviceSize){
    panic!("extension vkCmdBindTransformFeedbackBuffersEXT not loaded")
}
extern "system" fn CmdBeginTransformFeedbackEXT_panic(_commandBuffer: CommandBuffer, _firstCounterBuffer: u32, _counterBufferCount: u32, _pCounterBuffers: *const Buffer, _pCounterBufferOffsets: *const DeviceSize){
    panic!("extension vkCmdBeginTransformFeedbackEXT not loaded")
}
extern "system" fn CmdEndTransformFeedbackEXT_panic(_commandBuffer: CommandBuffer, _firstCounterBuffer: u32, _counterBufferCount: u32, _pCounterBuffers: *const Buffer, _pCounterBufferOffsets: *const DeviceSize){
    panic!("extension vkCmdEndTransformFeedbackEXT not loaded")
}
extern "system" fn CmdBeginQueryIndexedEXT_panic(_commandBuffer: CommandBuffer, _queryPool: QueryPool, _query: u32, _flags: QueryControlFlags, _index: u32){
    panic!("extension vkCmdBeginQueryIndexedEXT not loaded")
}
extern "system" fn CmdEndQueryIndexedEXT_panic(_commandBuffer: CommandBuffer, _queryPool: QueryPool, _query: u32, _index: u32){
    panic!("extension vkCmdEndQueryIndexedEXT not loaded")
}
extern "system" fn CmdDrawIndirectByteCountEXT_panic(_commandBuffer: CommandBuffer, _instanceCount: u32, _firstInstance: u32, _counterBuffer: Buffer, _counterBufferOffset: DeviceSize, _counterOffset: u32, _vertexStride: u32){
    panic!("extension vkCmdDrawIndirectByteCountEXT not loaded")
}
extern "system" fn CmdDrawIndirectCountAMD_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _countBuffer: Buffer, _countBufferOffset: DeviceSize, _maxDrawCount: u32, _stride: u32){
    panic!("extension vkCmdDrawIndirectCountAMD not loaded")
}
extern "system" fn CmdDrawIndexedIndirectCountAMD_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _countBuffer: Buffer, _countBufferOffset: DeviceSize, _maxDrawCount: u32, _stride: u32){
    panic!("extension vkCmdDrawIndexedIndirectCountAMD not loaded")
}
extern "system" fn GetShaderInfoAMD_panic(_device: Device, _pipeline: Pipeline, _shaderStage: ShaderStageFlagBits, _infoType: ShaderInfoTypeAMD, _pInfoSize: *mut usize, _pInfo: *mut c_void) -> Result{
    panic!("extension vkGetShaderInfoAMD not loaded")
}
extern "system" fn GetMemoryWin32HandleNV_panic(_device: Device, _memory: DeviceMemory, _handleType: ExternalMemoryHandleTypeFlagsNV, _pHandle: *mut HANDLE) -> Result{
    panic!("extension vkGetMemoryWin32HandleNV not loaded")
}
extern "system" fn GetMemoryWin32HandleKHR_panic(_device: Device, _pGetWin32HandleInfo: *const MemoryGetWin32HandleInfoKHR, _pHandle: *mut HANDLE) -> Result{
    panic!("extension vkGetMemoryWin32HandleKHR not loaded")
}
extern "system" fn GetMemoryWin32HandlePropertiesKHR_panic(_device: Device, _handleType: ExternalMemoryHandleTypeFlagBits, _handle: HANDLE, _pMemoryWin32HandleProperties: *mut MemoryWin32HandlePropertiesKHR) -> Result{
    panic!("extension vkGetMemoryWin32HandlePropertiesKHR not loaded")
}
extern "system" fn GetMemoryFdKHR_panic(_device: Device, _pGetFdInfo: *const MemoryGetFdInfoKHR, _pFd: *mut i32) -> Result{
    panic!("extension vkGetMemoryFdKHR not loaded")
}
extern "system" fn GetMemoryFdPropertiesKHR_panic(_device: Device, _handleType: ExternalMemoryHandleTypeFlagBits, _fd: i32, _pMemoryFdProperties: *mut MemoryFdPropertiesKHR) -> Result{
    panic!("extension vkGetMemoryFdPropertiesKHR not loaded")
}
extern "system" fn ImportSemaphoreWin32HandleKHR_panic(_device: Device, _pImportSemaphoreWin32HandleInfo: *const ImportSemaphoreWin32HandleInfoKHR) -> Result{
    panic!("extension vkImportSemaphoreWin32HandleKHR not loaded")
}
extern "system" fn GetSemaphoreWin32HandleKHR_panic(_device: Device, _pGetWin32HandleInfo: *const SemaphoreGetWin32HandleInfoKHR, _pHandle: *mut HANDLE) -> Result{
    panic!("extension vkGetSemaphoreWin32HandleKHR not loaded")
}
extern "system" fn ImportSemaphoreFdKHR_panic(_device: Device, _pImportSemaphoreFdInfo: *const ImportSemaphoreFdInfoKHR) -> Result{
    panic!("extension vkImportSemaphoreFdKHR not loaded")
}
extern "system" fn GetSemaphoreFdKHR_panic(_device: Device, _pGetFdInfo: *const SemaphoreGetFdInfoKHR, _pFd: *mut i32) -> Result{
    panic!("extension vkGetSemaphoreFdKHR not loaded")
}
extern "system" fn CmdPushDescriptorSetKHR_panic(_commandBuffer: CommandBuffer, _pipelineBindPoint: PipelineBindPoint, _layout: PipelineLayout, _set: u32, _descriptorWriteCount: u32, _pDescriptorWrites: *const WriteDescriptorSet){
    panic!("extension vkCmdPushDescriptorSetKHR not loaded")
}
extern "system" fn CmdPushDescriptorSetWithTemplateKHR_panic(_commandBuffer: CommandBuffer, _descriptorUpdateTemplate: DescriptorUpdateTemplate, _layout: PipelineLayout, _set: u32, _pData: *const c_void){
    panic!("extension vkCmdPushDescriptorSetWithTemplateKHR not loaded")
}
extern "system" fn CmdBeginConditionalRenderingEXT_panic(_commandBuffer: CommandBuffer, _pConditionalRenderingBegin: *const ConditionalRenderingBeginInfoEXT){
    panic!("extension vkCmdBeginConditionalRenderingEXT not loaded")
}
extern "system" fn CmdEndConditionalRenderingEXT_panic(_commandBuffer: CommandBuffer){
    panic!("extension vkCmdEndConditionalRenderingEXT not loaded")
}
extern "system" fn CmdProcessCommandsNVX_panic(_commandBuffer: CommandBuffer, _pProcessCommandsInfo: *const CmdProcessCommandsInfoNVX){
    panic!("extension vkCmdProcessCommandsNVX not loaded")
}
extern "system" fn CmdReserveSpaceForCommandsNVX_panic(_commandBuffer: CommandBuffer, _pReserveSpaceInfo: *const CmdReserveSpaceForCommandsInfoNVX){
    panic!("extension vkCmdReserveSpaceForCommandsNVX not loaded")
}
extern "system" fn CreateIndirectCommandsLayoutNVX_panic(_device: Device, _pCreateInfo: *const IndirectCommandsLayoutCreateInfoNVX, _pAllocator: *const AllocationCallbacks, _pIndirectCommandsLayout: *mut IndirectCommandsLayoutNVX) -> Result{
    panic!("extension vkCreateIndirectCommandsLayoutNVX not loaded")
}
extern "system" fn DestroyIndirectCommandsLayoutNVX_panic(_device: Device, _indirectCommandsLayout: IndirectCommandsLayoutNVX, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyIndirectCommandsLayoutNVX not loaded")
}
extern "system" fn CreateObjectTableNVX_panic(_device: Device, _pCreateInfo: *const ObjectTableCreateInfoNVX, _pAllocator: *const AllocationCallbacks, _pObjectTable: *mut ObjectTableNVX) -> Result{
    panic!("extension vkCreateObjectTableNVX not loaded")
}
extern "system" fn DestroyObjectTableNVX_panic(_device: Device, _objectTable: ObjectTableNVX, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyObjectTableNVX not loaded")
}
extern "system" fn RegisterObjectsNVX_panic(_device: Device, _objectTable: ObjectTableNVX, _objectCount: u32, _ppObjectTableEntries: *const *const ObjectTableEntryNVX, _pObjectIndices: *const u32) -> Result{
    panic!("extension vkRegisterObjectsNVX not loaded")
}
extern "system" fn UnregisterObjectsNVX_panic(_device: Device, _objectTable: ObjectTableNVX, _objectCount: u32, _pObjectEntryTypes: *const ObjectEntryTypeNVX, _pObjectIndices: *const u32) -> Result{
    panic!("extension vkUnregisterObjectsNVX not loaded")
}
extern "system" fn GetPhysicalDeviceGeneratedCommandsPropertiesNVX_panic(_physicalDevice: PhysicalDevice, _pFeatures: *mut DeviceGeneratedCommandsFeaturesNVX, _pLimits: *mut DeviceGeneratedCommandsLimitsNVX){
    panic!("extension vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX not loaded")
}
extern "system" fn CmdSetViewportWScalingNV_panic(_commandBuffer: CommandBuffer, _firstViewport: u32, _viewportCount: u32, _pViewportWScalings: *const ViewportWScalingNV){
    panic!("extension vkCmdSetViewportWScalingNV not loaded")
}
extern "system" fn DisplayPowerControlEXT_panic(_device: Device, _display: DisplayKHR, _pDisplayPowerInfo: *const DisplayPowerInfoEXT) -> Result{
    panic!("extension vkDisplayPowerControlEXT not loaded")
}
extern "system" fn RegisterDeviceEventEXT_panic(_device: Device, _pDeviceEventInfo: *const DeviceEventInfoEXT, _pAllocator: *const AllocationCallbacks, _pFence: *mut Fence) -> Result{
    panic!("extension vkRegisterDeviceEventEXT not loaded")
}
extern "system" fn RegisterDisplayEventEXT_panic(_device: Device, _display: DisplayKHR, _pDisplayEventInfo: *const DisplayEventInfoEXT, _pAllocator: *const AllocationCallbacks, _pFence: *mut Fence) -> Result{
    panic!("extension vkRegisterDisplayEventEXT not loaded")
}
extern "system" fn GetSwapchainCounterEXT_panic(_device: Device, _swapchain: SwapchainKHR, _counter: SurfaceCounterFlagBitsEXT, _pCounterValue: *mut u64) -> Result{
    panic!("extension vkGetSwapchainCounterEXT not loaded")
}
extern "system" fn GetRefreshCycleDurationGOOGLE_panic(_device: Device, _swapchain: SwapchainKHR, _pDisplayTimingProperties: *mut RefreshCycleDurationGOOGLE) -> Result{
    panic!("extension vkGetRefreshCycleDurationGOOGLE not loaded")
}
extern "system" fn GetPastPresentationTimingGOOGLE_panic(_device: Device, _swapchain: SwapchainKHR, _pPresentationTimingCount: *mut u32, _pPresentationTimings: *mut PastPresentationTimingGOOGLE) -> Result{
    panic!("extension vkGetPastPresentationTimingGOOGLE not loaded")
}
extern "system" fn CmdSetDiscardRectangleEXT_panic(_commandBuffer: CommandBuffer, _firstDiscardRectangle: u32, _discardRectangleCount: u32, _pDiscardRectangles: *const Rect2D){
    panic!("extension vkCmdSetDiscardRectangleEXT not loaded")
}
extern "system" fn SetHdrMetadataEXT_panic(_device: Device, _swapchainCount: u32, _pSwapchains: *const SwapchainKHR, _pMetadata: *const HdrMetadataEXT){
    panic!("extension vkSetHdrMetadataEXT not loaded")
}
extern "system" fn CreateRenderPass2KHR_panic(_device: Device, _pCreateInfo: *const RenderPassCreateInfo2KHR, _pAllocator: *const AllocationCallbacks, _pRenderPass: *mut RenderPass) -> Result{
    panic!("extension vkCreateRenderPass2KHR not loaded")
}
extern "system" fn CmdBeginRenderPass2KHR_panic(_commandBuffer: CommandBuffer, _pRenderPassBegin: *const RenderPassBeginInfo, _pSubpassBeginInfo: *const SubpassBeginInfoKHR){
    panic!("extension vkCmdBeginRenderPass2KHR not loaded")
}
extern "system" fn CmdNextSubpass2KHR_panic(_commandBuffer: CommandBuffer, _pSubpassBeginInfo: *const SubpassBeginInfoKHR, _pSubpassEndInfo: *const SubpassEndInfoKHR){
    panic!("extension vkCmdNextSubpass2KHR not loaded")
}
extern "system" fn CmdEndRenderPass2KHR_panic(_commandBuffer: CommandBuffer, _pSubpassEndInfo: *const SubpassEndInfoKHR){
    panic!("extension vkCmdEndRenderPass2KHR not loaded")
}
extern "system" fn GetSwapchainStatusKHR_panic(_device: Device, _swapchain: SwapchainKHR) -> Result{
    panic!("extension vkGetSwapchainStatusKHR not loaded")
}
extern "system" fn ImportFenceWin32HandleKHR_panic(_device: Device, _pImportFenceWin32HandleInfo: *const ImportFenceWin32HandleInfoKHR) -> Result{
    panic!("extension vkImportFenceWin32HandleKHR not loaded")
}
extern "system" fn GetFenceWin32HandleKHR_panic(_device: Device, _pGetWin32HandleInfo: *const FenceGetWin32HandleInfoKHR, _pHandle: *mut HANDLE) -> Result{
    panic!("extension vkGetFenceWin32HandleKHR not loaded")
}
extern "system" fn ImportFenceFdKHR_panic(_device: Device, _pImportFenceFdInfo: *const ImportFenceFdInfoKHR) -> Result{
    panic!("extension vkImportFenceFdKHR not loaded")
}
extern "system" fn GetFenceFdKHR_panic(_device: Device, _pGetFdInfo: *const FenceGetFdInfoKHR, _pFd: *mut i32) -> Result{
    panic!("extension vkGetFenceFdKHR not loaded")
}
extern "system" fn GetAndroidHardwareBufferPropertiesANDROID_panic(_device: Device, _buffer: *const AHardwareBuffer, _pProperties: *mut AndroidHardwareBufferPropertiesANDROID) -> Result{
    panic!("extension vkGetAndroidHardwareBufferPropertiesANDROID not loaded")
}
extern "system" fn GetMemoryAndroidHardwareBufferANDROID_panic(_device: Device, _pInfo: *const MemoryGetAndroidHardwareBufferInfoANDROID, _pBuffer: *mut *mut AHardwareBuffer) -> Result{
    panic!("extension vkGetMemoryAndroidHardwareBufferANDROID not loaded")
}
extern "system" fn CmdSetSampleLocationsEXT_panic(_commandBuffer: CommandBuffer, _pSampleLocationsInfo: *const SampleLocationsInfoEXT){
    panic!("extension vkCmdSetSampleLocationsEXT not loaded")
}
extern "system" fn GetPhysicalDeviceMultisamplePropertiesEXT_panic(_physicalDevice: PhysicalDevice, _samples: SampleCountFlagBits, _pMultisampleProperties: *mut MultisamplePropertiesEXT){
    panic!("extension vkGetPhysicalDeviceMultisamplePropertiesEXT not loaded")
}
extern "system" fn GetImageDrmFormatModifierPropertiesEXT_panic(_device: Device, _image: Image, _pProperties: *mut ImageDrmFormatModifierPropertiesEXT) -> Result{
    panic!("extension vkGetImageDrmFormatModifierPropertiesEXT not loaded")
}
extern "system" fn CreateValidationCacheEXT_panic(_device: Device, _pCreateInfo: *const ValidationCacheCreateInfoEXT, _pAllocator: *const AllocationCallbacks, _pValidationCache: *mut ValidationCacheEXT) -> Result{
    panic!("extension vkCreateValidationCacheEXT not loaded")
}
extern "system" fn DestroyValidationCacheEXT_panic(_device: Device, _validationCache: ValidationCacheEXT, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyValidationCacheEXT not loaded")
}
extern "system" fn MergeValidationCachesEXT_panic(_device: Device, _dstCache: ValidationCacheEXT, _srcCacheCount: u32, _pSrcCaches: *const ValidationCacheEXT) -> Result{
    panic!("extension vkMergeValidationCachesEXT not loaded")
}
extern "system" fn GetValidationCacheDataEXT_panic(_device: Device, _validationCache: ValidationCacheEXT, _pDataSize: *mut usize, _pData: *mut c_void) -> Result{
    panic!("extension vkGetValidationCacheDataEXT not loaded")
}
extern "system" fn CmdBindShadingRateImageNV_panic(_commandBuffer: CommandBuffer, _imageView: ImageView, _imageLayout: ImageLayout){
    panic!("extension vkCmdBindShadingRateImageNV not loaded")
}
extern "system" fn CmdSetViewportShadingRatePaletteNV_panic(_commandBuffer: CommandBuffer, _firstViewport: u32, _viewportCount: u32, _pShadingRatePalettes: *const ShadingRatePaletteNV){
    panic!("extension vkCmdSetViewportShadingRatePaletteNV not loaded")
}
extern "system" fn CmdSetCoarseSampleOrderNV_panic(_commandBuffer: CommandBuffer, _sampleOrderType: CoarseSampleOrderTypeNV, _customSampleOrderCount: u32, _pCustomSampleOrders: *const CoarseSampleOrderCustomNV){
    panic!("extension vkCmdSetCoarseSampleOrderNV not loaded")
}
extern "system" fn CreateAccelerationStructureNV_panic(_device: Device, _pCreateInfo: *const AccelerationStructureCreateInfoNV, _pAllocator: *const AllocationCallbacks, _pAccelerationStructure: *mut AccelerationStructureNV) -> Result{
    panic!("extension vkCreateAccelerationStructureNV not loaded")
}
extern "system" fn DestroyAccelerationStructureNV_panic(_device: Device, _accelerationStructure: AccelerationStructureNV, _pAllocator: *const AllocationCallbacks){
    panic!("extension vkDestroyAccelerationStructureNV not loaded")
}
extern "system" fn GetAccelerationStructureMemoryRequirementsNV_panic(_device: Device, _pInfo: *const AccelerationStructureMemoryRequirementsInfoNV, _pMemoryRequirements: *mut MemoryRequirements2){
    panic!("extension vkGetAccelerationStructureMemoryRequirementsNV not loaded")
}
extern "system" fn BindAccelerationStructureMemoryNV_panic(_device: Device, _bindInfoCount: u32, _pBindInfos: *const BindAccelerationStructureMemoryInfoNV) -> Result{
    panic!("extension vkBindAccelerationStructureMemoryNV not loaded")
}
extern "system" fn CmdBuildAccelerationStructureNV_panic(_commandBuffer: CommandBuffer, _pInfo: *const AccelerationStructureInfoNV, _instanceData: Buffer, _instanceOffset: DeviceSize, _update: Bool32, _dst: AccelerationStructureNV, _src: AccelerationStructureNV, _scratch: Buffer, _scratchOffset: DeviceSize){
    panic!("extension vkCmdBuildAccelerationStructureNV not loaded")
}
extern "system" fn CmdCopyAccelerationStructureNV_panic(_commandBuffer: CommandBuffer, _dst: AccelerationStructureNV, _src: AccelerationStructureNV, _mode: CopyAccelerationStructureModeNV){
    panic!("extension vkCmdCopyAccelerationStructureNV not loaded")
}
extern "system" fn CmdTraceRaysNV_panic(_commandBuffer: CommandBuffer, _raygenShaderBindingTableBuffer: Buffer, _raygenShaderBindingOffset: DeviceSize, _missShaderBindingTableBuffer: Buffer, _missShaderBindingOffset: DeviceSize, _missShaderBindingStride: DeviceSize, _hitShaderBindingTableBuffer: Buffer, _hitShaderBindingOffset: DeviceSize, _hitShaderBindingStride: DeviceSize, _callableShaderBindingTableBuffer: Buffer, _callableShaderBindingOffset: DeviceSize, _callableShaderBindingStride: DeviceSize, _width: u32, _height: u32, _depth: u32){
    panic!("extension vkCmdTraceRaysNV not loaded")
}
extern "system" fn CreateRayTracingPipelinesNV_panic(_device: Device, _pipelineCache: PipelineCache, _createInfoCount: u32, _pCreateInfos: *const RayTracingPipelineCreateInfoNV, _pAllocator: *const AllocationCallbacks, _pPipelines: *mut Pipeline) -> Result{
    panic!("extension vkCreateRayTracingPipelinesNV not loaded")
}
extern "system" fn GetRayTracingShaderGroupHandlesNV_panic(_device: Device, _pipeline: Pipeline, _firstGroup: u32, _groupCount: u32, _dataSize: usize, _pData: *mut c_void) -> Result{
    panic!("extension vkGetRayTracingShaderGroupHandlesNV not loaded")
}
extern "system" fn GetAccelerationStructureHandleNV_panic(_device: Device, _accelerationStructure: AccelerationStructureNV, _dataSize: usize, _pData: *mut c_void) -> Result{
    panic!("extension vkGetAccelerationStructureHandleNV not loaded")
}
extern "system" fn CmdWriteAccelerationStructuresPropertiesNV_panic(_commandBuffer: CommandBuffer, _accelerationStructureCount: u32, _pAccelerationStructures: *const AccelerationStructureNV, _queryType: QueryType, _queryPool: QueryPool, _firstQuery: u32){
    panic!("extension vkCmdWriteAccelerationStructuresPropertiesNV not loaded")
}
extern "system" fn CompileDeferredNV_panic(_device: Device, _pipeline: Pipeline, _shader: u32) -> Result{
    panic!("extension vkCompileDeferredNV not loaded")
}
extern "system" fn CmdDrawIndirectCountKHR_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _countBuffer: Buffer, _countBufferOffset: DeviceSize, _maxDrawCount: u32, _stride: u32){
    panic!("extension vkCmdDrawIndirectCountKHR not loaded")
}
extern "system" fn CmdDrawIndexedIndirectCountKHR_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _countBuffer: Buffer, _countBufferOffset: DeviceSize, _maxDrawCount: u32, _stride: u32){
    panic!("extension vkCmdDrawIndexedIndirectCountKHR not loaded")
}
extern "system" fn GetMemoryHostPointerPropertiesEXT_panic(_device: Device, _handleType: ExternalMemoryHandleTypeFlagBits, _pHostPointer: *const c_void, _pMemoryHostPointerProperties: *mut MemoryHostPointerPropertiesEXT) -> Result{
    panic!("extension vkGetMemoryHostPointerPropertiesEXT not loaded")
}
extern "system" fn CmdWriteBufferMarkerAMD_panic(_commandBuffer: CommandBuffer, _pipelineStage: PipelineStageFlagBits, _dstBuffer: Buffer, _dstOffset: DeviceSize, _marker: u32){
    panic!("extension vkCmdWriteBufferMarkerAMD not loaded")
}
extern "system" fn GetPhysicalDeviceCalibrateableTimeDomainsEXT_panic(_physicalDevice: PhysicalDevice, _pTimeDomainCount: *mut u32, _pTimeDomains: *mut TimeDomainEXT) -> Result{
    panic!("extension vkGetPhysicalDeviceCalibrateableTimeDomainsEXT not loaded")
}
extern "system" fn GetCalibratedTimestampsEXT_panic(_device: Device, _timestampCount: u32, _pTimestampInfos: *const CalibratedTimestampInfoEXT, _pTimestamps: *mut u64, _pMaxDeviation: *mut u64) -> Result{
    panic!("extension vkGetCalibratedTimestampsEXT not loaded")
}
extern "system" fn CmdDrawMeshTasksNV_panic(_commandBuffer: CommandBuffer, _taskCount: u32, _firstTask: u32){
    panic!("extension vkCmdDrawMeshTasksNV not loaded")
}
extern "system" fn CmdDrawMeshTasksIndirectNV_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _drawCount: u32, _stride: u32){
    panic!("extension vkCmdDrawMeshTasksIndirectNV not loaded")
}
extern "system" fn CmdDrawMeshTasksIndirectCountNV_panic(_commandBuffer: CommandBuffer, _buffer: Buffer, _offset: DeviceSize, _countBuffer: Buffer, _countBufferOffset: DeviceSize, _maxDrawCount: u32, _stride: u32){
    panic!("extension vkCmdDrawMeshTasksIndirectCountNV not loaded")
}
extern "system" fn CmdSetExclusiveScissorNV_panic(_commandBuffer: CommandBuffer, _firstExclusiveScissor: u32, _exclusiveScissorCount: u32, _pExclusiveScissors: *const Rect2D){
    panic!("extension vkCmdSetExclusiveScissorNV not loaded")
}
extern "system" fn CmdSetCheckpointNV_panic(_commandBuffer: CommandBuffer, _pCheckpointMarker: *const c_void){
    panic!("extension vkCmdSetCheckpointNV not loaded")
}
extern "system" fn GetQueueCheckpointDataNV_panic(_queue: Queue, _pCheckpointDataCount: *mut u32, _pCheckpointData: *mut CheckpointDataNV){
    panic!("extension vkGetQueueCheckpointDataNV not loaded")
}


impl Default for DeviceExtensions {
  /// Initializes all function pointers to functions that immediately panic.
  fn default() -> DeviceExtensions {
    DeviceExtensions {
      hdevice: NULL_HANDLE,
      CreateSwapchainKHR_ptr: CreateSwapchainKHR_panic,
      DestroySwapchainKHR_ptr: DestroySwapchainKHR_panic,
      GetSwapchainImagesKHR_ptr: GetSwapchainImagesKHR_panic,
      AcquireNextImageKHR_ptr: AcquireNextImageKHR_panic,
      QueuePresentKHR_ptr: QueuePresentKHR_panic,
      GetDeviceGroupPresentCapabilitiesKHR_ptr: GetDeviceGroupPresentCapabilitiesKHR_panic,
      GetDeviceGroupSurfacePresentModesKHR_ptr: GetDeviceGroupSurfacePresentModesKHR_panic,
      GetPhysicalDevicePresentRectanglesKHR_ptr: GetPhysicalDevicePresentRectanglesKHR_panic,
      AcquireNextImage2KHR_ptr: AcquireNextImage2KHR_panic,
      CreateSharedSwapchainsKHR_ptr: CreateSharedSwapchainsKHR_panic,
      DebugMarkerSetObjectTagEXT_ptr: DebugMarkerSetObjectTagEXT_panic,
      DebugMarkerSetObjectNameEXT_ptr: DebugMarkerSetObjectNameEXT_panic,
      CmdDebugMarkerBeginEXT_ptr: CmdDebugMarkerBeginEXT_panic,
      CmdDebugMarkerEndEXT_ptr: CmdDebugMarkerEndEXT_panic,
      CmdDebugMarkerInsertEXT_ptr: CmdDebugMarkerInsertEXT_panic,
      CmdBindTransformFeedbackBuffersEXT_ptr: CmdBindTransformFeedbackBuffersEXT_panic,
      CmdBeginTransformFeedbackEXT_ptr: CmdBeginTransformFeedbackEXT_panic,
      CmdEndTransformFeedbackEXT_ptr: CmdEndTransformFeedbackEXT_panic,
      CmdBeginQueryIndexedEXT_ptr: CmdBeginQueryIndexedEXT_panic,
      CmdEndQueryIndexedEXT_ptr: CmdEndQueryIndexedEXT_panic,
      CmdDrawIndirectByteCountEXT_ptr: CmdDrawIndirectByteCountEXT_panic,
      CmdDrawIndirectCountAMD_ptr: CmdDrawIndirectCountAMD_panic,
      CmdDrawIndexedIndirectCountAMD_ptr: CmdDrawIndexedIndirectCountAMD_panic,
      GetShaderInfoAMD_ptr: GetShaderInfoAMD_panic,
      GetMemoryWin32HandleNV_ptr: GetMemoryWin32HandleNV_panic,
      GetMemoryWin32HandleKHR_ptr: GetMemoryWin32HandleKHR_panic,
      GetMemoryWin32HandlePropertiesKHR_ptr: GetMemoryWin32HandlePropertiesKHR_panic,
      GetMemoryFdKHR_ptr: GetMemoryFdKHR_panic,
      GetMemoryFdPropertiesKHR_ptr: GetMemoryFdPropertiesKHR_panic,
      ImportSemaphoreWin32HandleKHR_ptr: ImportSemaphoreWin32HandleKHR_panic,
      GetSemaphoreWin32HandleKHR_ptr: GetSemaphoreWin32HandleKHR_panic,
      ImportSemaphoreFdKHR_ptr: ImportSemaphoreFdKHR_panic,
      GetSemaphoreFdKHR_ptr: GetSemaphoreFdKHR_panic,
      CmdPushDescriptorSetKHR_ptr: CmdPushDescriptorSetKHR_panic,
      CmdPushDescriptorSetWithTemplateKHR_ptr: CmdPushDescriptorSetWithTemplateKHR_panic,
      CmdBeginConditionalRenderingEXT_ptr: CmdBeginConditionalRenderingEXT_panic,
      CmdEndConditionalRenderingEXT_ptr: CmdEndConditionalRenderingEXT_panic,
      CmdProcessCommandsNVX_ptr: CmdProcessCommandsNVX_panic,
      CmdReserveSpaceForCommandsNVX_ptr: CmdReserveSpaceForCommandsNVX_panic,
      CreateIndirectCommandsLayoutNVX_ptr: CreateIndirectCommandsLayoutNVX_panic,
      DestroyIndirectCommandsLayoutNVX_ptr: DestroyIndirectCommandsLayoutNVX_panic,
      CreateObjectTableNVX_ptr: CreateObjectTableNVX_panic,
      DestroyObjectTableNVX_ptr: DestroyObjectTableNVX_panic,
      RegisterObjectsNVX_ptr: RegisterObjectsNVX_panic,
      UnregisterObjectsNVX_ptr: UnregisterObjectsNVX_panic,
      GetPhysicalDeviceGeneratedCommandsPropertiesNVX_ptr: GetPhysicalDeviceGeneratedCommandsPropertiesNVX_panic,
      CmdSetViewportWScalingNV_ptr: CmdSetViewportWScalingNV_panic,
      DisplayPowerControlEXT_ptr: DisplayPowerControlEXT_panic,
      RegisterDeviceEventEXT_ptr: RegisterDeviceEventEXT_panic,
      RegisterDisplayEventEXT_ptr: RegisterDisplayEventEXT_panic,
      GetSwapchainCounterEXT_ptr: GetSwapchainCounterEXT_panic,
      GetRefreshCycleDurationGOOGLE_ptr: GetRefreshCycleDurationGOOGLE_panic,
      GetPastPresentationTimingGOOGLE_ptr: GetPastPresentationTimingGOOGLE_panic,
      CmdSetDiscardRectangleEXT_ptr: CmdSetDiscardRectangleEXT_panic,
      SetHdrMetadataEXT_ptr: SetHdrMetadataEXT_panic,
      CreateRenderPass2KHR_ptr: CreateRenderPass2KHR_panic,
      CmdBeginRenderPass2KHR_ptr: CmdBeginRenderPass2KHR_panic,
      CmdNextSubpass2KHR_ptr: CmdNextSubpass2KHR_panic,
      CmdEndRenderPass2KHR_ptr: CmdEndRenderPass2KHR_panic,
      GetSwapchainStatusKHR_ptr: GetSwapchainStatusKHR_panic,
      ImportFenceWin32HandleKHR_ptr: ImportFenceWin32HandleKHR_panic,
      GetFenceWin32HandleKHR_ptr: GetFenceWin32HandleKHR_panic,
      ImportFenceFdKHR_ptr: ImportFenceFdKHR_panic,
      GetFenceFdKHR_ptr: GetFenceFdKHR_panic,
      GetAndroidHardwareBufferPropertiesANDROID_ptr: GetAndroidHardwareBufferPropertiesANDROID_panic,
      GetMemoryAndroidHardwareBufferANDROID_ptr: GetMemoryAndroidHardwareBufferANDROID_panic,
      CmdSetSampleLocationsEXT_ptr: CmdSetSampleLocationsEXT_panic,
      GetPhysicalDeviceMultisamplePropertiesEXT_ptr: GetPhysicalDeviceMultisamplePropertiesEXT_panic,
      GetImageDrmFormatModifierPropertiesEXT_ptr: GetImageDrmFormatModifierPropertiesEXT_panic,
      CreateValidationCacheEXT_ptr: CreateValidationCacheEXT_panic,
      DestroyValidationCacheEXT_ptr: DestroyValidationCacheEXT_panic,
      MergeValidationCachesEXT_ptr: MergeValidationCachesEXT_panic,
      GetValidationCacheDataEXT_ptr: GetValidationCacheDataEXT_panic,
      CmdBindShadingRateImageNV_ptr: CmdBindShadingRateImageNV_panic,
      CmdSetViewportShadingRatePaletteNV_ptr: CmdSetViewportShadingRatePaletteNV_panic,
      CmdSetCoarseSampleOrderNV_ptr: CmdSetCoarseSampleOrderNV_panic,
      CreateAccelerationStructureNV_ptr: CreateAccelerationStructureNV_panic,
      DestroyAccelerationStructureNV_ptr: DestroyAccelerationStructureNV_panic,
      GetAccelerationStructureMemoryRequirementsNV_ptr: GetAccelerationStructureMemoryRequirementsNV_panic,
      BindAccelerationStructureMemoryNV_ptr: BindAccelerationStructureMemoryNV_panic,
      CmdBuildAccelerationStructureNV_ptr: CmdBuildAccelerationStructureNV_panic,
      CmdCopyAccelerationStructureNV_ptr: CmdCopyAccelerationStructureNV_panic,
      CmdTraceRaysNV_ptr: CmdTraceRaysNV_panic,
      CreateRayTracingPipelinesNV_ptr: CreateRayTracingPipelinesNV_panic,
      GetRayTracingShaderGroupHandlesNV_ptr: GetRayTracingShaderGroupHandlesNV_panic,
      GetAccelerationStructureHandleNV_ptr: GetAccelerationStructureHandleNV_panic,
      CmdWriteAccelerationStructuresPropertiesNV_ptr: CmdWriteAccelerationStructuresPropertiesNV_panic,
      CompileDeferredNV_ptr: CompileDeferredNV_panic,
      CmdDrawIndirectCountKHR_ptr: CmdDrawIndirectCountKHR_panic,
      CmdDrawIndexedIndirectCountKHR_ptr: CmdDrawIndexedIndirectCountKHR_panic,
      GetMemoryHostPointerPropertiesEXT_ptr: GetMemoryHostPointerPropertiesEXT_panic,
      CmdWriteBufferMarkerAMD_ptr: CmdWriteBufferMarkerAMD_panic,
      GetPhysicalDeviceCalibrateableTimeDomainsEXT_ptr: GetPhysicalDeviceCalibrateableTimeDomainsEXT_panic,
      GetCalibratedTimestampsEXT_ptr: GetCalibratedTimestampsEXT_panic,
      CmdDrawMeshTasksNV_ptr: CmdDrawMeshTasksNV_panic,
      CmdDrawMeshTasksIndirectNV_ptr: CmdDrawMeshTasksIndirectNV_panic,
      CmdDrawMeshTasksIndirectCountNV_ptr: CmdDrawMeshTasksIndirectCountNV_panic,
      CmdSetExclusiveScissorNV_ptr: CmdSetExclusiveScissorNV_panic,
      CmdSetCheckpointNV_ptr: CmdSetCheckpointNV_panic,
      GetQueueCheckpointDataNV_ptr: GetQueueCheckpointDataNV_panic,
    }
  }
}


impl DeviceExtensions {
  /// Initialized device extensions
  /// 
  /// A valid instance of [Core](struct.Core.html) is needen to successfully initialize extensions.
  /// The vulkan feature level is picked up through the current Core instance.
  pub fn new(hdevice: Device) -> DeviceExtensions {
    let mut name;
    let mut ptr;

    unsafe { 
      let feature = (*core.expect("Vulkan core not initialized, make sure to have a valid instance of nobs_vk::Core")).feature;
        name = std::ffi::CString::new("vkCreateSwapchainKHR").unwrap();
        let CreateSwapchainKHR_ptr = if feature < VERSION_1_0 {
          CreateSwapchainKHR_panic as extern "system" fn (device: Device, pCreateInfo: *const SwapchainCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSwapchain: *mut SwapchainKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateSwapchainKHR_panic as extern "system" fn (device: Device, pCreateInfo: *const SwapchainCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSwapchain: *mut SwapchainKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDestroySwapchainKHR").unwrap();
        let DestroySwapchainKHR_ptr = if feature < VERSION_1_0 {
          DestroySwapchainKHR_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, pAllocator: *const AllocationCallbacks)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DestroySwapchainKHR_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, pAllocator: *const AllocationCallbacks)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetSwapchainImagesKHR").unwrap();
        let GetSwapchainImagesKHR_ptr = if feature < VERSION_1_0 {
          GetSwapchainImagesKHR_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, pSwapchainImageCount: *mut u32, pSwapchainImages: *mut Image) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetSwapchainImagesKHR_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, pSwapchainImageCount: *mut u32, pSwapchainImages: *mut Image) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkAcquireNextImageKHR").unwrap();
        let AcquireNextImageKHR_ptr = if feature < VERSION_1_0 {
          AcquireNextImageKHR_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, timeout: u64, semaphore: Semaphore, fence: Fence, pImageIndex: *mut u32) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            AcquireNextImageKHR_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, timeout: u64, semaphore: Semaphore, fence: Fence, pImageIndex: *mut u32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkQueuePresentKHR").unwrap();
        let QueuePresentKHR_ptr = if feature < VERSION_1_0 {
          QueuePresentKHR_panic as extern "system" fn (queue: Queue, pPresentInfo: *const PresentInfoKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            QueuePresentKHR_panic as extern "system" fn (queue: Queue, pPresentInfo: *const PresentInfoKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetDeviceGroupPresentCapabilitiesKHR").unwrap();
        let GetDeviceGroupPresentCapabilitiesKHR_ptr = if feature < VERSION_1_0 {
          GetDeviceGroupPresentCapabilitiesKHR_panic as extern "system" fn (device: Device, pDeviceGroupPresentCapabilities: *mut DeviceGroupPresentCapabilitiesKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetDeviceGroupPresentCapabilitiesKHR_panic as extern "system" fn (device: Device, pDeviceGroupPresentCapabilities: *mut DeviceGroupPresentCapabilitiesKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetDeviceGroupSurfacePresentModesKHR").unwrap();
        let GetDeviceGroupSurfacePresentModesKHR_ptr = if feature < VERSION_1_0 {
          GetDeviceGroupSurfacePresentModesKHR_panic as extern "system" fn (device: Device, surface: SurfaceKHR, pModes: *mut DeviceGroupPresentModeFlagsKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetDeviceGroupSurfacePresentModesKHR_panic as extern "system" fn (device: Device, surface: SurfaceKHR, pModes: *mut DeviceGroupPresentModeFlagsKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDevicePresentRectanglesKHR").unwrap();
        let GetPhysicalDevicePresentRectanglesKHR_ptr = if feature < VERSION_1_0 {
          GetPhysicalDevicePresentRectanglesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pRectCount: *mut u32, pRects: *mut Rect2D) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDevicePresentRectanglesKHR_panic as extern "system" fn (physicalDevice: PhysicalDevice, surface: SurfaceKHR, pRectCount: *mut u32, pRects: *mut Rect2D) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkAcquireNextImage2KHR").unwrap();
        let AcquireNextImage2KHR_ptr = if feature < VERSION_1_0 {
          AcquireNextImage2KHR_panic as extern "system" fn (device: Device, pAcquireInfo: *const AcquireNextImageInfoKHR, pImageIndex: *mut u32) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            AcquireNextImage2KHR_panic as extern "system" fn (device: Device, pAcquireInfo: *const AcquireNextImageInfoKHR, pImageIndex: *mut u32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateSharedSwapchainsKHR").unwrap();
        let CreateSharedSwapchainsKHR_ptr = if feature < VERSION_1_0 {
          CreateSharedSwapchainsKHR_panic as extern "system" fn (device: Device, swapchainCount: u32, pCreateInfos: *const SwapchainCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSwapchains: *mut SwapchainKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateSharedSwapchainsKHR_panic as extern "system" fn (device: Device, swapchainCount: u32, pCreateInfos: *const SwapchainCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSwapchains: *mut SwapchainKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDebugMarkerSetObjectTagEXT").unwrap();
        let DebugMarkerSetObjectTagEXT_ptr = if feature < VERSION_1_0 {
          DebugMarkerSetObjectTagEXT_panic as extern "system" fn (device: Device, pTagInfo: *const DebugMarkerObjectTagInfoEXT) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DebugMarkerSetObjectTagEXT_panic as extern "system" fn (device: Device, pTagInfo: *const DebugMarkerObjectTagInfoEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDebugMarkerSetObjectNameEXT").unwrap();
        let DebugMarkerSetObjectNameEXT_ptr = if feature < VERSION_1_0 {
          DebugMarkerSetObjectNameEXT_panic as extern "system" fn (device: Device, pNameInfo: *const DebugMarkerObjectNameInfoEXT) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DebugMarkerSetObjectNameEXT_panic as extern "system" fn (device: Device, pNameInfo: *const DebugMarkerObjectNameInfoEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDebugMarkerBeginEXT").unwrap();
        let CmdDebugMarkerBeginEXT_ptr = if feature < VERSION_1_0 {
          CmdDebugMarkerBeginEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pMarkerInfo: *const DebugMarkerMarkerInfoEXT)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDebugMarkerBeginEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pMarkerInfo: *const DebugMarkerMarkerInfoEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDebugMarkerEndEXT").unwrap();
        let CmdDebugMarkerEndEXT_ptr = if feature < VERSION_1_0 {
          CmdDebugMarkerEndEXT_panic as extern "system" fn (commandBuffer: CommandBuffer)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDebugMarkerEndEXT_panic as extern "system" fn (commandBuffer: CommandBuffer)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDebugMarkerInsertEXT").unwrap();
        let CmdDebugMarkerInsertEXT_ptr = if feature < VERSION_1_0 {
          CmdDebugMarkerInsertEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pMarkerInfo: *const DebugMarkerMarkerInfoEXT)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDebugMarkerInsertEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pMarkerInfo: *const DebugMarkerMarkerInfoEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdBindTransformFeedbackBuffersEXT").unwrap();
        let CmdBindTransformFeedbackBuffersEXT_ptr = if feature < VERSION_1_0 {
          CmdBindTransformFeedbackBuffersEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const Buffer, pOffsets: *const DeviceSize, pSizes: *const DeviceSize)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdBindTransformFeedbackBuffersEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const Buffer, pOffsets: *const DeviceSize, pSizes: *const DeviceSize)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdBeginTransformFeedbackEXT").unwrap();
        let CmdBeginTransformFeedbackEXT_ptr = if feature < VERSION_1_0 {
          CmdBeginTransformFeedbackEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const Buffer, pCounterBufferOffsets: *const DeviceSize)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdBeginTransformFeedbackEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const Buffer, pCounterBufferOffsets: *const DeviceSize)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdEndTransformFeedbackEXT").unwrap();
        let CmdEndTransformFeedbackEXT_ptr = if feature < VERSION_1_0 {
          CmdEndTransformFeedbackEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const Buffer, pCounterBufferOffsets: *const DeviceSize)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdEndTransformFeedbackEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const Buffer, pCounterBufferOffsets: *const DeviceSize)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdBeginQueryIndexedEXT").unwrap();
        let CmdBeginQueryIndexedEXT_ptr = if feature < VERSION_1_0 {
          CmdBeginQueryIndexedEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags, index: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdBeginQueryIndexedEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags, index: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdEndQueryIndexedEXT").unwrap();
        let CmdEndQueryIndexedEXT_ptr = if feature < VERSION_1_0 {
          CmdEndQueryIndexedEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, index: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdEndQueryIndexedEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, index: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDrawIndirectByteCountEXT").unwrap();
        let CmdDrawIndirectByteCountEXT_ptr = if feature < VERSION_1_0 {
          CmdDrawIndirectByteCountEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: Buffer, counterBufferOffset: DeviceSize, counterOffset: u32, vertexStride: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDrawIndirectByteCountEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: Buffer, counterBufferOffset: DeviceSize, counterOffset: u32, vertexStride: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDrawIndirectCountAMD").unwrap();
        let CmdDrawIndirectCountAMD_ptr = if feature < VERSION_1_0 {
          CmdDrawIndirectCountAMD_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDrawIndirectCountAMD_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDrawIndexedIndirectCountAMD").unwrap();
        let CmdDrawIndexedIndirectCountAMD_ptr = if feature < VERSION_1_0 {
          CmdDrawIndexedIndirectCountAMD_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDrawIndexedIndirectCountAMD_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetShaderInfoAMD").unwrap();
        let GetShaderInfoAMD_ptr = if feature < VERSION_1_0 {
          GetShaderInfoAMD_panic as extern "system" fn (device: Device, pipeline: Pipeline, shaderStage: ShaderStageFlagBits, infoType: ShaderInfoTypeAMD, pInfoSize: *mut usize, pInfo: *mut c_void) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetShaderInfoAMD_panic as extern "system" fn (device: Device, pipeline: Pipeline, shaderStage: ShaderStageFlagBits, infoType: ShaderInfoTypeAMD, pInfoSize: *mut usize, pInfo: *mut c_void) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetMemoryWin32HandleNV").unwrap();
        let GetMemoryWin32HandleNV_ptr = if feature < VERSION_1_0 {
          GetMemoryWin32HandleNV_panic as extern "system" fn (device: Device, memory: DeviceMemory, handleType: ExternalMemoryHandleTypeFlagsNV, pHandle: *mut HANDLE) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetMemoryWin32HandleNV_panic as extern "system" fn (device: Device, memory: DeviceMemory, handleType: ExternalMemoryHandleTypeFlagsNV, pHandle: *mut HANDLE) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetMemoryWin32HandleKHR").unwrap();
        let GetMemoryWin32HandleKHR_ptr = if feature < VERSION_1_0 {
          GetMemoryWin32HandleKHR_panic as extern "system" fn (device: Device, pGetWin32HandleInfo: *const MemoryGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetMemoryWin32HandleKHR_panic as extern "system" fn (device: Device, pGetWin32HandleInfo: *const MemoryGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetMemoryWin32HandlePropertiesKHR").unwrap();
        let GetMemoryWin32HandlePropertiesKHR_ptr = if feature < VERSION_1_0 {
          GetMemoryWin32HandlePropertiesKHR_panic as extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, handle: HANDLE, pMemoryWin32HandleProperties: *mut MemoryWin32HandlePropertiesKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetMemoryWin32HandlePropertiesKHR_panic as extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, handle: HANDLE, pMemoryWin32HandleProperties: *mut MemoryWin32HandlePropertiesKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetMemoryFdKHR").unwrap();
        let GetMemoryFdKHR_ptr = if feature < VERSION_1_0 {
          GetMemoryFdKHR_panic as extern "system" fn (device: Device, pGetFdInfo: *const MemoryGetFdInfoKHR, pFd: *mut i32) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetMemoryFdKHR_panic as extern "system" fn (device: Device, pGetFdInfo: *const MemoryGetFdInfoKHR, pFd: *mut i32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetMemoryFdPropertiesKHR").unwrap();
        let GetMemoryFdPropertiesKHR_ptr = if feature < VERSION_1_0 {
          GetMemoryFdPropertiesKHR_panic as extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, fd: i32, pMemoryFdProperties: *mut MemoryFdPropertiesKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetMemoryFdPropertiesKHR_panic as extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, fd: i32, pMemoryFdProperties: *mut MemoryFdPropertiesKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkImportSemaphoreWin32HandleKHR").unwrap();
        let ImportSemaphoreWin32HandleKHR_ptr = if feature < VERSION_1_0 {
          ImportSemaphoreWin32HandleKHR_panic as extern "system" fn (device: Device, pImportSemaphoreWin32HandleInfo: *const ImportSemaphoreWin32HandleInfoKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            ImportSemaphoreWin32HandleKHR_panic as extern "system" fn (device: Device, pImportSemaphoreWin32HandleInfo: *const ImportSemaphoreWin32HandleInfoKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetSemaphoreWin32HandleKHR").unwrap();
        let GetSemaphoreWin32HandleKHR_ptr = if feature < VERSION_1_0 {
          GetSemaphoreWin32HandleKHR_panic as extern "system" fn (device: Device, pGetWin32HandleInfo: *const SemaphoreGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetSemaphoreWin32HandleKHR_panic as extern "system" fn (device: Device, pGetWin32HandleInfo: *const SemaphoreGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkImportSemaphoreFdKHR").unwrap();
        let ImportSemaphoreFdKHR_ptr = if feature < VERSION_1_0 {
          ImportSemaphoreFdKHR_panic as extern "system" fn (device: Device, pImportSemaphoreFdInfo: *const ImportSemaphoreFdInfoKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            ImportSemaphoreFdKHR_panic as extern "system" fn (device: Device, pImportSemaphoreFdInfo: *const ImportSemaphoreFdInfoKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetSemaphoreFdKHR").unwrap();
        let GetSemaphoreFdKHR_ptr = if feature < VERSION_1_0 {
          GetSemaphoreFdKHR_panic as extern "system" fn (device: Device, pGetFdInfo: *const SemaphoreGetFdInfoKHR, pFd: *mut i32) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetSemaphoreFdKHR_panic as extern "system" fn (device: Device, pGetFdInfo: *const SemaphoreGetFdInfoKHR, pFd: *mut i32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdPushDescriptorSetKHR").unwrap();
        let CmdPushDescriptorSetKHR_ptr = if feature < VERSION_1_0 {
          CmdPushDescriptorSetKHR_panic as extern "system" fn (commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const WriteDescriptorSet)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdPushDescriptorSetKHR_panic as extern "system" fn (commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const WriteDescriptorSet)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdPushDescriptorSetWithTemplateKHR").unwrap();
        let CmdPushDescriptorSetWithTemplateKHR_ptr = if feature < VERSION_1_0 {
          CmdPushDescriptorSetWithTemplateKHR_panic as extern "system" fn (commandBuffer: CommandBuffer, descriptorUpdateTemplate: DescriptorUpdateTemplate, layout: PipelineLayout, set: u32, pData: *const c_void)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdPushDescriptorSetWithTemplateKHR_panic as extern "system" fn (commandBuffer: CommandBuffer, descriptorUpdateTemplate: DescriptorUpdateTemplate, layout: PipelineLayout, set: u32, pData: *const c_void)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdBeginConditionalRenderingEXT").unwrap();
        let CmdBeginConditionalRenderingEXT_ptr = if feature < VERSION_1_0 {
          CmdBeginConditionalRenderingEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pConditionalRenderingBegin: *const ConditionalRenderingBeginInfoEXT)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdBeginConditionalRenderingEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pConditionalRenderingBegin: *const ConditionalRenderingBeginInfoEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdEndConditionalRenderingEXT").unwrap();
        let CmdEndConditionalRenderingEXT_ptr = if feature < VERSION_1_0 {
          CmdEndConditionalRenderingEXT_panic as extern "system" fn (commandBuffer: CommandBuffer)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdEndConditionalRenderingEXT_panic as extern "system" fn (commandBuffer: CommandBuffer)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdProcessCommandsNVX").unwrap();
        let CmdProcessCommandsNVX_ptr = if feature < VERSION_1_0 {
          CmdProcessCommandsNVX_panic as extern "system" fn (commandBuffer: CommandBuffer, pProcessCommandsInfo: *const CmdProcessCommandsInfoNVX)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdProcessCommandsNVX_panic as extern "system" fn (commandBuffer: CommandBuffer, pProcessCommandsInfo: *const CmdProcessCommandsInfoNVX)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdReserveSpaceForCommandsNVX").unwrap();
        let CmdReserveSpaceForCommandsNVX_ptr = if feature < VERSION_1_0 {
          CmdReserveSpaceForCommandsNVX_panic as extern "system" fn (commandBuffer: CommandBuffer, pReserveSpaceInfo: *const CmdReserveSpaceForCommandsInfoNVX)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdReserveSpaceForCommandsNVX_panic as extern "system" fn (commandBuffer: CommandBuffer, pReserveSpaceInfo: *const CmdReserveSpaceForCommandsInfoNVX)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateIndirectCommandsLayoutNVX").unwrap();
        let CreateIndirectCommandsLayoutNVX_ptr = if feature < VERSION_1_0 {
          CreateIndirectCommandsLayoutNVX_panic as extern "system" fn (device: Device, pCreateInfo: *const IndirectCommandsLayoutCreateInfoNVX, pAllocator: *const AllocationCallbacks, pIndirectCommandsLayout: *mut IndirectCommandsLayoutNVX) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateIndirectCommandsLayoutNVX_panic as extern "system" fn (device: Device, pCreateInfo: *const IndirectCommandsLayoutCreateInfoNVX, pAllocator: *const AllocationCallbacks, pIndirectCommandsLayout: *mut IndirectCommandsLayoutNVX) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDestroyIndirectCommandsLayoutNVX").unwrap();
        let DestroyIndirectCommandsLayoutNVX_ptr = if feature < VERSION_1_0 {
          DestroyIndirectCommandsLayoutNVX_panic as extern "system" fn (device: Device, indirectCommandsLayout: IndirectCommandsLayoutNVX, pAllocator: *const AllocationCallbacks)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DestroyIndirectCommandsLayoutNVX_panic as extern "system" fn (device: Device, indirectCommandsLayout: IndirectCommandsLayoutNVX, pAllocator: *const AllocationCallbacks)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateObjectTableNVX").unwrap();
        let CreateObjectTableNVX_ptr = if feature < VERSION_1_0 {
          CreateObjectTableNVX_panic as extern "system" fn (device: Device, pCreateInfo: *const ObjectTableCreateInfoNVX, pAllocator: *const AllocationCallbacks, pObjectTable: *mut ObjectTableNVX) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateObjectTableNVX_panic as extern "system" fn (device: Device, pCreateInfo: *const ObjectTableCreateInfoNVX, pAllocator: *const AllocationCallbacks, pObjectTable: *mut ObjectTableNVX) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDestroyObjectTableNVX").unwrap();
        let DestroyObjectTableNVX_ptr = if feature < VERSION_1_0 {
          DestroyObjectTableNVX_panic as extern "system" fn (device: Device, objectTable: ObjectTableNVX, pAllocator: *const AllocationCallbacks)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DestroyObjectTableNVX_panic as extern "system" fn (device: Device, objectTable: ObjectTableNVX, pAllocator: *const AllocationCallbacks)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkRegisterObjectsNVX").unwrap();
        let RegisterObjectsNVX_ptr = if feature < VERSION_1_0 {
          RegisterObjectsNVX_panic as extern "system" fn (device: Device, objectTable: ObjectTableNVX, objectCount: u32, ppObjectTableEntries: *const *const ObjectTableEntryNVX, pObjectIndices: *const u32) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            RegisterObjectsNVX_panic as extern "system" fn (device: Device, objectTable: ObjectTableNVX, objectCount: u32, ppObjectTableEntries: *const *const ObjectTableEntryNVX, pObjectIndices: *const u32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkUnregisterObjectsNVX").unwrap();
        let UnregisterObjectsNVX_ptr = if feature < VERSION_1_0 {
          UnregisterObjectsNVX_panic as extern "system" fn (device: Device, objectTable: ObjectTableNVX, objectCount: u32, pObjectEntryTypes: *const ObjectEntryTypeNVX, pObjectIndices: *const u32) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            UnregisterObjectsNVX_panic as extern "system" fn (device: Device, objectTable: ObjectTableNVX, objectCount: u32, pObjectEntryTypes: *const ObjectEntryTypeNVX, pObjectIndices: *const u32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX").unwrap();
        let GetPhysicalDeviceGeneratedCommandsPropertiesNVX_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceGeneratedCommandsPropertiesNVX_panic as extern "system" fn (physicalDevice: PhysicalDevice, pFeatures: *mut DeviceGeneratedCommandsFeaturesNVX, pLimits: *mut DeviceGeneratedCommandsLimitsNVX)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceGeneratedCommandsPropertiesNVX_panic as extern "system" fn (physicalDevice: PhysicalDevice, pFeatures: *mut DeviceGeneratedCommandsFeaturesNVX, pLimits: *mut DeviceGeneratedCommandsLimitsNVX)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdSetViewportWScalingNV").unwrap();
        let CmdSetViewportWScalingNV_ptr = if feature < VERSION_1_0 {
          CmdSetViewportWScalingNV_panic as extern "system" fn (commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const ViewportWScalingNV)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdSetViewportWScalingNV_panic as extern "system" fn (commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const ViewportWScalingNV)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDisplayPowerControlEXT").unwrap();
        let DisplayPowerControlEXT_ptr = if feature < VERSION_1_0 {
          DisplayPowerControlEXT_panic as extern "system" fn (device: Device, display: DisplayKHR, pDisplayPowerInfo: *const DisplayPowerInfoEXT) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DisplayPowerControlEXT_panic as extern "system" fn (device: Device, display: DisplayKHR, pDisplayPowerInfo: *const DisplayPowerInfoEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkRegisterDeviceEventEXT").unwrap();
        let RegisterDeviceEventEXT_ptr = if feature < VERSION_1_0 {
          RegisterDeviceEventEXT_panic as extern "system" fn (device: Device, pDeviceEventInfo: *const DeviceEventInfoEXT, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            RegisterDeviceEventEXT_panic as extern "system" fn (device: Device, pDeviceEventInfo: *const DeviceEventInfoEXT, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkRegisterDisplayEventEXT").unwrap();
        let RegisterDisplayEventEXT_ptr = if feature < VERSION_1_0 {
          RegisterDisplayEventEXT_panic as extern "system" fn (device: Device, display: DisplayKHR, pDisplayEventInfo: *const DisplayEventInfoEXT, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            RegisterDisplayEventEXT_panic as extern "system" fn (device: Device, display: DisplayKHR, pDisplayEventInfo: *const DisplayEventInfoEXT, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetSwapchainCounterEXT").unwrap();
        let GetSwapchainCounterEXT_ptr = if feature < VERSION_1_0 {
          GetSwapchainCounterEXT_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, counter: SurfaceCounterFlagBitsEXT, pCounterValue: *mut u64) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetSwapchainCounterEXT_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, counter: SurfaceCounterFlagBitsEXT, pCounterValue: *mut u64) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetRefreshCycleDurationGOOGLE").unwrap();
        let GetRefreshCycleDurationGOOGLE_ptr = if feature < VERSION_1_0 {
          GetRefreshCycleDurationGOOGLE_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, pDisplayTimingProperties: *mut RefreshCycleDurationGOOGLE) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetRefreshCycleDurationGOOGLE_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, pDisplayTimingProperties: *mut RefreshCycleDurationGOOGLE) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPastPresentationTimingGOOGLE").unwrap();
        let GetPastPresentationTimingGOOGLE_ptr = if feature < VERSION_1_0 {
          GetPastPresentationTimingGOOGLE_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, pPresentationTimingCount: *mut u32, pPresentationTimings: *mut PastPresentationTimingGOOGLE) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPastPresentationTimingGOOGLE_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR, pPresentationTimingCount: *mut u32, pPresentationTimings: *mut PastPresentationTimingGOOGLE) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdSetDiscardRectangleEXT").unwrap();
        let CmdSetDiscardRectangleEXT_ptr = if feature < VERSION_1_0 {
          CmdSetDiscardRectangleEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const Rect2D)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdSetDiscardRectangleEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const Rect2D)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkSetHdrMetadataEXT").unwrap();
        let SetHdrMetadataEXT_ptr = if feature < VERSION_1_0 {
          SetHdrMetadataEXT_panic as extern "system" fn (device: Device, swapchainCount: u32, pSwapchains: *const SwapchainKHR, pMetadata: *const HdrMetadataEXT)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            SetHdrMetadataEXT_panic as extern "system" fn (device: Device, swapchainCount: u32, pSwapchains: *const SwapchainKHR, pMetadata: *const HdrMetadataEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateRenderPass2KHR").unwrap();
        let CreateRenderPass2KHR_ptr = if feature < VERSION_1_0 {
          CreateRenderPass2KHR_panic as extern "system" fn (device: Device, pCreateInfo: *const RenderPassCreateInfo2KHR, pAllocator: *const AllocationCallbacks, pRenderPass: *mut RenderPass) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateRenderPass2KHR_panic as extern "system" fn (device: Device, pCreateInfo: *const RenderPassCreateInfo2KHR, pAllocator: *const AllocationCallbacks, pRenderPass: *mut RenderPass) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdBeginRenderPass2KHR").unwrap();
        let CmdBeginRenderPass2KHR_ptr = if feature < VERSION_1_0 {
          CmdBeginRenderPass2KHR_panic as extern "system" fn (commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, pSubpassBeginInfo: *const SubpassBeginInfoKHR)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdBeginRenderPass2KHR_panic as extern "system" fn (commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, pSubpassBeginInfo: *const SubpassBeginInfoKHR)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdNextSubpass2KHR").unwrap();
        let CmdNextSubpass2KHR_ptr = if feature < VERSION_1_0 {
          CmdNextSubpass2KHR_panic as extern "system" fn (commandBuffer: CommandBuffer, pSubpassBeginInfo: *const SubpassBeginInfoKHR, pSubpassEndInfo: *const SubpassEndInfoKHR)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdNextSubpass2KHR_panic as extern "system" fn (commandBuffer: CommandBuffer, pSubpassBeginInfo: *const SubpassBeginInfoKHR, pSubpassEndInfo: *const SubpassEndInfoKHR)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdEndRenderPass2KHR").unwrap();
        let CmdEndRenderPass2KHR_ptr = if feature < VERSION_1_0 {
          CmdEndRenderPass2KHR_panic as extern "system" fn (commandBuffer: CommandBuffer, pSubpassEndInfo: *const SubpassEndInfoKHR)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdEndRenderPass2KHR_panic as extern "system" fn (commandBuffer: CommandBuffer, pSubpassEndInfo: *const SubpassEndInfoKHR)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetSwapchainStatusKHR").unwrap();
        let GetSwapchainStatusKHR_ptr = if feature < VERSION_1_0 {
          GetSwapchainStatusKHR_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetSwapchainStatusKHR_panic as extern "system" fn (device: Device, swapchain: SwapchainKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkImportFenceWin32HandleKHR").unwrap();
        let ImportFenceWin32HandleKHR_ptr = if feature < VERSION_1_0 {
          ImportFenceWin32HandleKHR_panic as extern "system" fn (device: Device, pImportFenceWin32HandleInfo: *const ImportFenceWin32HandleInfoKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            ImportFenceWin32HandleKHR_panic as extern "system" fn (device: Device, pImportFenceWin32HandleInfo: *const ImportFenceWin32HandleInfoKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetFenceWin32HandleKHR").unwrap();
        let GetFenceWin32HandleKHR_ptr = if feature < VERSION_1_0 {
          GetFenceWin32HandleKHR_panic as extern "system" fn (device: Device, pGetWin32HandleInfo: *const FenceGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetFenceWin32HandleKHR_panic as extern "system" fn (device: Device, pGetWin32HandleInfo: *const FenceGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkImportFenceFdKHR").unwrap();
        let ImportFenceFdKHR_ptr = if feature < VERSION_1_0 {
          ImportFenceFdKHR_panic as extern "system" fn (device: Device, pImportFenceFdInfo: *const ImportFenceFdInfoKHR) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            ImportFenceFdKHR_panic as extern "system" fn (device: Device, pImportFenceFdInfo: *const ImportFenceFdInfoKHR) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetFenceFdKHR").unwrap();
        let GetFenceFdKHR_ptr = if feature < VERSION_1_0 {
          GetFenceFdKHR_panic as extern "system" fn (device: Device, pGetFdInfo: *const FenceGetFdInfoKHR, pFd: *mut i32) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetFenceFdKHR_panic as extern "system" fn (device: Device, pGetFdInfo: *const FenceGetFdInfoKHR, pFd: *mut i32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetAndroidHardwareBufferPropertiesANDROID").unwrap();
        let GetAndroidHardwareBufferPropertiesANDROID_ptr = if feature < VERSION_1_0 {
          GetAndroidHardwareBufferPropertiesANDROID_panic as extern "system" fn (device: Device, buffer: *const AHardwareBuffer, pProperties: *mut AndroidHardwareBufferPropertiesANDROID) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetAndroidHardwareBufferPropertiesANDROID_panic as extern "system" fn (device: Device, buffer: *const AHardwareBuffer, pProperties: *mut AndroidHardwareBufferPropertiesANDROID) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetMemoryAndroidHardwareBufferANDROID").unwrap();
        let GetMemoryAndroidHardwareBufferANDROID_ptr = if feature < VERSION_1_0 {
          GetMemoryAndroidHardwareBufferANDROID_panic as extern "system" fn (device: Device, pInfo: *const MemoryGetAndroidHardwareBufferInfoANDROID, pBuffer: *mut *mut AHardwareBuffer) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetMemoryAndroidHardwareBufferANDROID_panic as extern "system" fn (device: Device, pInfo: *const MemoryGetAndroidHardwareBufferInfoANDROID, pBuffer: *mut *mut AHardwareBuffer) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdSetSampleLocationsEXT").unwrap();
        let CmdSetSampleLocationsEXT_ptr = if feature < VERSION_1_0 {
          CmdSetSampleLocationsEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pSampleLocationsInfo: *const SampleLocationsInfoEXT)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdSetSampleLocationsEXT_panic as extern "system" fn (commandBuffer: CommandBuffer, pSampleLocationsInfo: *const SampleLocationsInfoEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceMultisamplePropertiesEXT").unwrap();
        let GetPhysicalDeviceMultisamplePropertiesEXT_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceMultisamplePropertiesEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, samples: SampleCountFlagBits, pMultisampleProperties: *mut MultisamplePropertiesEXT)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceMultisamplePropertiesEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, samples: SampleCountFlagBits, pMultisampleProperties: *mut MultisamplePropertiesEXT)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetImageDrmFormatModifierPropertiesEXT").unwrap();
        let GetImageDrmFormatModifierPropertiesEXT_ptr = if feature < VERSION_1_0 {
          GetImageDrmFormatModifierPropertiesEXT_panic as extern "system" fn (device: Device, image: Image, pProperties: *mut ImageDrmFormatModifierPropertiesEXT) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetImageDrmFormatModifierPropertiesEXT_panic as extern "system" fn (device: Device, image: Image, pProperties: *mut ImageDrmFormatModifierPropertiesEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateValidationCacheEXT").unwrap();
        let CreateValidationCacheEXT_ptr = if feature < VERSION_1_0 {
          CreateValidationCacheEXT_panic as extern "system" fn (device: Device, pCreateInfo: *const ValidationCacheCreateInfoEXT, pAllocator: *const AllocationCallbacks, pValidationCache: *mut ValidationCacheEXT) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateValidationCacheEXT_panic as extern "system" fn (device: Device, pCreateInfo: *const ValidationCacheCreateInfoEXT, pAllocator: *const AllocationCallbacks, pValidationCache: *mut ValidationCacheEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDestroyValidationCacheEXT").unwrap();
        let DestroyValidationCacheEXT_ptr = if feature < VERSION_1_0 {
          DestroyValidationCacheEXT_panic as extern "system" fn (device: Device, validationCache: ValidationCacheEXT, pAllocator: *const AllocationCallbacks)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DestroyValidationCacheEXT_panic as extern "system" fn (device: Device, validationCache: ValidationCacheEXT, pAllocator: *const AllocationCallbacks)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkMergeValidationCachesEXT").unwrap();
        let MergeValidationCachesEXT_ptr = if feature < VERSION_1_0 {
          MergeValidationCachesEXT_panic as extern "system" fn (device: Device, dstCache: ValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *const ValidationCacheEXT) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            MergeValidationCachesEXT_panic as extern "system" fn (device: Device, dstCache: ValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *const ValidationCacheEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetValidationCacheDataEXT").unwrap();
        let GetValidationCacheDataEXT_ptr = if feature < VERSION_1_0 {
          GetValidationCacheDataEXT_panic as extern "system" fn (device: Device, validationCache: ValidationCacheEXT, pDataSize: *mut usize, pData: *mut c_void) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetValidationCacheDataEXT_panic as extern "system" fn (device: Device, validationCache: ValidationCacheEXT, pDataSize: *mut usize, pData: *mut c_void) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdBindShadingRateImageNV").unwrap();
        let CmdBindShadingRateImageNV_ptr = if feature < VERSION_1_0 {
          CmdBindShadingRateImageNV_panic as extern "system" fn (commandBuffer: CommandBuffer, imageView: ImageView, imageLayout: ImageLayout)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdBindShadingRateImageNV_panic as extern "system" fn (commandBuffer: CommandBuffer, imageView: ImageView, imageLayout: ImageLayout)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdSetViewportShadingRatePaletteNV").unwrap();
        let CmdSetViewportShadingRatePaletteNV_ptr = if feature < VERSION_1_0 {
          CmdSetViewportShadingRatePaletteNV_panic as extern "system" fn (commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *const ShadingRatePaletteNV)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdSetViewportShadingRatePaletteNV_panic as extern "system" fn (commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *const ShadingRatePaletteNV)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdSetCoarseSampleOrderNV").unwrap();
        let CmdSetCoarseSampleOrderNV_ptr = if feature < VERSION_1_0 {
          CmdSetCoarseSampleOrderNV_panic as extern "system" fn (commandBuffer: CommandBuffer, sampleOrderType: CoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *const CoarseSampleOrderCustomNV)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdSetCoarseSampleOrderNV_panic as extern "system" fn (commandBuffer: CommandBuffer, sampleOrderType: CoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *const CoarseSampleOrderCustomNV)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateAccelerationStructureNV").unwrap();
        let CreateAccelerationStructureNV_ptr = if feature < VERSION_1_0 {
          CreateAccelerationStructureNV_panic as extern "system" fn (device: Device, pCreateInfo: *const AccelerationStructureCreateInfoNV, pAllocator: *const AllocationCallbacks, pAccelerationStructure: *mut AccelerationStructureNV) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateAccelerationStructureNV_panic as extern "system" fn (device: Device, pCreateInfo: *const AccelerationStructureCreateInfoNV, pAllocator: *const AllocationCallbacks, pAccelerationStructure: *mut AccelerationStructureNV) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkDestroyAccelerationStructureNV").unwrap();
        let DestroyAccelerationStructureNV_ptr = if feature < VERSION_1_0 {
          DestroyAccelerationStructureNV_panic as extern "system" fn (device: Device, accelerationStructure: AccelerationStructureNV, pAllocator: *const AllocationCallbacks)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            DestroyAccelerationStructureNV_panic as extern "system" fn (device: Device, accelerationStructure: AccelerationStructureNV, pAllocator: *const AllocationCallbacks)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetAccelerationStructureMemoryRequirementsNV").unwrap();
        let GetAccelerationStructureMemoryRequirementsNV_ptr = if feature < VERSION_1_0 {
          GetAccelerationStructureMemoryRequirementsNV_panic as extern "system" fn (device: Device, pInfo: *const AccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *mut MemoryRequirements2)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetAccelerationStructureMemoryRequirementsNV_panic as extern "system" fn (device: Device, pInfo: *const AccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *mut MemoryRequirements2)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkBindAccelerationStructureMemoryNV").unwrap();
        let BindAccelerationStructureMemoryNV_ptr = if feature < VERSION_1_0 {
          BindAccelerationStructureMemoryNV_panic as extern "system" fn (device: Device, bindInfoCount: u32, pBindInfos: *const BindAccelerationStructureMemoryInfoNV) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            BindAccelerationStructureMemoryNV_panic as extern "system" fn (device: Device, bindInfoCount: u32, pBindInfos: *const BindAccelerationStructureMemoryInfoNV) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdBuildAccelerationStructureNV").unwrap();
        let CmdBuildAccelerationStructureNV_ptr = if feature < VERSION_1_0 {
          CmdBuildAccelerationStructureNV_panic as extern "system" fn (commandBuffer: CommandBuffer, pInfo: *const AccelerationStructureInfoNV, instanceData: Buffer, instanceOffset: DeviceSize, update: Bool32, dst: AccelerationStructureNV, src: AccelerationStructureNV, scratch: Buffer, scratchOffset: DeviceSize)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdBuildAccelerationStructureNV_panic as extern "system" fn (commandBuffer: CommandBuffer, pInfo: *const AccelerationStructureInfoNV, instanceData: Buffer, instanceOffset: DeviceSize, update: Bool32, dst: AccelerationStructureNV, src: AccelerationStructureNV, scratch: Buffer, scratchOffset: DeviceSize)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdCopyAccelerationStructureNV").unwrap();
        let CmdCopyAccelerationStructureNV_ptr = if feature < VERSION_1_0 {
          CmdCopyAccelerationStructureNV_panic as extern "system" fn (commandBuffer: CommandBuffer, dst: AccelerationStructureNV, src: AccelerationStructureNV, mode: CopyAccelerationStructureModeNV)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdCopyAccelerationStructureNV_panic as extern "system" fn (commandBuffer: CommandBuffer, dst: AccelerationStructureNV, src: AccelerationStructureNV, mode: CopyAccelerationStructureModeNV)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdTraceRaysNV").unwrap();
        let CmdTraceRaysNV_ptr = if feature < VERSION_1_0 {
          CmdTraceRaysNV_panic as extern "system" fn (commandBuffer: CommandBuffer, raygenShaderBindingTableBuffer: Buffer, raygenShaderBindingOffset: DeviceSize, missShaderBindingTableBuffer: Buffer, missShaderBindingOffset: DeviceSize, missShaderBindingStride: DeviceSize, hitShaderBindingTableBuffer: Buffer, hitShaderBindingOffset: DeviceSize, hitShaderBindingStride: DeviceSize, callableShaderBindingTableBuffer: Buffer, callableShaderBindingOffset: DeviceSize, callableShaderBindingStride: DeviceSize, width: u32, height: u32, depth: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdTraceRaysNV_panic as extern "system" fn (commandBuffer: CommandBuffer, raygenShaderBindingTableBuffer: Buffer, raygenShaderBindingOffset: DeviceSize, missShaderBindingTableBuffer: Buffer, missShaderBindingOffset: DeviceSize, missShaderBindingStride: DeviceSize, hitShaderBindingTableBuffer: Buffer, hitShaderBindingOffset: DeviceSize, hitShaderBindingStride: DeviceSize, callableShaderBindingTableBuffer: Buffer, callableShaderBindingOffset: DeviceSize, callableShaderBindingStride: DeviceSize, width: u32, height: u32, depth: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCreateRayTracingPipelinesNV").unwrap();
        let CreateRayTracingPipelinesNV_ptr = if feature < VERSION_1_0 {
          CreateRayTracingPipelinesNV_panic as extern "system" fn (device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const RayTracingPipelineCreateInfoNV, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CreateRayTracingPipelinesNV_panic as extern "system" fn (device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const RayTracingPipelineCreateInfoNV, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetRayTracingShaderGroupHandlesNV").unwrap();
        let GetRayTracingShaderGroupHandlesNV_ptr = if feature < VERSION_1_0 {
          GetRayTracingShaderGroupHandlesNV_panic as extern "system" fn (device: Device, pipeline: Pipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetRayTracingShaderGroupHandlesNV_panic as extern "system" fn (device: Device, pipeline: Pipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetAccelerationStructureHandleNV").unwrap();
        let GetAccelerationStructureHandleNV_ptr = if feature < VERSION_1_0 {
          GetAccelerationStructureHandleNV_panic as extern "system" fn (device: Device, accelerationStructure: AccelerationStructureNV, dataSize: usize, pData: *mut c_void) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetAccelerationStructureHandleNV_panic as extern "system" fn (device: Device, accelerationStructure: AccelerationStructureNV, dataSize: usize, pData: *mut c_void) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdWriteAccelerationStructuresPropertiesNV").unwrap();
        let CmdWriteAccelerationStructuresPropertiesNV_ptr = if feature < VERSION_1_0 {
          CmdWriteAccelerationStructuresPropertiesNV_panic as extern "system" fn (commandBuffer: CommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *const AccelerationStructureNV, queryType: QueryType, queryPool: QueryPool, firstQuery: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdWriteAccelerationStructuresPropertiesNV_panic as extern "system" fn (commandBuffer: CommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *const AccelerationStructureNV, queryType: QueryType, queryPool: QueryPool, firstQuery: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCompileDeferredNV").unwrap();
        let CompileDeferredNV_ptr = if feature < VERSION_1_0 {
          CompileDeferredNV_panic as extern "system" fn (device: Device, pipeline: Pipeline, shader: u32) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CompileDeferredNV_panic as extern "system" fn (device: Device, pipeline: Pipeline, shader: u32) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDrawIndirectCountKHR").unwrap();
        let CmdDrawIndirectCountKHR_ptr = if feature < VERSION_1_0 {
          CmdDrawIndirectCountKHR_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDrawIndirectCountKHR_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDrawIndexedIndirectCountKHR").unwrap();
        let CmdDrawIndexedIndirectCountKHR_ptr = if feature < VERSION_1_0 {
          CmdDrawIndexedIndirectCountKHR_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDrawIndexedIndirectCountKHR_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetMemoryHostPointerPropertiesEXT").unwrap();
        let GetMemoryHostPointerPropertiesEXT_ptr = if feature < VERSION_1_0 {
          GetMemoryHostPointerPropertiesEXT_panic as extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut MemoryHostPointerPropertiesEXT) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetMemoryHostPointerPropertiesEXT_panic as extern "system" fn (device: Device, handleType: ExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut MemoryHostPointerPropertiesEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdWriteBufferMarkerAMD").unwrap();
        let CmdWriteBufferMarkerAMD_ptr = if feature < VERSION_1_0 {
          CmdWriteBufferMarkerAMD_panic as extern "system" fn (commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlagBits, dstBuffer: Buffer, dstOffset: DeviceSize, marker: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdWriteBufferMarkerAMD_panic as extern "system" fn (commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlagBits, dstBuffer: Buffer, dstOffset: DeviceSize, marker: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT").unwrap();
        let GetPhysicalDeviceCalibrateableTimeDomainsEXT_ptr = if feature < VERSION_1_0 {
          GetPhysicalDeviceCalibrateableTimeDomainsEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, pTimeDomainCount: *mut u32, pTimeDomains: *mut TimeDomainEXT) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetPhysicalDeviceCalibrateableTimeDomainsEXT_panic as extern "system" fn (physicalDevice: PhysicalDevice, pTimeDomainCount: *mut u32, pTimeDomains: *mut TimeDomainEXT) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetCalibratedTimestampsEXT").unwrap();
        let GetCalibratedTimestampsEXT_ptr = if feature < VERSION_1_0 {
          GetCalibratedTimestampsEXT_panic as extern "system" fn (device: Device, timestampCount: u32, pTimestampInfos: *const CalibratedTimestampInfoEXT, pTimestamps: *mut u64, pMaxDeviation: *mut u64) -> Result
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetCalibratedTimestampsEXT_panic as extern "system" fn (device: Device, timestampCount: u32, pTimestampInfos: *const CalibratedTimestampInfoEXT, pTimestamps: *mut u64, pMaxDeviation: *mut u64) -> Result
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDrawMeshTasksNV").unwrap();
        let CmdDrawMeshTasksNV_ptr = if feature < VERSION_1_0 {
          CmdDrawMeshTasksNV_panic as extern "system" fn (commandBuffer: CommandBuffer, taskCount: u32, firstTask: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDrawMeshTasksNV_panic as extern "system" fn (commandBuffer: CommandBuffer, taskCount: u32, firstTask: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDrawMeshTasksIndirectNV").unwrap();
        let CmdDrawMeshTasksIndirectNV_ptr = if feature < VERSION_1_0 {
          CmdDrawMeshTasksIndirectNV_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDrawMeshTasksIndirectNV_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdDrawMeshTasksIndirectCountNV").unwrap();
        let CmdDrawMeshTasksIndirectCountNV_ptr = if feature < VERSION_1_0 {
          CmdDrawMeshTasksIndirectCountNV_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdDrawMeshTasksIndirectCountNV_panic as extern "system" fn (commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdSetExclusiveScissorNV").unwrap();
        let CmdSetExclusiveScissorNV_ptr = if feature < VERSION_1_0 {
          CmdSetExclusiveScissorNV_panic as extern "system" fn (commandBuffer: CommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *const Rect2D)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdSetExclusiveScissorNV_panic as extern "system" fn (commandBuffer: CommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *const Rect2D)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkCmdSetCheckpointNV").unwrap();
        let CmdSetCheckpointNV_ptr = if feature < VERSION_1_0 {
          CmdSetCheckpointNV_panic as extern "system" fn (commandBuffer: CommandBuffer, pCheckpointMarker: *const c_void)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            CmdSetCheckpointNV_panic as extern "system" fn (commandBuffer: CommandBuffer, pCheckpointMarker: *const c_void)
          } else {
            mem::transmute(ptr)
          }
        };
        
        name = std::ffi::CString::new("vkGetQueueCheckpointDataNV").unwrap();
        let GetQueueCheckpointDataNV_ptr = if feature < VERSION_1_0 {
          GetQueueCheckpointDataNV_panic as extern "system" fn (queue: Queue, pCheckpointDataCount: *mut u32, pCheckpointData: *mut CheckpointDataNV)
        } else {
          ptr = GetDeviceProcAddr(hdevice, name.as_ptr());
          if (ptr as *const c_void).is_null() {
            GetQueueCheckpointDataNV_panic as extern "system" fn (queue: Queue, pCheckpointDataCount: *mut u32, pCheckpointData: *mut CheckpointDataNV)
          } else {
            mem::transmute(ptr)
          }
        };
        

      DeviceExtensions {
        hdevice,
        CreateSwapchainKHR_ptr,
        DestroySwapchainKHR_ptr,
        GetSwapchainImagesKHR_ptr,
        AcquireNextImageKHR_ptr,
        QueuePresentKHR_ptr,
        GetDeviceGroupPresentCapabilitiesKHR_ptr,
        GetDeviceGroupSurfacePresentModesKHR_ptr,
        GetPhysicalDevicePresentRectanglesKHR_ptr,
        AcquireNextImage2KHR_ptr,
        CreateSharedSwapchainsKHR_ptr,
        DebugMarkerSetObjectTagEXT_ptr,
        DebugMarkerSetObjectNameEXT_ptr,
        CmdDebugMarkerBeginEXT_ptr,
        CmdDebugMarkerEndEXT_ptr,
        CmdDebugMarkerInsertEXT_ptr,
        CmdBindTransformFeedbackBuffersEXT_ptr,
        CmdBeginTransformFeedbackEXT_ptr,
        CmdEndTransformFeedbackEXT_ptr,
        CmdBeginQueryIndexedEXT_ptr,
        CmdEndQueryIndexedEXT_ptr,
        CmdDrawIndirectByteCountEXT_ptr,
        CmdDrawIndirectCountAMD_ptr,
        CmdDrawIndexedIndirectCountAMD_ptr,
        GetShaderInfoAMD_ptr,
        GetMemoryWin32HandleNV_ptr,
        GetMemoryWin32HandleKHR_ptr,
        GetMemoryWin32HandlePropertiesKHR_ptr,
        GetMemoryFdKHR_ptr,
        GetMemoryFdPropertiesKHR_ptr,
        ImportSemaphoreWin32HandleKHR_ptr,
        GetSemaphoreWin32HandleKHR_ptr,
        ImportSemaphoreFdKHR_ptr,
        GetSemaphoreFdKHR_ptr,
        CmdPushDescriptorSetKHR_ptr,
        CmdPushDescriptorSetWithTemplateKHR_ptr,
        CmdBeginConditionalRenderingEXT_ptr,
        CmdEndConditionalRenderingEXT_ptr,
        CmdProcessCommandsNVX_ptr,
        CmdReserveSpaceForCommandsNVX_ptr,
        CreateIndirectCommandsLayoutNVX_ptr,
        DestroyIndirectCommandsLayoutNVX_ptr,
        CreateObjectTableNVX_ptr,
        DestroyObjectTableNVX_ptr,
        RegisterObjectsNVX_ptr,
        UnregisterObjectsNVX_ptr,
        GetPhysicalDeviceGeneratedCommandsPropertiesNVX_ptr,
        CmdSetViewportWScalingNV_ptr,
        DisplayPowerControlEXT_ptr,
        RegisterDeviceEventEXT_ptr,
        RegisterDisplayEventEXT_ptr,
        GetSwapchainCounterEXT_ptr,
        GetRefreshCycleDurationGOOGLE_ptr,
        GetPastPresentationTimingGOOGLE_ptr,
        CmdSetDiscardRectangleEXT_ptr,
        SetHdrMetadataEXT_ptr,
        CreateRenderPass2KHR_ptr,
        CmdBeginRenderPass2KHR_ptr,
        CmdNextSubpass2KHR_ptr,
        CmdEndRenderPass2KHR_ptr,
        GetSwapchainStatusKHR_ptr,
        ImportFenceWin32HandleKHR_ptr,
        GetFenceWin32HandleKHR_ptr,
        ImportFenceFdKHR_ptr,
        GetFenceFdKHR_ptr,
        GetAndroidHardwareBufferPropertiesANDROID_ptr,
        GetMemoryAndroidHardwareBufferANDROID_ptr,
        CmdSetSampleLocationsEXT_ptr,
        GetPhysicalDeviceMultisamplePropertiesEXT_ptr,
        GetImageDrmFormatModifierPropertiesEXT_ptr,
        CreateValidationCacheEXT_ptr,
        DestroyValidationCacheEXT_ptr,
        MergeValidationCachesEXT_ptr,
        GetValidationCacheDataEXT_ptr,
        CmdBindShadingRateImageNV_ptr,
        CmdSetViewportShadingRatePaletteNV_ptr,
        CmdSetCoarseSampleOrderNV_ptr,
        CreateAccelerationStructureNV_ptr,
        DestroyAccelerationStructureNV_ptr,
        GetAccelerationStructureMemoryRequirementsNV_ptr,
        BindAccelerationStructureMemoryNV_ptr,
        CmdBuildAccelerationStructureNV_ptr,
        CmdCopyAccelerationStructureNV_ptr,
        CmdTraceRaysNV_ptr,
        CreateRayTracingPipelinesNV_ptr,
        GetRayTracingShaderGroupHandlesNV_ptr,
        GetAccelerationStructureHandleNV_ptr,
        CmdWriteAccelerationStructuresPropertiesNV_ptr,
        CompileDeferredNV_ptr,
        CmdDrawIndirectCountKHR_ptr,
        CmdDrawIndexedIndirectCountKHR_ptr,
        GetMemoryHostPointerPropertiesEXT_ptr,
        CmdWriteBufferMarkerAMD_ptr,
        GetPhysicalDeviceCalibrateableTimeDomainsEXT_ptr,
        GetCalibratedTimestampsEXT_ptr,
        CmdDrawMeshTasksNV_ptr,
        CmdDrawMeshTasksIndirectNV_ptr,
        CmdDrawMeshTasksIndirectCountNV_ptr,
        CmdSetExclusiveScissorNV_ptr,
        CmdSetCheckpointNV_ptr,
        GetQueueCheckpointDataNV_ptr,
      }
    }
  }


  /// Retrieve the vulkan handle of the DeviceExtensions
  pub fn get_handle(&self) -> Device {
    self.hdevice
  }

  #[doc(hidden)] pub fn CreateSwapchainKHR(&self, device: Device, pCreateInfo: *const SwapchainCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSwapchain: *mut SwapchainKHR) -> Result{
    (self.CreateSwapchainKHR_ptr)(device, pCreateInfo, pAllocator, pSwapchain)
  }
  #[doc(hidden)] pub fn DestroySwapchainKHR(&self, device: Device, swapchain: SwapchainKHR, pAllocator: *const AllocationCallbacks){
    (self.DestroySwapchainKHR_ptr)(device, swapchain, pAllocator)
  }
  #[doc(hidden)] pub fn GetSwapchainImagesKHR(&self, device: Device, swapchain: SwapchainKHR, pSwapchainImageCount: *mut u32, pSwapchainImages: *mut Image) -> Result{
    (self.GetSwapchainImagesKHR_ptr)(device, swapchain, pSwapchainImageCount, pSwapchainImages)
  }
  #[doc(hidden)] pub fn AcquireNextImageKHR(&self, device: Device, swapchain: SwapchainKHR, timeout: u64, semaphore: Semaphore, fence: Fence, pImageIndex: *mut u32) -> Result{
    (self.AcquireNextImageKHR_ptr)(device, swapchain, timeout, semaphore, fence, pImageIndex)
  }
  #[doc(hidden)] pub fn QueuePresentKHR(&self, queue: Queue, pPresentInfo: *const PresentInfoKHR) -> Result{
    (self.QueuePresentKHR_ptr)(queue, pPresentInfo)
  }
  #[doc(hidden)] pub fn GetDeviceGroupPresentCapabilitiesKHR(&self, device: Device, pDeviceGroupPresentCapabilities: *mut DeviceGroupPresentCapabilitiesKHR) -> Result{
    (self.GetDeviceGroupPresentCapabilitiesKHR_ptr)(device, pDeviceGroupPresentCapabilities)
  }
  #[doc(hidden)] pub fn GetDeviceGroupSurfacePresentModesKHR(&self, device: Device, surface: SurfaceKHR, pModes: *mut DeviceGroupPresentModeFlagsKHR) -> Result{
    (self.GetDeviceGroupSurfacePresentModesKHR_ptr)(device, surface, pModes)
  }
  #[doc(hidden)] pub fn GetPhysicalDevicePresentRectanglesKHR(&self, physicalDevice: PhysicalDevice, surface: SurfaceKHR, pRectCount: *mut u32, pRects: *mut Rect2D) -> Result{
    (self.GetPhysicalDevicePresentRectanglesKHR_ptr)(physicalDevice, surface, pRectCount, pRects)
  }
  #[doc(hidden)] pub fn AcquireNextImage2KHR(&self, device: Device, pAcquireInfo: *const AcquireNextImageInfoKHR, pImageIndex: *mut u32) -> Result{
    (self.AcquireNextImage2KHR_ptr)(device, pAcquireInfo, pImageIndex)
  }
  #[doc(hidden)] pub fn CreateSharedSwapchainsKHR(&self, device: Device, swapchainCount: u32, pCreateInfos: *const SwapchainCreateInfoKHR, pAllocator: *const AllocationCallbacks, pSwapchains: *mut SwapchainKHR) -> Result{
    (self.CreateSharedSwapchainsKHR_ptr)(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains)
  }
  #[doc(hidden)] pub fn DebugMarkerSetObjectTagEXT(&self, device: Device, pTagInfo: *const DebugMarkerObjectTagInfoEXT) -> Result{
    (self.DebugMarkerSetObjectTagEXT_ptr)(device, pTagInfo)
  }
  #[doc(hidden)] pub fn DebugMarkerSetObjectNameEXT(&self, device: Device, pNameInfo: *const DebugMarkerObjectNameInfoEXT) -> Result{
    (self.DebugMarkerSetObjectNameEXT_ptr)(device, pNameInfo)
  }
  #[doc(hidden)] pub fn CmdDebugMarkerBeginEXT(&self, commandBuffer: CommandBuffer, pMarkerInfo: *const DebugMarkerMarkerInfoEXT){
    (self.CmdDebugMarkerBeginEXT_ptr)(commandBuffer, pMarkerInfo)
  }
  #[doc(hidden)] pub fn CmdDebugMarkerEndEXT(&self, commandBuffer: CommandBuffer){
    (self.CmdDebugMarkerEndEXT_ptr)(commandBuffer)
  }
  #[doc(hidden)] pub fn CmdDebugMarkerInsertEXT(&self, commandBuffer: CommandBuffer, pMarkerInfo: *const DebugMarkerMarkerInfoEXT){
    (self.CmdDebugMarkerInsertEXT_ptr)(commandBuffer, pMarkerInfo)
  }
  #[doc(hidden)] pub fn CmdBindTransformFeedbackBuffersEXT(&self, commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const Buffer, pOffsets: *const DeviceSize, pSizes: *const DeviceSize){
    (self.CmdBindTransformFeedbackBuffersEXT_ptr)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes)
  }
  #[doc(hidden)] pub fn CmdBeginTransformFeedbackEXT(&self, commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const Buffer, pCounterBufferOffsets: *const DeviceSize){
    (self.CmdBeginTransformFeedbackEXT_ptr)(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)
  }
  #[doc(hidden)] pub fn CmdEndTransformFeedbackEXT(&self, commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const Buffer, pCounterBufferOffsets: *const DeviceSize){
    (self.CmdEndTransformFeedbackEXT_ptr)(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)
  }
  #[doc(hidden)] pub fn CmdBeginQueryIndexedEXT(&self, commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags, index: u32){
    (self.CmdBeginQueryIndexedEXT_ptr)(commandBuffer, queryPool, query, flags, index)
  }
  #[doc(hidden)] pub fn CmdEndQueryIndexedEXT(&self, commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, index: u32){
    (self.CmdEndQueryIndexedEXT_ptr)(commandBuffer, queryPool, query, index)
  }
  #[doc(hidden)] pub fn CmdDrawIndirectByteCountEXT(&self, commandBuffer: CommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: Buffer, counterBufferOffset: DeviceSize, counterOffset: u32, vertexStride: u32){
    (self.CmdDrawIndirectByteCountEXT_ptr)(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride)
  }
  #[doc(hidden)] pub fn CmdDrawIndirectCountAMD(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32){
    (self.CmdDrawIndirectCountAMD_ptr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
  }
  #[doc(hidden)] pub fn CmdDrawIndexedIndirectCountAMD(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32){
    (self.CmdDrawIndexedIndirectCountAMD_ptr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
  }
  #[doc(hidden)] pub fn GetShaderInfoAMD(&self, device: Device, pipeline: Pipeline, shaderStage: ShaderStageFlagBits, infoType: ShaderInfoTypeAMD, pInfoSize: *mut usize, pInfo: *mut c_void) -> Result{
    (self.GetShaderInfoAMD_ptr)(device, pipeline, shaderStage, infoType, pInfoSize, pInfo)
  }
  #[doc(hidden)] pub fn GetMemoryWin32HandleNV(&self, device: Device, memory: DeviceMemory, handleType: ExternalMemoryHandleTypeFlagsNV, pHandle: *mut HANDLE) -> Result{
    (self.GetMemoryWin32HandleNV_ptr)(device, memory, handleType, pHandle)
  }
  #[doc(hidden)] pub fn GetMemoryWin32HandleKHR(&self, device: Device, pGetWin32HandleInfo: *const MemoryGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result{
    (self.GetMemoryWin32HandleKHR_ptr)(device, pGetWin32HandleInfo, pHandle)
  }
  #[doc(hidden)] pub fn GetMemoryWin32HandlePropertiesKHR(&self, device: Device, handleType: ExternalMemoryHandleTypeFlagBits, handle: HANDLE, pMemoryWin32HandleProperties: *mut MemoryWin32HandlePropertiesKHR) -> Result{
    (self.GetMemoryWin32HandlePropertiesKHR_ptr)(device, handleType, handle, pMemoryWin32HandleProperties)
  }
  #[doc(hidden)] pub fn GetMemoryFdKHR(&self, device: Device, pGetFdInfo: *const MemoryGetFdInfoKHR, pFd: *mut i32) -> Result{
    (self.GetMemoryFdKHR_ptr)(device, pGetFdInfo, pFd)
  }
  #[doc(hidden)] pub fn GetMemoryFdPropertiesKHR(&self, device: Device, handleType: ExternalMemoryHandleTypeFlagBits, fd: i32, pMemoryFdProperties: *mut MemoryFdPropertiesKHR) -> Result{
    (self.GetMemoryFdPropertiesKHR_ptr)(device, handleType, fd, pMemoryFdProperties)
  }
  #[doc(hidden)] pub fn ImportSemaphoreWin32HandleKHR(&self, device: Device, pImportSemaphoreWin32HandleInfo: *const ImportSemaphoreWin32HandleInfoKHR) -> Result{
    (self.ImportSemaphoreWin32HandleKHR_ptr)(device, pImportSemaphoreWin32HandleInfo)
  }
  #[doc(hidden)] pub fn GetSemaphoreWin32HandleKHR(&self, device: Device, pGetWin32HandleInfo: *const SemaphoreGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result{
    (self.GetSemaphoreWin32HandleKHR_ptr)(device, pGetWin32HandleInfo, pHandle)
  }
  #[doc(hidden)] pub fn ImportSemaphoreFdKHR(&self, device: Device, pImportSemaphoreFdInfo: *const ImportSemaphoreFdInfoKHR) -> Result{
    (self.ImportSemaphoreFdKHR_ptr)(device, pImportSemaphoreFdInfo)
  }
  #[doc(hidden)] pub fn GetSemaphoreFdKHR(&self, device: Device, pGetFdInfo: *const SemaphoreGetFdInfoKHR, pFd: *mut i32) -> Result{
    (self.GetSemaphoreFdKHR_ptr)(device, pGetFdInfo, pFd)
  }
  #[doc(hidden)] pub fn CmdPushDescriptorSetKHR(&self, commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const WriteDescriptorSet){
    (self.CmdPushDescriptorSetKHR_ptr)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)
  }
  #[doc(hidden)] pub fn CmdPushDescriptorSetWithTemplateKHR(&self, commandBuffer: CommandBuffer, descriptorUpdateTemplate: DescriptorUpdateTemplate, layout: PipelineLayout, set: u32, pData: *const c_void){
    (self.CmdPushDescriptorSetWithTemplateKHR_ptr)(commandBuffer, descriptorUpdateTemplate, layout, set, pData)
  }
  #[doc(hidden)] pub fn CmdBeginConditionalRenderingEXT(&self, commandBuffer: CommandBuffer, pConditionalRenderingBegin: *const ConditionalRenderingBeginInfoEXT){
    (self.CmdBeginConditionalRenderingEXT_ptr)(commandBuffer, pConditionalRenderingBegin)
  }
  #[doc(hidden)] pub fn CmdEndConditionalRenderingEXT(&self, commandBuffer: CommandBuffer){
    (self.CmdEndConditionalRenderingEXT_ptr)(commandBuffer)
  }
  #[doc(hidden)] pub fn CmdProcessCommandsNVX(&self, commandBuffer: CommandBuffer, pProcessCommandsInfo: *const CmdProcessCommandsInfoNVX){
    (self.CmdProcessCommandsNVX_ptr)(commandBuffer, pProcessCommandsInfo)
  }
  #[doc(hidden)] pub fn CmdReserveSpaceForCommandsNVX(&self, commandBuffer: CommandBuffer, pReserveSpaceInfo: *const CmdReserveSpaceForCommandsInfoNVX){
    (self.CmdReserveSpaceForCommandsNVX_ptr)(commandBuffer, pReserveSpaceInfo)
  }
  #[doc(hidden)] pub fn CreateIndirectCommandsLayoutNVX(&self, device: Device, pCreateInfo: *const IndirectCommandsLayoutCreateInfoNVX, pAllocator: *const AllocationCallbacks, pIndirectCommandsLayout: *mut IndirectCommandsLayoutNVX) -> Result{
    (self.CreateIndirectCommandsLayoutNVX_ptr)(device, pCreateInfo, pAllocator, pIndirectCommandsLayout)
  }
  #[doc(hidden)] pub fn DestroyIndirectCommandsLayoutNVX(&self, device: Device, indirectCommandsLayout: IndirectCommandsLayoutNVX, pAllocator: *const AllocationCallbacks){
    (self.DestroyIndirectCommandsLayoutNVX_ptr)(device, indirectCommandsLayout, pAllocator)
  }
  #[doc(hidden)] pub fn CreateObjectTableNVX(&self, device: Device, pCreateInfo: *const ObjectTableCreateInfoNVX, pAllocator: *const AllocationCallbacks, pObjectTable: *mut ObjectTableNVX) -> Result{
    (self.CreateObjectTableNVX_ptr)(device, pCreateInfo, pAllocator, pObjectTable)
  }
  #[doc(hidden)] pub fn DestroyObjectTableNVX(&self, device: Device, objectTable: ObjectTableNVX, pAllocator: *const AllocationCallbacks){
    (self.DestroyObjectTableNVX_ptr)(device, objectTable, pAllocator)
  }
  #[doc(hidden)] pub fn RegisterObjectsNVX(&self, device: Device, objectTable: ObjectTableNVX, objectCount: u32, ppObjectTableEntries: *const *const ObjectTableEntryNVX, pObjectIndices: *const u32) -> Result{
    (self.RegisterObjectsNVX_ptr)(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices)
  }
  #[doc(hidden)] pub fn UnregisterObjectsNVX(&self, device: Device, objectTable: ObjectTableNVX, objectCount: u32, pObjectEntryTypes: *const ObjectEntryTypeNVX, pObjectIndices: *const u32) -> Result{
    (self.UnregisterObjectsNVX_ptr)(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceGeneratedCommandsPropertiesNVX(&self, physicalDevice: PhysicalDevice, pFeatures: *mut DeviceGeneratedCommandsFeaturesNVX, pLimits: *mut DeviceGeneratedCommandsLimitsNVX){
    (self.GetPhysicalDeviceGeneratedCommandsPropertiesNVX_ptr)(physicalDevice, pFeatures, pLimits)
  }
  #[doc(hidden)] pub fn CmdSetViewportWScalingNV(&self, commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const ViewportWScalingNV){
    (self.CmdSetViewportWScalingNV_ptr)(commandBuffer, firstViewport, viewportCount, pViewportWScalings)
  }
  #[doc(hidden)] pub fn DisplayPowerControlEXT(&self, device: Device, display: DisplayKHR, pDisplayPowerInfo: *const DisplayPowerInfoEXT) -> Result{
    (self.DisplayPowerControlEXT_ptr)(device, display, pDisplayPowerInfo)
  }
  #[doc(hidden)] pub fn RegisterDeviceEventEXT(&self, device: Device, pDeviceEventInfo: *const DeviceEventInfoEXT, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result{
    (self.RegisterDeviceEventEXT_ptr)(device, pDeviceEventInfo, pAllocator, pFence)
  }
  #[doc(hidden)] pub fn RegisterDisplayEventEXT(&self, device: Device, display: DisplayKHR, pDisplayEventInfo: *const DisplayEventInfoEXT, pAllocator: *const AllocationCallbacks, pFence: *mut Fence) -> Result{
    (self.RegisterDisplayEventEXT_ptr)(device, display, pDisplayEventInfo, pAllocator, pFence)
  }
  #[doc(hidden)] pub fn GetSwapchainCounterEXT(&self, device: Device, swapchain: SwapchainKHR, counter: SurfaceCounterFlagBitsEXT, pCounterValue: *mut u64) -> Result{
    (self.GetSwapchainCounterEXT_ptr)(device, swapchain, counter, pCounterValue)
  }
  #[doc(hidden)] pub fn GetRefreshCycleDurationGOOGLE(&self, device: Device, swapchain: SwapchainKHR, pDisplayTimingProperties: *mut RefreshCycleDurationGOOGLE) -> Result{
    (self.GetRefreshCycleDurationGOOGLE_ptr)(device, swapchain, pDisplayTimingProperties)
  }
  #[doc(hidden)] pub fn GetPastPresentationTimingGOOGLE(&self, device: Device, swapchain: SwapchainKHR, pPresentationTimingCount: *mut u32, pPresentationTimings: *mut PastPresentationTimingGOOGLE) -> Result{
    (self.GetPastPresentationTimingGOOGLE_ptr)(device, swapchain, pPresentationTimingCount, pPresentationTimings)
  }
  #[doc(hidden)] pub fn CmdSetDiscardRectangleEXT(&self, commandBuffer: CommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const Rect2D){
    (self.CmdSetDiscardRectangleEXT_ptr)(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)
  }
  #[doc(hidden)] pub fn SetHdrMetadataEXT(&self, device: Device, swapchainCount: u32, pSwapchains: *const SwapchainKHR, pMetadata: *const HdrMetadataEXT){
    (self.SetHdrMetadataEXT_ptr)(device, swapchainCount, pSwapchains, pMetadata)
  }
  #[doc(hidden)] pub fn CreateRenderPass2KHR(&self, device: Device, pCreateInfo: *const RenderPassCreateInfo2KHR, pAllocator: *const AllocationCallbacks, pRenderPass: *mut RenderPass) -> Result{
    (self.CreateRenderPass2KHR_ptr)(device, pCreateInfo, pAllocator, pRenderPass)
  }
  #[doc(hidden)] pub fn CmdBeginRenderPass2KHR(&self, commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, pSubpassBeginInfo: *const SubpassBeginInfoKHR){
    (self.CmdBeginRenderPass2KHR_ptr)(commandBuffer, pRenderPassBegin, pSubpassBeginInfo)
  }
  #[doc(hidden)] pub fn CmdNextSubpass2KHR(&self, commandBuffer: CommandBuffer, pSubpassBeginInfo: *const SubpassBeginInfoKHR, pSubpassEndInfo: *const SubpassEndInfoKHR){
    (self.CmdNextSubpass2KHR_ptr)(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo)
  }
  #[doc(hidden)] pub fn CmdEndRenderPass2KHR(&self, commandBuffer: CommandBuffer, pSubpassEndInfo: *const SubpassEndInfoKHR){
    (self.CmdEndRenderPass2KHR_ptr)(commandBuffer, pSubpassEndInfo)
  }
  #[doc(hidden)] pub fn GetSwapchainStatusKHR(&self, device: Device, swapchain: SwapchainKHR) -> Result{
    (self.GetSwapchainStatusKHR_ptr)(device, swapchain)
  }
  #[doc(hidden)] pub fn ImportFenceWin32HandleKHR(&self, device: Device, pImportFenceWin32HandleInfo: *const ImportFenceWin32HandleInfoKHR) -> Result{
    (self.ImportFenceWin32HandleKHR_ptr)(device, pImportFenceWin32HandleInfo)
  }
  #[doc(hidden)] pub fn GetFenceWin32HandleKHR(&self, device: Device, pGetWin32HandleInfo: *const FenceGetWin32HandleInfoKHR, pHandle: *mut HANDLE) -> Result{
    (self.GetFenceWin32HandleKHR_ptr)(device, pGetWin32HandleInfo, pHandle)
  }
  #[doc(hidden)] pub fn ImportFenceFdKHR(&self, device: Device, pImportFenceFdInfo: *const ImportFenceFdInfoKHR) -> Result{
    (self.ImportFenceFdKHR_ptr)(device, pImportFenceFdInfo)
  }
  #[doc(hidden)] pub fn GetFenceFdKHR(&self, device: Device, pGetFdInfo: *const FenceGetFdInfoKHR, pFd: *mut i32) -> Result{
    (self.GetFenceFdKHR_ptr)(device, pGetFdInfo, pFd)
  }
  #[doc(hidden)] pub fn GetAndroidHardwareBufferPropertiesANDROID(&self, device: Device, buffer: *const AHardwareBuffer, pProperties: *mut AndroidHardwareBufferPropertiesANDROID) -> Result{
    (self.GetAndroidHardwareBufferPropertiesANDROID_ptr)(device, buffer, pProperties)
  }
  #[doc(hidden)] pub fn GetMemoryAndroidHardwareBufferANDROID(&self, device: Device, pInfo: *const MemoryGetAndroidHardwareBufferInfoANDROID, pBuffer: *mut *mut AHardwareBuffer) -> Result{
    (self.GetMemoryAndroidHardwareBufferANDROID_ptr)(device, pInfo, pBuffer)
  }
  #[doc(hidden)] pub fn CmdSetSampleLocationsEXT(&self, commandBuffer: CommandBuffer, pSampleLocationsInfo: *const SampleLocationsInfoEXT){
    (self.CmdSetSampleLocationsEXT_ptr)(commandBuffer, pSampleLocationsInfo)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceMultisamplePropertiesEXT(&self, physicalDevice: PhysicalDevice, samples: SampleCountFlagBits, pMultisampleProperties: *mut MultisamplePropertiesEXT){
    (self.GetPhysicalDeviceMultisamplePropertiesEXT_ptr)(physicalDevice, samples, pMultisampleProperties)
  }
  #[doc(hidden)] pub fn GetImageDrmFormatModifierPropertiesEXT(&self, device: Device, image: Image, pProperties: *mut ImageDrmFormatModifierPropertiesEXT) -> Result{
    (self.GetImageDrmFormatModifierPropertiesEXT_ptr)(device, image, pProperties)
  }
  #[doc(hidden)] pub fn CreateValidationCacheEXT(&self, device: Device, pCreateInfo: *const ValidationCacheCreateInfoEXT, pAllocator: *const AllocationCallbacks, pValidationCache: *mut ValidationCacheEXT) -> Result{
    (self.CreateValidationCacheEXT_ptr)(device, pCreateInfo, pAllocator, pValidationCache)
  }
  #[doc(hidden)] pub fn DestroyValidationCacheEXT(&self, device: Device, validationCache: ValidationCacheEXT, pAllocator: *const AllocationCallbacks){
    (self.DestroyValidationCacheEXT_ptr)(device, validationCache, pAllocator)
  }
  #[doc(hidden)] pub fn MergeValidationCachesEXT(&self, device: Device, dstCache: ValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *const ValidationCacheEXT) -> Result{
    (self.MergeValidationCachesEXT_ptr)(device, dstCache, srcCacheCount, pSrcCaches)
  }
  #[doc(hidden)] pub fn GetValidationCacheDataEXT(&self, device: Device, validationCache: ValidationCacheEXT, pDataSize: *mut usize, pData: *mut c_void) -> Result{
    (self.GetValidationCacheDataEXT_ptr)(device, validationCache, pDataSize, pData)
  }
  #[doc(hidden)] pub fn CmdBindShadingRateImageNV(&self, commandBuffer: CommandBuffer, imageView: ImageView, imageLayout: ImageLayout){
    (self.CmdBindShadingRateImageNV_ptr)(commandBuffer, imageView, imageLayout)
  }
  #[doc(hidden)] pub fn CmdSetViewportShadingRatePaletteNV(&self, commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *const ShadingRatePaletteNV){
    (self.CmdSetViewportShadingRatePaletteNV_ptr)(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes)
  }
  #[doc(hidden)] pub fn CmdSetCoarseSampleOrderNV(&self, commandBuffer: CommandBuffer, sampleOrderType: CoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *const CoarseSampleOrderCustomNV){
    (self.CmdSetCoarseSampleOrderNV_ptr)(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders)
  }
  #[doc(hidden)] pub fn CreateAccelerationStructureNV(&self, device: Device, pCreateInfo: *const AccelerationStructureCreateInfoNV, pAllocator: *const AllocationCallbacks, pAccelerationStructure: *mut AccelerationStructureNV) -> Result{
    (self.CreateAccelerationStructureNV_ptr)(device, pCreateInfo, pAllocator, pAccelerationStructure)
  }
  #[doc(hidden)] pub fn DestroyAccelerationStructureNV(&self, device: Device, accelerationStructure: AccelerationStructureNV, pAllocator: *const AllocationCallbacks){
    (self.DestroyAccelerationStructureNV_ptr)(device, accelerationStructure, pAllocator)
  }
  #[doc(hidden)] pub fn GetAccelerationStructureMemoryRequirementsNV(&self, device: Device, pInfo: *const AccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *mut MemoryRequirements2){
    (self.GetAccelerationStructureMemoryRequirementsNV_ptr)(device, pInfo, pMemoryRequirements)
  }
  #[doc(hidden)] pub fn BindAccelerationStructureMemoryNV(&self, device: Device, bindInfoCount: u32, pBindInfos: *const BindAccelerationStructureMemoryInfoNV) -> Result{
    (self.BindAccelerationStructureMemoryNV_ptr)(device, bindInfoCount, pBindInfos)
  }
  #[doc(hidden)] pub fn CmdBuildAccelerationStructureNV(&self, commandBuffer: CommandBuffer, pInfo: *const AccelerationStructureInfoNV, instanceData: Buffer, instanceOffset: DeviceSize, update: Bool32, dst: AccelerationStructureNV, src: AccelerationStructureNV, scratch: Buffer, scratchOffset: DeviceSize){
    (self.CmdBuildAccelerationStructureNV_ptr)(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset)
  }
  #[doc(hidden)] pub fn CmdCopyAccelerationStructureNV(&self, commandBuffer: CommandBuffer, dst: AccelerationStructureNV, src: AccelerationStructureNV, mode: CopyAccelerationStructureModeNV){
    (self.CmdCopyAccelerationStructureNV_ptr)(commandBuffer, dst, src, mode)
  }
  #[doc(hidden)] pub fn CmdTraceRaysNV(&self, commandBuffer: CommandBuffer, raygenShaderBindingTableBuffer: Buffer, raygenShaderBindingOffset: DeviceSize, missShaderBindingTableBuffer: Buffer, missShaderBindingOffset: DeviceSize, missShaderBindingStride: DeviceSize, hitShaderBindingTableBuffer: Buffer, hitShaderBindingOffset: DeviceSize, hitShaderBindingStride: DeviceSize, callableShaderBindingTableBuffer: Buffer, callableShaderBindingOffset: DeviceSize, callableShaderBindingStride: DeviceSize, width: u32, height: u32, depth: u32){
    (self.CmdTraceRaysNV_ptr)(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth)
  }
  #[doc(hidden)] pub fn CreateRayTracingPipelinesNV(&self, device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: *const RayTracingPipelineCreateInfoNV, pAllocator: *const AllocationCallbacks, pPipelines: *mut Pipeline) -> Result{
    (self.CreateRayTracingPipelinesNV_ptr)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
  }
  #[doc(hidden)] pub fn GetRayTracingShaderGroupHandlesNV(&self, device: Device, pipeline: Pipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> Result{
    (self.GetRayTracingShaderGroupHandlesNV_ptr)(device, pipeline, firstGroup, groupCount, dataSize, pData)
  }
  #[doc(hidden)] pub fn GetAccelerationStructureHandleNV(&self, device: Device, accelerationStructure: AccelerationStructureNV, dataSize: usize, pData: *mut c_void) -> Result{
    (self.GetAccelerationStructureHandleNV_ptr)(device, accelerationStructure, dataSize, pData)
  }
  #[doc(hidden)] pub fn CmdWriteAccelerationStructuresPropertiesNV(&self, commandBuffer: CommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *const AccelerationStructureNV, queryType: QueryType, queryPool: QueryPool, firstQuery: u32){
    (self.CmdWriteAccelerationStructuresPropertiesNV_ptr)(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery)
  }
  #[doc(hidden)] pub fn CompileDeferredNV(&self, device: Device, pipeline: Pipeline, shader: u32) -> Result{
    (self.CompileDeferredNV_ptr)(device, pipeline, shader)
  }
  #[doc(hidden)] pub fn CmdDrawIndirectCountKHR(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32){
    (self.CmdDrawIndirectCountKHR_ptr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
  }
  #[doc(hidden)] pub fn CmdDrawIndexedIndirectCountKHR(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32){
    (self.CmdDrawIndexedIndirectCountKHR_ptr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
  }
  #[doc(hidden)] pub fn GetMemoryHostPointerPropertiesEXT(&self, device: Device, handleType: ExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut MemoryHostPointerPropertiesEXT) -> Result{
    (self.GetMemoryHostPointerPropertiesEXT_ptr)(device, handleType, pHostPointer, pMemoryHostPointerProperties)
  }
  #[doc(hidden)] pub fn CmdWriteBufferMarkerAMD(&self, commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlagBits, dstBuffer: Buffer, dstOffset: DeviceSize, marker: u32){
    (self.CmdWriteBufferMarkerAMD_ptr)(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)
  }
  #[doc(hidden)] pub fn GetPhysicalDeviceCalibrateableTimeDomainsEXT(&self, physicalDevice: PhysicalDevice, pTimeDomainCount: *mut u32, pTimeDomains: *mut TimeDomainEXT) -> Result{
    (self.GetPhysicalDeviceCalibrateableTimeDomainsEXT_ptr)(physicalDevice, pTimeDomainCount, pTimeDomains)
  }
  #[doc(hidden)] pub fn GetCalibratedTimestampsEXT(&self, device: Device, timestampCount: u32, pTimestampInfos: *const CalibratedTimestampInfoEXT, pTimestamps: *mut u64, pMaxDeviation: *mut u64) -> Result{
    (self.GetCalibratedTimestampsEXT_ptr)(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation)
  }
  #[doc(hidden)] pub fn CmdDrawMeshTasksNV(&self, commandBuffer: CommandBuffer, taskCount: u32, firstTask: u32){
    (self.CmdDrawMeshTasksNV_ptr)(commandBuffer, taskCount, firstTask)
  }
  #[doc(hidden)] pub fn CmdDrawMeshTasksIndirectNV(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32){
    (self.CmdDrawMeshTasksIndirectNV_ptr)(commandBuffer, buffer, offset, drawCount, stride)
  }
  #[doc(hidden)] pub fn CmdDrawMeshTasksIndirectCountNV(&self, commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, countBuffer: Buffer, countBufferOffset: DeviceSize, maxDrawCount: u32, stride: u32){
    (self.CmdDrawMeshTasksIndirectCountNV_ptr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
  }
  #[doc(hidden)] pub fn CmdSetExclusiveScissorNV(&self, commandBuffer: CommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *const Rect2D){
    (self.CmdSetExclusiveScissorNV_ptr)(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors)
  }
  #[doc(hidden)] pub fn CmdSetCheckpointNV(&self, commandBuffer: CommandBuffer, pCheckpointMarker: *const c_void){
    (self.CmdSetCheckpointNV_ptr)(commandBuffer, pCheckpointMarker)
  }
  #[doc(hidden)] pub fn GetQueueCheckpointDataNV(&self, queue: Queue, pCheckpointDataCount: *mut u32, pCheckpointData: *mut CheckpointDataNV){
    (self.GetQueueCheckpointDataNV_ptr)(queue, pCheckpointDataCount, pCheckpointData)
  }
}



/// Wraps a call to a vulkan command and converts it's returned error code with [make_result](fn.make_result.html).
///
/// Prints debug information to std::out with the file and line number of the vulkan command.
/// This macro may only be used with vulkan commands that return a `nobs_vk::Result`
///
/// ## Example
/// ```rust
/// #[macro_use] extern crate nobs_vk as vk;
/// //...
/// # fn main() {
/// # let _vk_lib = vk::Core::new();
/// # let mut inst_ver = 0;
/// match vk_check!(vk::EnumerateInstanceVersion(&mut inst_ver)) {
///   Err(e) => println!("EnumerateInstanceVersion returned with: {:?}", e),
///   Ok(e) => println!("EnumerateInstanceVersion returned with: {:?}", e),
/// }
/// # }
/// ```
#[macro_export]
macro_rules! vk_check {
  ($fn:expr) => {{
    let r = $crate::make_result($fn);
    if let Err(e) = r {
      println!(
        "{} failed with {:?} in \"{}\" at line {}",
        stringify!($fn),
        e,
        file!(),
        line!()
      );
    }
    r
  }};
}

/// Same as [vk_check](macro.vk_check.html) but instead of returning the Result calls unwrap on it.
///
/// Still prints debug information to std::out with the file and line number of the vulkan command.
#[macro_export]
macro_rules! vk_uncheck {
  ($fn:expr) => {{ vk_check!($fn).unwrap() }};
}


/// Converts the integer error code from a vulkan command into a `Result<Success, Error>`
pub fn make_result(r: crate::Result) -> std::result::Result<Success, Error> {
  match r {
    SUCCESS => Ok(Success::SUCCESS),
    NOT_READY => Ok(Success::NOT_READY),
    TIMEOUT => Ok(Success::TIMEOUT),
    EVENT_SET => Ok(Success::EVENT_SET),
    EVENT_RESET => Ok(Success::EVENT_RESET),
    INCOMPLETE => Ok(Success::INCOMPLETE),
    ERROR_OUT_OF_HOST_MEMORY => Err(Error::ERROR_OUT_OF_HOST_MEMORY),
    ERROR_OUT_OF_DEVICE_MEMORY => Err(Error::ERROR_OUT_OF_DEVICE_MEMORY),
    ERROR_INITIALIZATION_FAILED => Err(Error::ERROR_INITIALIZATION_FAILED),
    ERROR_DEVICE_LOST => Err(Error::ERROR_DEVICE_LOST),
    ERROR_MEMORY_MAP_FAILED => Err(Error::ERROR_MEMORY_MAP_FAILED),
    ERROR_LAYER_NOT_PRESENT => Err(Error::ERROR_LAYER_NOT_PRESENT),
    ERROR_EXTENSION_NOT_PRESENT => Err(Error::ERROR_EXTENSION_NOT_PRESENT),
    ERROR_FEATURE_NOT_PRESENT => Err(Error::ERROR_FEATURE_NOT_PRESENT),
    ERROR_INCOMPATIBLE_DRIVER => Err(Error::ERROR_INCOMPATIBLE_DRIVER),
    ERROR_TOO_MANY_OBJECTS => Err(Error::ERROR_TOO_MANY_OBJECTS),
    ERROR_FORMAT_NOT_SUPPORTED => Err(Error::ERROR_FORMAT_NOT_SUPPORTED),
    ERROR_FRAGMENTED_POOL => Err(Error::ERROR_FRAGMENTED_POOL),
    ERROR_OUT_OF_POOL_MEMORY => Err(Error::ERROR_OUT_OF_POOL_MEMORY),
    ERROR_INVALID_EXTERNAL_HANDLE => Err(Error::ERROR_INVALID_EXTERNAL_HANDLE),
    ERROR_SURFACE_LOST_KHR => Err(Error::ERROR_SURFACE_LOST_KHR),
    ERROR_NATIVE_WINDOW_IN_USE_KHR => Err(Error::ERROR_NATIVE_WINDOW_IN_USE_KHR),
    SUBOPTIMAL_KHR => Ok(Success::SUBOPTIMAL_KHR),
    ERROR_OUT_OF_DATE_KHR => Err(Error::ERROR_OUT_OF_DATE_KHR),
    ERROR_INCOMPATIBLE_DISPLAY_KHR => Err(Error::ERROR_INCOMPATIBLE_DISPLAY_KHR),
    ERROR_VALIDATION_FAILED_EXT => Err(Error::ERROR_VALIDATION_FAILED_EXT),
    ERROR_INVALID_SHADER_NV => Err(Error::ERROR_INVALID_SHADER_NV),
    ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT => Err(Error::ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT),
    ERROR_FRAGMENTATION_EXT => Err(Error::ERROR_FRAGMENTATION_EXT),
    ERROR_NOT_PERMITTED_EXT => Err(Error::ERROR_NOT_PERMITTED_EXT),
    _ => Err(Error::UNKNOWN)
  }
}

/// Enum type for all successful return codes in `nobs_vk::Result`
#[derive(Debug, Clone, Copy)]
pub enum Success {
  SUCCESS,
  NOT_READY,
  TIMEOUT,
  EVENT_SET,
  EVENT_RESET,
  INCOMPLETE,
  SUBOPTIMAL_KHR,
}
impl Success {
  /// Gets the actual vulkan return code back.
  pub fn vk_result(&self) -> crate::Result {
    match self {
      Success::SUCCESS => crate::SUCCESS,
      Success::NOT_READY => crate::NOT_READY,
      Success::TIMEOUT => crate::TIMEOUT,
      Success::EVENT_SET => crate::EVENT_SET,
      Success::EVENT_RESET => crate::EVENT_RESET,
      Success::INCOMPLETE => crate::INCOMPLETE,
      Success::SUBOPTIMAL_KHR => crate::SUBOPTIMAL_KHR,
    }
  }
}

/// Enum type for all unsuccessful return codes in `nobs_vk::Result`
#[derive(Debug, Clone, Copy)]
pub enum Error  {
  ERROR_OUT_OF_HOST_MEMORY,
  ERROR_OUT_OF_DEVICE_MEMORY,
  ERROR_INITIALIZATION_FAILED,
  ERROR_DEVICE_LOST,
  ERROR_MEMORY_MAP_FAILED,
  ERROR_LAYER_NOT_PRESENT,
  ERROR_EXTENSION_NOT_PRESENT,
  ERROR_FEATURE_NOT_PRESENT,
  ERROR_INCOMPATIBLE_DRIVER,
  ERROR_TOO_MANY_OBJECTS,
  ERROR_FORMAT_NOT_SUPPORTED,
  ERROR_FRAGMENTED_POOL,
  ERROR_OUT_OF_POOL_MEMORY,
  ERROR_INVALID_EXTERNAL_HANDLE,
  ERROR_SURFACE_LOST_KHR,
  ERROR_NATIVE_WINDOW_IN_USE_KHR,
  ERROR_OUT_OF_DATE_KHR,
  ERROR_INCOMPATIBLE_DISPLAY_KHR,
  ERROR_VALIDATION_FAILED_EXT,
  ERROR_INVALID_SHADER_NV,
  ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
  ERROR_FRAGMENTATION_EXT,
  ERROR_NOT_PERMITTED_EXT,
  UNKNOWN,
}
impl Error {
  /// Gets the actual vulkan return code back.
  pub fn vk_result(&self) -> crate::Result {
    match self {
      Error::ERROR_OUT_OF_HOST_MEMORY => crate::ERROR_OUT_OF_HOST_MEMORY,
      Error::ERROR_OUT_OF_DEVICE_MEMORY => crate::ERROR_OUT_OF_DEVICE_MEMORY,
      Error::ERROR_INITIALIZATION_FAILED => crate::ERROR_INITIALIZATION_FAILED,
      Error::ERROR_DEVICE_LOST => crate::ERROR_DEVICE_LOST,
      Error::ERROR_MEMORY_MAP_FAILED => crate::ERROR_MEMORY_MAP_FAILED,
      Error::ERROR_LAYER_NOT_PRESENT => crate::ERROR_LAYER_NOT_PRESENT,
      Error::ERROR_EXTENSION_NOT_PRESENT => crate::ERROR_EXTENSION_NOT_PRESENT,
      Error::ERROR_FEATURE_NOT_PRESENT => crate::ERROR_FEATURE_NOT_PRESENT,
      Error::ERROR_INCOMPATIBLE_DRIVER => crate::ERROR_INCOMPATIBLE_DRIVER,
      Error::ERROR_TOO_MANY_OBJECTS => crate::ERROR_TOO_MANY_OBJECTS,
      Error::ERROR_FORMAT_NOT_SUPPORTED => crate::ERROR_FORMAT_NOT_SUPPORTED,
      Error::ERROR_FRAGMENTED_POOL => crate::ERROR_FRAGMENTED_POOL,
      Error::ERROR_OUT_OF_POOL_MEMORY => crate::ERROR_OUT_OF_POOL_MEMORY,
      Error::ERROR_INVALID_EXTERNAL_HANDLE => crate::ERROR_INVALID_EXTERNAL_HANDLE,
      Error::ERROR_SURFACE_LOST_KHR => crate::ERROR_SURFACE_LOST_KHR,
      Error::ERROR_NATIVE_WINDOW_IN_USE_KHR => crate::ERROR_NATIVE_WINDOW_IN_USE_KHR,
      Error::ERROR_OUT_OF_DATE_KHR => crate::ERROR_OUT_OF_DATE_KHR,
      Error::ERROR_INCOMPATIBLE_DISPLAY_KHR => crate::ERROR_INCOMPATIBLE_DISPLAY_KHR,
      Error::ERROR_VALIDATION_FAILED_EXT => crate::ERROR_VALIDATION_FAILED_EXT,
      Error::ERROR_INVALID_SHADER_NV => crate::ERROR_INVALID_SHADER_NV,
      Error::ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT => crate::ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
      Error::ERROR_FRAGMENTATION_EXT => crate::ERROR_FRAGMENTATION_EXT,
      Error::ERROR_NOT_PERMITTED_EXT => crate::ERROR_NOT_PERMITTED_EXT,
      Error::UNKNOWN => crate::Result::max_value(),
    }
  }
}



pub mod device;
pub mod instance;

